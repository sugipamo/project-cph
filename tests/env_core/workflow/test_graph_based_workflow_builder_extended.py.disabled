"""
Extended tests for GraphBasedWorkflowBuilder to improve coverage
"""
import pytest
from unittest.mock import Mock, patch, MagicMock, PropertyMock
from src.env_core.workflow.graph_based_workflow_builder import GraphBasedWorkflowBuilder
from src.env_core.workflow.request_execution_graph import (
    RequestExecutionGraph, RequestNode, DependencyEdge, DependencyType
)
from src.env_core.step.step import Step, StepType, StepContext
from src.domain.requests.shell.shell_request import ShellRequest
from src.domain.requests.file.file_request import FileRequest
from pathlib import Path


class TestGraphBasedWorkflowBuilderExtended:
    """Extended tests to cover missing lines"""
    
    def setup_method(self):
        """Setup test environment"""
        self.mock_context = Mock(spec=StepContext)
        self.mock_context.language = "python"
        self.mock_context.env_json = {
            "python": {"debug": {"enabled": True}}
        }
        self.builder = GraphBasedWorkflowBuilder(self.mock_context)
    
    def test_step_to_request_returns_none(self):
        """Test _step_to_request when PureRequestFactory returns None"""
        step = Mock(spec=Step)
        step.type = StepType.OJ
        step.cmd = ["oj", "test"]
        
        with patch('src.operations.factory.unified_request_factory.create_request') as mock_factory:
            mock_factory.return_value = None
            
            # Execute
            result = self.builder._step_to_request(step)
            
            # Verify
            assert result is None
            mock_factory.assert_called_once_with(step, context=self.mock_context)
    
    def test_build_graph_from_steps_with_skip_none_request(self):
        """Test _build_graph_from_steps skips steps that produce None requests"""
        # Create steps
        step1 = Mock(spec=Step)
        step1.type = StepType.SHELL
        step1.cmd = ["echo", "hello"]
        
        step2 = Mock(spec=Step)
        step2.type = StepType.OJ  # This will return None
        step2.cmd = ["oj", "test"]
        
        steps = [step1, step2]
        
        # Mock step to request conversion
        mock_request = Mock()
        with patch.object(self.builder, '_step_to_request', side_effect=[mock_request, None]):
            with patch.object(self.builder, '_extract_resource_info_from_step', 
                            return_value=(set(), set(), set(), set())):
                with patch.object(self.builder, '_build_dependencies'):
                    # Execute
                    graph = self.builder._build_graph_from_steps(steps)
        
        # Verify only one node was added
        assert len(graph.nodes) == 1
        assert "step_0" in graph.nodes
        assert "step_1" not in graph.nodes
    
    def test_build_dependencies_with_file_creation_dependencies(self):
        """Test _build_dependencies with file creation dependencies"""
        graph = RequestExecutionGraph()
        
        # Create nodes with file dependencies
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files={"output.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files=set(),
            creates_dirs=set(),
            reads_files={"output.txt"},
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify file creation dependency was added
        assert len(graph.edges) == 1
        edge = graph.edges[0]
        assert edge.from_node == "node1"
        assert edge.to_node == "node2"
        assert edge.dependency_type == DependencyType.FILE_CREATION
        assert edge.resource_path == "output.txt"
    
    def test_build_dependencies_with_directory_creation_dependencies(self):
        """Test _build_dependencies with directory creation dependencies"""
        graph = RequestExecutionGraph()
        
        # Create nodes with directory dependencies
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files=set(),
            creates_dirs={"output_dir"},
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files=set(),
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs={"output_dir"}
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify directory creation dependency was added
        assert len(graph.edges) == 1
        edge = graph.edges[0]
        assert edge.from_node == "node1"
        assert edge.to_node == "node2"
        assert edge.dependency_type == DependencyType.DIRECTORY_CREATION
        assert edge.resource_path == "output_dir"
    
    def test_build_dependencies_with_parent_directory_dependencies(self):
        """Test _build_dependencies with parent directory dependencies"""
        graph = RequestExecutionGraph()
        
        # Create nodes where node2 creates files in a directory created by node1
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files=set(),
            creates_dirs={"output_dir"},
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"output_dir/file.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify parent directory dependency was added
        assert len(graph.edges) == 1
        edge = graph.edges[0]
        assert edge.from_node == "node1"
        assert edge.to_node == "node2"
        assert edge.dependency_type == DependencyType.DIRECTORY_CREATION
    
    def test_build_dependencies_with_reverse_dependency_skip(self):
        """Test _build_dependencies skips adding sequential dependency when reverse exists"""
        graph = RequestExecutionGraph()
        
        # Create nodes
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files=set(),
            creates_dirs=set(),
            reads_files={"input.txt"},
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"input.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        
        # Add reverse dependency first (node2 -> node1)
        edge = DependencyEdge(
            from_node="node2",
            to_node="node1",
            dependency_type=DependencyType.FILE_CREATION,
            resource_path="input.txt"
        )
        graph.add_dependency(edge)
        
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify no sequential dependency was added (only the existing reverse dependency)
        assert len(graph.edges) == 1
        assert graph.edges[0].from_node == "node2"
        assert graph.edges[0].to_node == "node1"
    
    def test_build_dependencies_with_resource_conflict(self):
        """Test _build_dependencies adds sequential dependency for resource conflicts"""
        graph = RequestExecutionGraph()
        
        # Create nodes with resource conflict (both create same file)
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files={"conflict.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"conflict.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify sequential dependency was added due to conflict
        edges = [e for e in graph.edges if e.dependency_type == DependencyType.EXECUTION_ORDER]
        assert len(edges) == 1
        assert edges[0].from_node == "node1"
        assert edges[0].to_node == "node2"
        assert "resource conflict" in edges[0].description
    
    def test_build_dependencies_with_existing_dependency_skip(self):
        """Test _build_dependencies skips adding sequential when dependency exists"""
        graph = RequestExecutionGraph()
        
        # Create nodes
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files={"file1.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"file2.txt"},
            creates_dirs=set(),
            reads_files={"file1.txt"},
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute - this will add file dependency
        self.builder._build_dependencies(graph, nodes)
        
        # Verify only file dependency was added, no sequential dependency
        assert len(graph.edges) == 1
        assert graph.edges[0].dependency_type == DependencyType.FILE_CREATION
    
    def test_build_dependencies_multiple_creators_and_readers(self):
        """Test _build_dependencies with multiple creators and readers of same resource"""
        graph = RequestExecutionGraph()
        
        # Create nodes - two creators and two readers of same file
        creator1 = RequestNode(
            id="creator1",
            request=Mock(),
            creates_files={"shared.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        creator2 = RequestNode(
            id="creator2",
            request=Mock(),
            creates_files={"shared.txt"},
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        reader1 = RequestNode(
            id="reader1",
            request=Mock(),
            creates_files=set(),
            creates_dirs=set(),
            reads_files={"shared.txt"},
            requires_dirs=set()
        )
        
        reader2 = RequestNode(
            id="reader2",
            request=Mock(),
            creates_files=set(),
            creates_dirs=set(),
            reads_files={"shared.txt"},
            requires_dirs=set()
        )
        
        # Add in specific order
        for node in [creator1, creator2, reader1, reader2]:
            graph.add_request_node(node)
        
        nodes = [creator1, creator2, reader1, reader2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify dependencies were created correctly
        file_deps = [e for e in graph.edges if e.dependency_type == DependencyType.FILE_CREATION]
        assert len(file_deps) >= 2  # At least creator1->reader1 and creator1->reader2
    
    def test_build_graph_pure_with_request_generation_failure(self):
        """Test build_graph_pure when request generation fails"""
        # Create test steps
        step1 = Step(type=StepType.SHELL, cmd=["echo", "test"])
        step2 = Step(type=StepType.OJ, cmd=["oj", "test"])  # Will fail to convert
        steps = [step1, step2]
        
        # Mock the step to request conversion to return None for OJ step
        with patch.object(self.builder, '_step_to_request', side_effect=[Mock(), None]):
            # Execute
            graph, errors, warnings = self.builder.build_graph_pure(steps)
        
        # Verify graph was built with only successful conversions
        assert isinstance(graph, RequestExecutionGraph)
        assert len(graph.nodes) == 1  # Only the shell step
    
    def test_build_graph_pure_with_pure_function_errors(self):
        """Test build_graph_pure handling errors from pure functions"""
        steps = [Step(type=StepType.SHELL, cmd=["echo", "test"])]
        
        # Mock build_execution_graph_pure to return errors
        with patch('src.pure_functions.graph_builder_pure.build_execution_graph_pure') as mock_build:
            mock_result = Mock()
            mock_result.nodes = []
            mock_result.dependencies = []
            mock_result.errors = ["Test error"]
            mock_result.warnings = ["Test warning"]
            mock_build.return_value = mock_result
            
            # Execute
            graph, errors, warnings = self.builder.build_graph_pure(steps)
            
            # Verify errors and warnings were propagated
            assert errors == ["Test error"]
            assert warnings == ["Test warning"]
    
    def test_build_graph_pure_with_invalid_dependency_type(self):
        """Test build_graph_pure with invalid dependency type"""
        steps = [Step(type=StepType.SHELL, cmd=["echo", "test"])]
        
        # Mock build_execution_graph_pure
        with patch('src.pure_functions.graph_builder_pure.build_execution_graph_pure') as mock_build:
            mock_node = Mock()
            mock_node.id = "node1"
            mock_node.step = steps[0]
            mock_node.creates_files = set()
            mock_node.creates_dirs = set()
            mock_node.reads_files = set()
            mock_node.requires_dirs = set()
            mock_node.metadata = {}
            
            mock_dep = Mock()
            mock_dep.from_node_id = "node1"
            mock_dep.to_node_id = "node1"
            mock_dep.dependency_type = "INVALID_TYPE"  # Invalid type
            mock_dep.resource_path = None
            mock_dep.description = "Test"
            
            mock_result = Mock()
            mock_result.nodes = [mock_node]
            mock_result.dependencies = [mock_dep]
            mock_result.errors = []
            mock_result.warnings = []
            mock_build.return_value = mock_result
            
            with patch.object(self.builder, '_step_to_request', return_value=Mock()):
                # Execute
                graph, errors, warnings = self.builder.build_graph_pure(steps)
                
                # Verify - should default to EXECUTION_ORDER
                assert len(graph.edges) == 1
                assert graph.edges[0].dependency_type == DependencyType.EXECUTION_ORDER
    
    def test_validate_graph_with_cycles(self):
        """Test validate_graph with circular dependencies"""
        # Create a graph with cycles
        graph = RequestExecutionGraph()
        
        node1 = RequestNode("node1", Mock())
        node2 = RequestNode("node2", Mock())
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        
        # Add circular dependencies
        edge1 = DependencyEdge("node1", "node2", DependencyType.EXECUTION_ORDER)
        edge2 = DependencyEdge("node2", "node1", DependencyType.EXECUTION_ORDER)
        
        graph.add_dependency(edge1)
        graph.add_dependency(edge2)
        
        # Execute
        is_valid, messages = self.builder.validate_graph(graph)
        
        # Verify
        assert not is_valid
        assert any("Circular dependencies detected" in msg for msg in messages)
    
    def test_validate_graph_empty(self):
        """Test validate_graph with empty graph"""
        graph = RequestExecutionGraph()
        
        # Execute
        is_valid, messages = self.builder.validate_graph(graph)
        
        # Verify
        assert not is_valid
        assert any("No executable nodes in graph" in msg for msg in messages)
    
    def test_validate_graph_valid(self):
        """Test validate_graph with valid graph"""
        # Create a valid graph
        graph = RequestExecutionGraph()
        
        node1 = RequestNode("node1", Mock())
        node2 = RequestNode("node2", Mock())
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        
        edge = DependencyEdge("node1", "node2", DependencyType.EXECUTION_ORDER)
        graph.add_dependency(edge)
        
        # Execute
        is_valid, messages = self.builder.validate_graph(graph)
        
        # Verify
        assert is_valid
        assert any("Graph has" in msg and "execution groups" in msg for msg in messages)
        assert any("Group" in msg and "nodes can run in parallel" in msg for msg in messages)
    
    def test_validate_graph_with_get_parallel_groups_error(self):
        """Test validate_graph when get_parallel_groups raises exception"""
        graph = Mock(spec=RequestExecutionGraph)
        graph.nodes = {"node1": Mock()}
        graph.detect_cycles.return_value = []
        graph.get_parallel_groups.side_effect = ValueError("Test error")
        
        # Execute
        is_valid, messages = self.builder.validate_graph(graph)
        
        # Verify
        assert not is_valid
        assert any("Failed to determine execution groups" in msg for msg in messages)
    
    def test_is_parent_directory_edge_cases(self):
        """Test _is_parent_directory with various edge cases"""
        # Mock the pure function
        with patch('src.pure_functions.graph_builder_pure.is_parent_directory_pure') as mock_is_parent:
            mock_is_parent.return_value = True
            
            result = self.builder._is_parent_directory("/parent", "/parent/child")
            
            assert result is True
            mock_is_parent.assert_called_once_with("/parent", "/parent/child")
    
    def test_has_resource_conflict_comprehensive(self):
        """Test _has_resource_conflict with comprehensive scenarios"""
        # Create nodes with various resource overlaps
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files={"file1.txt", "file2.txt"},
            creates_dirs={"dir1", "dir2"},
            reads_files={"input.txt"},
            requires_dirs={"input_dir"}
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"file1.txt"},  # Conflict!
            creates_dirs={"dir3"},
            reads_files={"file2.txt"},  # Reading what node1 creates
            requires_dirs={"dir1"}  # Requiring what node1 creates
        )
        
        # Mock the pure function
        with patch('src.pure_functions.graph_builder_pure.has_resource_conflict_pure') as mock_conflict:
            mock_conflict.return_value = True
            
            result = self.builder._has_resource_conflict(node1, node2)
            
            assert result is True
            
            # Verify NodeInfo objects were created correctly
            call_args = mock_conflict.call_args[0]
            node_info1 = call_args[0]
            node_info2 = call_args[1]
            
            assert node_info1.creates_files == {"file1.txt", "file2.txt"}
            assert node_info2.creates_files == {"file1.txt"}
    
    def test_build_dependencies_break_on_duplicate_directory_dependency(self):
        """Test _build_dependencies breaks after adding directory dependency to avoid duplicates"""
        graph = RequestExecutionGraph()
        
        # Create nodes where multiple directories could create dependencies
        node1 = RequestNode(
            id="node1",
            request=Mock(),
            creates_files=set(),
            creates_dirs={"base_dir", "base_dir/sub"},  # Creates nested directories
            reads_files=set(),
            requires_dirs=set()
        )
        
        node2 = RequestNode(
            id="node2",
            request=Mock(),
            creates_files={"base_dir/file.txt"},  # Creates file in base_dir
            creates_dirs=set(),
            reads_files=set(),
            requires_dirs=set()
        )
        
        graph.add_request_node(node1)
        graph.add_request_node(node2)
        nodes = [node1, node2]
        
        # Execute
        self.builder._build_dependencies(graph, nodes)
        
        # Verify only one directory dependency was added (break prevents duplicates)
        dir_deps = [e for e in graph.edges if e.dependency_type == DependencyType.DIRECTORY_CREATION]
        assert len(dir_deps) == 1


class TestDebugConfigurationHandling:
    """Test debug configuration handling in graph builder"""
    
    def test_build_graph_with_debug_config_no_env_json(self):
        """Test _build_graph_from_steps when context has no env_json"""
        context = Mock()
        context.env_json = None
        context.language = "python"
        
        builder = GraphBasedWorkflowBuilder(context)
        
        # Create real Step object to test properly
        step = Step(type=StepType.SHELL, cmd=["ls"])
        
        # Execute
        graph = builder._build_graph_from_steps([step])
        
        # Verify graph was created
        assert isinstance(graph, RequestExecutionGraph)
        # The debug logger would have been initialized with whatever config was available
        assert hasattr(graph, 'debug_logger')
    
    def test_build_graph_with_debug_config_no_language_config(self):
        """Test _build_graph_from_steps when language config is missing"""
        context = Mock()
        context.env_json = {"other_language": {"debug": {"enabled": True}}}
        context.language = "python"  # Not in env_json
        
        builder = GraphBasedWorkflowBuilder(context)
        
        # Create real Step object to test properly
        step = Step(type=StepType.SHELL, cmd=["ls"])
        
        # Execute
        graph = builder._build_graph_from_steps([step])
        
        # Verify graph was created
        assert isinstance(graph, RequestExecutionGraph)
        # The debug logger would have been initialized with whatever config was available
        assert hasattr(graph, 'debug_logger')
    
    def test_build_graph_pure_with_debug_config_no_env_json(self):
        """Test build_graph_pure when context has no env_json"""
        context = Mock()
        context.env_json = None
        context.language = "python"
        
        builder = GraphBasedWorkflowBuilder(context)
        steps = [Step(type=StepType.SHELL, cmd=["echo", "test"])]
        
        # Mock the pure function
        with patch('src.pure_functions.graph_builder_pure.build_execution_graph_pure') as mock_build:
            mock_result = Mock()
            mock_result.nodes = []
            mock_result.dependencies = []
            mock_result.errors = []
            mock_result.warnings = []
            mock_build.return_value = mock_result
            
            # Execute
            graph, _, _ = builder.build_graph_pure(steps)
            
            # Verify graph was created
            assert isinstance(graph, RequestExecutionGraph)
            # The debug logger would have been initialized with whatever config was available
            assert hasattr(graph, 'debug_logger')