# バリデーションシステム移植計画

## 現状の問題点

### 1. Pythonバリデーションシステムの複雑性
- operations/validators配下の多数のバリデーター実装
- ComparisonValidator、ConfigurationValidator、PathValidatorなど分散した実装
- 動的型システムによる実行時エラーのリスク

### 2. Rustプロジェクトとの不整合
- 現在のRustプロジェクトに統一的なバリデーションフレームワークが欠如
- 型安全性を活かしたコンパイル時検証の不足
- エラーメッセージの一貫性欠如

## 対応方針

### Phase 1: バリデーション基盤の構築（優先度: 高）

#### 1.1 バリデータートレイトの定義
```rust
// src/domain/validation.rs
use async_trait::async_trait;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("Required field '{field}' is missing")]
    RequiredFieldMissing { field: String },
    
    #[error("Field '{field}' has invalid value: {reason}")]
    InvalidValue { field: String, reason: String },
    
    #[error("Type mismatch for field '{field}': expected {expected}, got {actual}")]
    TypeMismatch {
        field: String,
        expected: String,
        actual: String,
    },
    
    #[error("Constraint violation: {message}")]
    ConstraintViolation { message: String },
    
    #[error("Multiple validation errors")]
    Multiple(Vec<ValidationError>),
}

pub type ValidationResult<T> = Result<T, ValidationError>;

#[async_trait]
pub trait Validator<T>: Send + Sync {
    async fn validate(&self, value: &T) -> ValidationResult<()>;
    
    fn and<V: Validator<T>>(self, other: V) -> AndValidator<T, Self, V>
    where
        Self: Sized,
    {
        AndValidator::new(self, other)
    }
    
    fn or<V: Validator<T>>(self, other: V) -> OrValidator<T, Self, V>
    where
        Self: Sized,
    {
        OrValidator::new(self, other)
    }
}

pub trait Validatable {
    type Validator: Validator<Self>;
    
    fn validator() -> Self::Validator;
    
    fn validate(&self) -> ValidationResult<()> {
        futures::executor::block_on(Self::validator().validate(self))
    }
}
```

#### 1.2 基本バリデーターの実装
```rust
// src/application/validators/basic.rs
pub struct RequiredValidator<T> {
    field_name: String,
    _phantom: PhantomData<T>,
}

impl<T> RequiredValidator<T> {
    pub fn new(field_name: impl Into<String>) -> Self {
        Self {
            field_name: field_name.into(),
            _phantom: PhantomData,
        }
    }
}

#[async_trait]
impl<T> Validator<Option<T>> for RequiredValidator<T>
where
    T: Send + Sync,
{
    async fn validate(&self, value: &Option<T>) -> ValidationResult<()> {
        match value {
            Some(_) => Ok(()),
            None => Err(ValidationError::RequiredFieldMissing {
                field: self.field_name.clone(),
            }),
        }
    }
}

pub struct RangeValidator<T> {
    field_name: String,
    min: Option<T>,
    max: Option<T>,
}

impl<T> RangeValidator<T> {
    pub fn new(field_name: impl Into<String>) -> Self {
        Self {
            field_name: field_name.into(),
            min: None,
            max: None,
        }
    }
    
    pub fn min(mut self, min: T) -> Self {
        self.min = Some(min);
        self
    }
    
    pub fn max(mut self, max: T) -> Self {
        self.max = Some(max);
        self
    }
}

#[async_trait]
impl<T> Validator<T> for RangeValidator<T>
where
    T: PartialOrd + Display + Send + Sync,
{
    async fn validate(&self, value: &T) -> ValidationResult<()> {
        if let Some(ref min) = self.min {
            if value < min {
                return Err(ValidationError::ConstraintViolation {
                    message: format!(
                        "{} must be at least {}, got {}",
                        self.field_name, min, value
                    ),
                });
            }
        }
        
        if let Some(ref max) = self.max {
            if value > max {
                return Err(ValidationError::ConstraintViolation {
                    message: format!(
                        "{} must be at most {}, got {}",
                        self.field_name, max, value
                    ),
                });
            }
        }
        
        Ok(())
    }
}
```

### Phase 2: 高度なバリデーター（優先度: 高）

#### 2.1 文字列バリデーター
```rust
// src/application/validators/string.rs
use regex::Regex;

pub struct StringValidator {
    field_name: String,
    min_length: Option<usize>,
    max_length: Option<usize>,
    pattern: Option<Regex>,
    allowed_chars: Option<HashSet<char>>,
}

impl StringValidator {
    pub fn new(field_name: impl Into<String>) -> Self {
        Self {
            field_name: field_name.into(),
            min_length: None,
            max_length: None,
            pattern: None,
            allowed_chars: None,
        }
    }
    
    pub fn min_length(mut self, len: usize) -> Self {
        self.min_length = Some(len);
        self
    }
    
    pub fn max_length(mut self, len: usize) -> Self {
        self.max_length = Some(len);
        self
    }
    
    pub fn pattern(mut self, pattern: impl Into<String>) -> Result<Self, regex::Error> {
        self.pattern = Some(Regex::new(&pattern.into())?);
        Ok(self)
    }
    
    pub fn email(self) -> Self {
        self.pattern(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
            .unwrap()
    }
    
    pub fn alphanumeric(mut self) -> Self {
        self.allowed_chars = Some(
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
                .chars()
                .collect()
        );
        self
    }
}

#[async_trait]
impl Validator<String> for StringValidator {
    async fn validate(&self, value: &String) -> ValidationResult<()> {
        // 長さチェック
        if let Some(min) = self.min_length {
            if value.len() < min {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: format!("minimum length is {}, got {}", min, value.len()),
                });
            }
        }
        
        if let Some(max) = self.max_length {
            if value.len() > max {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: format!("maximum length is {}, got {}", max, value.len()),
                });
            }
        }
        
        // パターンチェック
        if let Some(ref pattern) = self.pattern {
            if !pattern.is_match(value) {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "does not match required pattern".to_string(),
                });
            }
        }
        
        // 許可文字チェック
        if let Some(ref allowed) = self.allowed_chars {
            for ch in value.chars() {
                if !allowed.contains(&ch) {
                    return Err(ValidationError::InvalidValue {
                        field: self.field_name.clone(),
                        reason: format!("contains invalid character '{}'", ch),
                    });
                }
            }
        }
        
        Ok(())
    }
}
```

#### 2.2 パスバリデーター
```rust
// src/application/validators/path.rs
use std::path::{Path, PathBuf};
use tokio::fs;

pub struct PathValidator {
    field_name: String,
    must_exist: Option<bool>,
    must_be_file: Option<bool>,
    must_be_dir: Option<bool>,
    allowed_extensions: Option<Vec<String>>,
    base_path: Option<PathBuf>,
}

impl PathValidator {
    pub fn new(field_name: impl Into<String>) -> Self {
        Self {
            field_name: field_name.into(),
            must_exist: None,
            must_be_file: None,
            must_be_dir: None,
            allowed_extensions: None,
            base_path: None,
        }
    }
    
    pub fn must_exist(mut self) -> Self {
        self.must_exist = Some(true);
        self
    }
    
    pub fn must_not_exist(mut self) -> Self {
        self.must_exist = Some(false);
        self
    }
    
    pub fn must_be_file(mut self) -> Self {
        self.must_be_file = Some(true);
        self.must_be_dir = Some(false);
        self
    }
    
    pub fn must_be_dir(mut self) -> Self {
        self.must_be_dir = Some(true);
        self.must_be_file = Some(false);
        self
    }
    
    pub fn allowed_extensions(mut self, extensions: Vec<&str>) -> Self {
        self.allowed_extensions = Some(
            extensions.into_iter().map(|s| s.to_string()).collect()
        );
        self
    }
    
    pub fn within_base_path(mut self, base: impl AsRef<Path>) -> Self {
        self.base_path = Some(base.as_ref().to_path_buf());
        self
    }
}

#[async_trait]
impl Validator<PathBuf> for PathValidator {
    async fn validate(&self, value: &PathBuf) -> ValidationResult<()> {
        // 基本パスチェック
        if let Some(ref base) = self.base_path {
            let canonical_value = value.canonicalize()
                .map_err(|_| ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "cannot canonicalize path".to_string(),
                })?;
            
            let canonical_base = base.canonicalize()
                .map_err(|_| ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "cannot canonicalize base path".to_string(),
                })?;
            
            if !canonical_value.starts_with(&canonical_base) {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "path is outside allowed base directory".to_string(),
                });
            }
        }
        
        // 存在チェック
        let exists = fs::metadata(value).await.is_ok();
        
        if let Some(must_exist) = self.must_exist {
            if must_exist && !exists {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "path does not exist".to_string(),
                });
            }
            
            if !must_exist && exists {
                return Err(ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: "path already exists".to_string(),
                });
            }
        }
        
        // ファイル/ディレクトリチェック
        if exists {
            let metadata = fs::metadata(value).await
                .map_err(|e| ValidationError::InvalidValue {
                    field: self.field_name.clone(),
                    reason: format!("cannot read metadata: {}", e),
                })?;
            
            if let Some(true) = self.must_be_file {
                if !metadata.is_file() {
                    return Err(ValidationError::InvalidValue {
                        field: self.field_name.clone(),
                        reason: "path is not a file".to_string(),
                    });
                }
            }
            
            if let Some(true) = self.must_be_dir {
                if !metadata.is_dir() {
                    return Err(ValidationError::InvalidValue {
                        field: self.field_name.clone(),
                        reason: "path is not a directory".to_string(),
                    });
                }
            }
        }
        
        // 拡張子チェック
        if let Some(ref extensions) = self.allowed_extensions {
            if let Some(ext) = value.extension() {
                let ext_str = ext.to_str().unwrap_or("");
                if !extensions.iter().any(|e| e == ext_str) {
                    return Err(ValidationError::InvalidValue {
                        field: self.field_name.clone(),
                        reason: format!(
                            "invalid extension '{}', allowed: {:?}",
                            ext_str, extensions
                        ),
                    });
                }
            }
        }
        
        Ok(())
    }
}
```

### Phase 3: 構造体バリデーション（優先度: 高）

#### 3.1 派生マクロ
```rust
// src/macros/validation.rs
use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(Validate, attributes(validate))]
pub fn derive_validate(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    
    let validation_code = generate_validation_code(&input);
    
    let expanded = quote! {
        impl Validatable for #name {
            type Validator = CompositeValidator<Self>;
            
            fn validator() -> Self::Validator {
                #validation_code
            }
        }
    };
    
    proc_macro::TokenStream::from(expanded)
}

// 使用例
#[derive(Debug, Validate)]
pub struct ExecutionConfig {
    #[validate(required, range(min = 1, max = 3600))]
    pub timeout: u32,
    
    #[validate(required, range(min = 1, max = 16384))]
    pub memory_limit_mb: u32,
    
    #[validate(required, min_length = 1)]
    pub working_directory: String,
    
    #[validate(path(must_exist, must_be_dir))]
    pub test_data_path: Option<PathBuf>,
}
```

#### 3.2 カスタムバリデーター
```rust
// src/application/validators/custom.rs
pub struct ComparisonValidator {
    mode: ComparisonMode,
}

#[derive(Debug, Clone)]
pub enum ComparisonMode {
    Exact,
    TrimmedLines,
    IgnoreWhitespace,
    Regex(Regex),
    FloatTolerance(f64),
}

impl ComparisonValidator {
    pub fn new(mode: ComparisonMode) -> Self {
        Self { mode }
    }
    
    pub fn validate_output(&self, actual: &str, expected: &str) -> ValidationResult<()> {
        let matches = match &self.mode {
            ComparisonMode::Exact => actual == expected,
            
            ComparisonMode::TrimmedLines => {
                let actual_lines: Vec<&str> = actual.lines()
                    .map(|l| l.trim())
                    .filter(|l| !l.is_empty())
                    .collect();
                let expected_lines: Vec<&str> = expected.lines()
                    .map(|l| l.trim())
                    .filter(|l| !l.is_empty())
                    .collect();
                actual_lines == expected_lines
            }
            
            ComparisonMode::IgnoreWhitespace => {
                let actual_normalized: String = actual
                    .split_whitespace()
                    .collect::<Vec<_>>()
                    .join(" ");
                let expected_normalized: String = expected
                    .split_whitespace()
                    .collect::<Vec<_>>()
                    .join(" ");
                actual_normalized == expected_normalized
            }
            
            ComparisonMode::Regex(regex) => regex.is_match(actual),
            
            ComparisonMode::FloatTolerance(tolerance) => {
                self.compare_with_tolerance(actual, expected, *tolerance)
            }
        };
        
        if matches {
            Ok(())
        } else {
            Err(ValidationError::InvalidValue {
                field: "output".to_string(),
                reason: "does not match expected output".to_string(),
            })
        }
    }
    
    fn compare_with_tolerance(&self, actual: &str, expected: &str, tolerance: f64) -> bool {
        let actual_tokens: Vec<&str> = actual.split_whitespace().collect();
        let expected_tokens: Vec<&str> = expected.split_whitespace().collect();
        
        if actual_tokens.len() != expected_tokens.len() {
            return false;
        }
        
        for (a, e) in actual_tokens.iter().zip(expected_tokens.iter()) {
            if let (Ok(a_float), Ok(e_float)) = (a.parse::<f64>(), e.parse::<f64>()) {
                if (a_float - e_float).abs() > tolerance {
                    return false;
                }
            } else if a != e {
                return false;
            }
        }
        
        true
    }
}
```

### Phase 4: 非同期バリデーション（優先度: 中）

#### 4.1 非同期バリデーター
```rust
// src/application/validators/async_validators.rs
pub struct RemoteValidator {
    endpoint: String,
    client: reqwest::Client,
}

impl RemoteValidator {
    pub fn new(endpoint: impl Into<String>) -> Self {
        Self {
            endpoint: endpoint.into(),
            client: reqwest::Client::new(),
        }
    }
}

#[async_trait]
impl Validator<String> for RemoteValidator {
    async fn validate(&self, value: &String) -> ValidationResult<()> {
        let response = self.client
            .post(&self.endpoint)
            .json(&serde_json::json!({
                "value": value
            }))
            .send()
            .await
            .map_err(|e| ValidationError::InvalidValue {
                field: "remote".to_string(),
                reason: format!("validation request failed: {}", e),
            })?;
        
        if response.status().is_success() {
            Ok(())
        } else {
            let error_body = response.text().await.unwrap_or_default();
            Err(ValidationError::InvalidValue {
                field: "remote".to_string(),
                reason: error_body,
            })
        }
    }
}

pub struct DatabaseValidator<T> {
    repository: Arc<dyn Repository<T, String>>,
    check_exists: bool,
}

#[async_trait]
impl<T> Validator<String> for DatabaseValidator<T>
where
    T: Send + Sync + 'static,
{
    async fn validate(&self, value: &String) -> ValidationResult<()> {
        let exists = self.repository.exists(value).await
            .map_err(|e| ValidationError::InvalidValue {
                field: "database".to_string(),
                reason: format!("database check failed: {}", e),
            })?;
        
        if self.check_exists && !exists {
            Err(ValidationError::InvalidValue {
                field: "database".to_string(),
                reason: "record does not exist".to_string(),
            })
        } else if !self.check_exists && exists {
            Err(ValidationError::InvalidValue {
                field: "database".to_string(),
                reason: "record already exists".to_string(),
            })
        } else {
            Ok(())
        }
    }
}
```

### Phase 5: バリデーションパイプライン（優先度: 低）

#### 5.1 パイプラインビルダー
```rust
// src/application/validators/pipeline.rs
pub struct ValidationPipeline<T> {
    validators: Vec<Box<dyn Validator<T>>>,
    fail_fast: bool,
}

impl<T> ValidationPipeline<T> {
    pub fn new() -> Self {
        Self {
            validators: Vec::new(),
            fail_fast: true,
        }
    }
    
    pub fn fail_fast(mut self, enabled: bool) -> Self {
        self.fail_fast = enabled;
        self
    }
    
    pub fn add<V: Validator<T> + 'static>(mut self, validator: V) -> Self {
        self.validators.push(Box::new(validator));
        self
    }
}

#[async_trait]
impl<T> Validator<T> for ValidationPipeline<T>
where
    T: Send + Sync,
{
    async fn validate(&self, value: &T) -> ValidationResult<()> {
        let mut errors = Vec::new();
        
        for validator in &self.validators {
            match validator.validate(value).await {
                Ok(()) => continue,
                Err(e) => {
                    if self.fail_fast {
                        return Err(e);
                    }
                    errors.push(e);
                }
            }
        }
        
        if errors.is_empty() {
            Ok(())
        } else if errors.len() == 1 {
            Err(errors.into_iter().next().unwrap())
        } else {
            Err(ValidationError::Multiple(errors))
        }
    }
}

pub struct ConditionalValidator<T, V> {
    condition: Box<dyn Fn(&T) -> bool + Send + Sync>,
    validator: V,
}

impl<T, V> ConditionalValidator<T, V> {
    pub fn new<F>(condition: F, validator: V) -> Self
    where
        F: Fn(&T) -> bool + Send + Sync + 'static,
    {
        Self {
            condition: Box::new(condition),
            validator,
        }
    }
}

#[async_trait]
impl<T, V> Validator<T> for ConditionalValidator<T, V>
where
    T: Send + Sync,
    V: Validator<T>,
{
    async fn validate(&self, value: &T) -> ValidationResult<()> {
        if (self.condition)(value) {
            self.validator.validate(value).await
        } else {
            Ok(())
        }
    }
}
```

## 実装上の考慮事項

### 1. 型安全性の確保
- コンパイル時の型チェック
- ゼロコスト抽象化
- 型推論の活用

### 2. パフォーマンス最適化
- 軽量なバリデーター実装
- 非同期処理の効率化
- メモリアロケーションの最小化

### 3. エラーハンドリング
- 詳細なエラー情報
- エラーの集約とレポート
- 国際化対応

## 期待される効果

1. **信頼性の向上**
   - コンパイル時エラー検出
   - 型安全なバリデーション
   - 一貫したエラーハンドリング

2. **開発効率の向上**
   - 再利用可能なバリデーター
   - 宣言的なバリデーション定義
   - IDE支援の向上

3. **保守性の向上**
   - 明確な責任分離
   - テスタブルな設計
   - 拡張可能なアーキテクチャ

## リスクと対策

### リスク
- 複雑なバリデーションロジックの実装困難性
- パフォーマンスオーバーヘッド
- 既存コードとの互換性

### 対策
- シンプルなAPIの提供
- ベンチマークテスト
- 段階的な移行サポート
- 互換性レイヤーの実装

## 実装優先順位

1. **即座に実装すべき項目**
   - 基本的なバリデータートレイト
   - 必須フィールド・範囲チェック
   - 文字列・パスバリデーター

2. **短期的に実装すべき項目**
   - 派生マクロ
   - カスタムバリデーター
   - バリデーションパイプライン

3. **中長期的に検討する項目**
   - 非同期バリデーター
   - 国際化対応
   - バリデーションルールエンジン