# リクエストファクトリーパターン実装計画

## 概要
テスト実行エラー統合版で提案されたTestObjectFactoryパターンを発展させ、全体的なリクエストファクトリーパターンを実装する。

## 背景と現状
- API変更時のテスト更新が困難
- 必須パラメータの追加による広範な影響
- オブジェクト生成ロジックの重複
- テストの保守性が低い

## 目標
1. 統一されたファクトリーパターンの実装
2. テスト用オブジェクト生成の簡素化
3. API変更への耐性向上
4. テストコードの保守性改善

## 実施内容

### Phase 1: 基本ファクトリー実装（1週間）
- `RequestFactory`トレイトの定義
- 基本的なビルダーパターン実装
- デフォルト値管理機能

### Phase 2: 各種ファクトリー実装（2週間）
- `FileRequestFactory`
- `DockerRequestFactory`
- `ExecutionRequestFactory`
- `WorkflowRequestFactory`

### Phase 3: テストヘルパー実装（1週間）
- モックオブジェクト生成
- ランダムテストデータ生成
- シナリオベースのデータ生成

### Phase 4: 既存コードの移行（2週間）
- 既存テストの書き換え
- プロダクションコードへの適用
- ドキュメント作成

## 技術仕様

### ファクトリートレイト
```rust
pub trait RequestFactory<T> {
    fn create() -> RequestBuilder<T>;
    fn create_default() -> Result<T>;
    fn create_with_defaults(overrides: impl Into<T>) -> Result<T>;
}

pub struct RequestBuilder<T> {
    inner: T,
    validators: Vec<Box<dyn Fn(&T) -> Result<()>>>,
}

impl<T> RequestBuilder<T> {
    pub fn with<F>(mut self, f: F) -> Self 
    where F: FnOnce(&mut T) {
        f(&mut self.inner);
        self
    }
    
    pub fn validate<F>(mut self, f: F) -> Self
    where F: Fn(&T) -> Result<()> + 'static {
        self.validators.push(Box::new(f));
        self
    }
    
    pub fn build(self) -> Result<T> {
        for validator in &self.validators {
            validator(&self.inner)?;
        }
        Ok(self.inner)
    }
}
```

### 使用例
```rust
// 基本的な使用
let request = FileRequestFactory::create()
    .with(|r| r.path = "/test/file.txt")
    .with(|r| r.operation = FileOp::Read)
    .build()?;

// デフォルト値を使用
let request = FileRequestFactory::create_default()?;

// 部分的なオーバーライド
let request = FileRequestFactory::create_with_defaults(
    FileRequestOverrides {
        path: Some("/custom/path.txt"),
        ..Default::default()
    }
)?;

// テスト用のランダムデータ
let requests: Vec<FileRequest> = (0..10)
    .map(|_| FileRequestFactory::create_random())
    .collect::<Result<Vec<_>>>()?;
```

### テストシナリオ生成
```rust
pub struct TestScenarioBuilder {
    scenario_type: ScenarioType,
    constraints: Vec<Constraint>,
}

impl TestScenarioBuilder {
    pub fn happy_path() -> Self {
        Self {
            scenario_type: ScenarioType::Success,
            constraints: vec![],
        }
    }
    
    pub fn error_case(error_type: ErrorType) -> Self {
        Self {
            scenario_type: ScenarioType::Error(error_type),
            constraints: vec![],
        }
    }
    
    pub fn generate<T: RequestFactory>(&self) -> Result<Vec<T>> {
        // シナリオに基づいてテストデータを生成
    }
}
```

## 期待される成果
- API変更時の影響範囲の最小化
- テスト作成時間の短縮
- テストの可読性向上
- バグの早期発見

## リスクと対策
- **リスク**: 過度な抽象化による複雑性
- **対策**: シンプルなインターフェース、段階的導入

## 成功指標
- テスト修正時間: 50%削減
- API変更時の影響ファイル数: 70%削減
- テストコード行数: 30%削減
- 新規テスト作成時間: 40%短縮