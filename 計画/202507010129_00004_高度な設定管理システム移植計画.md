# 高度な設定管理システム移植計画

## 現状の問題点

### 1. Python設定管理の複雑性
- ConfigResolver、ConfigNode、ConfigurationRepositoryなど多層構造
- 動的な型システムによる設定値の型安全性欠如
- BFSによる設定解決の非効率性

### 2. Rustプロジェクトとの不整合
- 現在のRustプロジェクトに高度な設定管理機能が不足
- config crateの基本機能のみ使用
- 階層的設定管理、エイリアス、動的解決の欠如

## 対応方針

### Phase 1: 階層的設定モデル（優先度: 高）

#### 1.1 ConfigNodeのRust実装
```rust
// src/domain/config_node.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfigNode {
    pub name: String,
    pub value: Option<ConfigValue>,
    pub aliases: HashSet<String>,
    pub parent: Option<Box<ConfigNode>>,
    pub children: HashMap<String, ConfigNode>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec<ConfigValue>),
    Object(HashMap<String, ConfigValue>),
}

impl ConfigNode {
    pub fn new(name: String) -> Self {
        Self {
            name,
            value: None,
            aliases: HashSet::new(),
            parent: None,
            children: HashMap::new(),
            metadata: HashMap::new(),
        }
    }

    pub fn add_alias(&mut self, alias: String) {
        self.aliases.insert(alias);
    }

    pub fn add_child(&mut self, child: ConfigNode) {
        self.children.insert(child.name.clone(), child);
    }

    pub fn path(&self) -> Vec<String> {
        let mut path = Vec::new();
        let mut current = Some(self);
        
        while let Some(node) = current {
            path.push(node.name.clone());
            current = node.parent.as_ref().map(|p| p.as_ref());
        }
        
        path.reverse();
        path
    }
}
```

#### 1.2 設定解決エンジン
```rust
// src/application/config_resolver.rs
use std::collections::{VecDeque, HashMap};
use std::sync::Arc;

pub struct ConfigResolver {
    root: Arc<ConfigNode>,
    cache: HashMap<String, ConfigValue>,
}

impl ConfigResolver {
    pub fn new(root: ConfigNode) -> Self {
        Self {
            root: Arc::new(root),
            cache: HashMap::new(),
        }
    }

    pub fn resolve(&mut self, path: &str) -> Result<ConfigValue> {
        // キャッシュチェック
        if let Some(value) = self.cache.get(path) {
            return Ok(value.clone());
        }

        // BFSによる設定解決
        let segments: Vec<&str> = path.split('.').collect();
        let result = self.bfs_search(&segments)?;
        
        // キャッシュに保存
        self.cache.insert(path.to_string(), result.clone());
        Ok(result)
    }

    fn bfs_search(&self, segments: &[&str]) -> Result<ConfigValue> {
        let mut queue = VecDeque::new();
        queue.push_back((self.root.clone(), 0));
        
        while let Some((node, depth)) = queue.pop_front() {
            if depth == segments.len() {
                if let Some(value) = &node.value {
                    return Ok(value.clone());
                }
            }
            
            if depth < segments.len() {
                let target = segments[depth];
                
                // 直接マッチ
                if let Some(child) = node.children.get(target) {
                    queue.push_back((Arc::new(child.clone()), depth + 1));
                }
                
                // エイリアスマッチ
                for (_, child) in &node.children {
                    if child.aliases.contains(target) {
                        queue.push_back((Arc::new(child.clone()), depth + 1));
                    }
                }
            }
        }
        
        Err(ConfigError::NotFound(path.to_string()))
    }

    pub fn get_typed<T: DeserializeOwned>(&mut self, path: &str) -> Result<T> {
        let value = self.resolve(path)?;
        serde_json::from_value(serde_json::to_value(value)?)
            .map_err(|e| ConfigError::TypeMismatch(e.to_string()))
    }
}
```

### Phase 2: 設定リポジトリとストレージ（優先度: 高）

#### 2.1 設定永続化層
```rust
// src/infrastructure/config_repository.rs
use sqlx::{SqlitePool, Row};
use async_trait::async_trait;

#[async_trait]
pub trait ConfigRepository: Send + Sync {
    async fn save_config(&self, key: &str, value: &str) -> Result<()>;
    async fn load_config(&self, key: &str) -> Result<Option<String>>;
    async fn list_configs(&self, prefix: &str) -> Result<Vec<String>>;
    async fn delete_config(&self, key: &str) -> Result<()>;
}

pub struct SqliteConfigRepository {
    pool: SqlitePool,
}

impl SqliteConfigRepository {
    pub async fn new(database_url: &str) -> Result<Self> {
        let pool = SqlitePool::connect(database_url).await?;
        
        // テーブル作成
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS configurations (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        "#)
        .execute(&pool)
        .await?;
        
        Ok(Self { pool })
    }
}

#[async_trait]
impl ConfigRepository for SqliteConfigRepository {
    async fn save_config(&self, key: &str, value: &str) -> Result<()> {
        sqlx::query(r#"
            INSERT INTO configurations (key, value)
            VALUES (?1, ?2)
            ON CONFLICT(key) DO UPDATE SET
                value = excluded.value,
                updated_at = CURRENT_TIMESTAMP
        "#)
        .bind(key)
        .bind(value)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }

    async fn load_config(&self, key: &str) -> Result<Option<String>> {
        let result = sqlx::query("SELECT value FROM configurations WHERE key = ?1")
            .bind(key)
            .fetch_optional(&self.pool)
            .await?;
        
        Ok(result.map(|row| row.get("value")))
    }

    async fn list_configs(&self, prefix: &str) -> Result<Vec<String>> {
        let pattern = format!("{}%", prefix);
        let rows = sqlx::query("SELECT key FROM configurations WHERE key LIKE ?1")
            .bind(pattern)
            .fetch_all(&self.pool)
            .await?;
        
        Ok(rows.into_iter().map(|row| row.get("key")).collect())
    }

    async fn delete_config(&self, key: &str) -> Result<()> {
        sqlx::query("DELETE FROM configurations WHERE key = ?1")
            .bind(key)
            .execute(&self.pool)
            .await?;
        
        Ok(())
    }
}
```

#### 2.2 設定ローダーとビルダー
```rust
// src/application/config_loader.rs
use std::path::Path;
use std::fs;

pub struct ConfigLoader {
    sources: Vec<ConfigSource>,
}

pub enum ConfigSource {
    File(PathBuf),
    Environment(String),
    Database(Arc<dyn ConfigRepository>),
    Memory(HashMap<String, ConfigValue>),
}

impl ConfigLoader {
    pub fn new() -> Self {
        Self {
            sources: Vec::new(),
        }
    }

    pub fn add_file<P: AsRef<Path>>(mut self, path: P) -> Self {
        self.sources.push(ConfigSource::File(path.as_ref().to_path_buf()));
        self
    }

    pub fn add_env_prefix(mut self, prefix: String) -> Self {
        self.sources.push(ConfigSource::Environment(prefix));
        self
    }

    pub fn add_database(mut self, repo: Arc<dyn ConfigRepository>) -> Self {
        self.sources.push(ConfigSource::Database(repo));
        self
    }

    pub async fn build(self) -> Result<ConfigNode> {
        let mut root = ConfigNode::new("root".to_string());
        
        for source in self.sources {
            match source {
                ConfigSource::File(path) => {
                    self.load_from_file(&mut root, &path)?;
                }
                ConfigSource::Environment(prefix) => {
                    self.load_from_env(&mut root, &prefix)?;
                }
                ConfigSource::Database(repo) => {
                    self.load_from_database(&mut root, repo).await?;
                }
                ConfigSource::Memory(map) => {
                    self.load_from_memory(&mut root, map)?;
                }
            }
        }
        
        Ok(root)
    }

    fn load_from_file(&self, root: &mut ConfigNode, path: &Path) -> Result<()> {
        let content = fs::read_to_string(path)?;
        
        match path.extension().and_then(|s| s.to_str()) {
            Some("json") => {
                let value: serde_json::Value = serde_json::from_str(&content)?;
                self.merge_json_into_node(root, value)?;
            }
            Some("toml") => {
                let value: toml::Value = toml::from_str(&content)?;
                self.merge_toml_into_node(root, value)?;
            }
            Some("yaml") | Some("yml") => {
                let value: serde_yaml::Value = serde_yaml::from_str(&content)?;
                self.merge_yaml_into_node(root, value)?;
            }
            _ => return Err(ConfigError::UnsupportedFormat),
        }
        
        Ok(())
    }
}
```

### Phase 3: 実行時設定管理（優先度: 中）

#### 3.1 動的設定更新
```rust
// src/application/runtime_config.rs
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct RuntimeConfigManager {
    resolver: Arc<RwLock<ConfigResolver>>,
    watchers: Vec<Box<dyn ConfigWatcher>>,
}

#[async_trait]
pub trait ConfigWatcher: Send + Sync {
    async fn on_change(&self, key: &str, old_value: &ConfigValue, new_value: &ConfigValue);
}

impl RuntimeConfigManager {
    pub fn new(initial_config: ConfigNode) -> Self {
        Self {
            resolver: Arc::new(RwLock::new(ConfigResolver::new(initial_config))),
            watchers: Vec::new(),
        }
    }

    pub async fn get<T: DeserializeOwned>(&self, key: &str) -> Result<T> {
        let mut resolver = self.resolver.write().await;
        resolver.get_typed(key)
    }

    pub async fn set(&self, key: &str, value: ConfigValue) -> Result<()> {
        let old_value = {
            let mut resolver = self.resolver.write().await;
            let old = resolver.resolve(key).ok();
            
            // 新しい値を設定
            self.update_node(&mut resolver.root, key, value.clone())?;
            resolver.cache.clear(); // キャッシュをクリア
            
            old
        };

        // ウォッチャーに通知
        if let Some(old) = old_value {
            for watcher in &self.watchers {
                watcher.on_change(key, &old, &value).await;
            }
        }

        Ok(())
    }

    pub fn watch(&mut self, watcher: Box<dyn ConfigWatcher>) {
        self.watchers.push(watcher);
    }

    async fn reload_from_source(&self, source: ConfigSource) -> Result<()> {
        let loader = ConfigLoader::new();
        let new_config = match source {
            ConfigSource::File(path) => {
                loader.add_file(path).build().await?
            }
            // 他のソースも同様に処理
            _ => return Err(ConfigError::UnsupportedSource),
        };

        let mut resolver = self.resolver.write().await;
        *resolver = ConfigResolver::new(new_config);
        
        Ok(())
    }
}
```

#### 3.2 設定検証とスキーマ
```rust
// src/domain/config_schema.rs
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ExecutionConfig {
    #[validate(range(min = 1, max = 3600))]
    pub timeout: u32,
    
    #[validate(range(min = 1, max = 16384))]
    pub memory_limit_mb: u32,
    
    #[validate(length(min = 1))]
    pub working_directory: String,
    
    pub environment: HashMap<String, String>,
}

pub trait ConfigSchema: Sized + Validate {
    fn from_config_value(value: ConfigValue) -> Result<Self>;
    fn to_config_value(&self) -> ConfigValue;
    fn validate_value(&self) -> Result<()> {
        self.validate()
            .map_err(|e| ConfigError::ValidationFailed(e.to_string()))
    }
}

impl ConfigSchema for ExecutionConfig {
    fn from_config_value(value: ConfigValue) -> Result<Self> {
        let json_value = serde_json::to_value(value)?;
        let config: Self = serde_json::from_value(json_value)?;
        config.validate_value()?;
        Ok(config)
    }

    fn to_config_value(&self) -> ConfigValue {
        // 実装省略
    }
}
```

### Phase 4: 環境別設定とオーバーライド（優先度: 中）

#### 4.1 環境別設定管理
```rust
// src/application/environment_config.rs
#[derive(Debug, Clone)]
pub enum Environment {
    Development,
    Testing,
    Production,
    Custom(String),
}

pub struct EnvironmentConfigManager {
    base_config: ConfigNode,
    environment: Environment,
    overrides: HashMap<String, ConfigValue>,
}

impl EnvironmentConfigManager {
    pub fn new(environment: Environment) -> Self {
        Self {
            base_config: ConfigNode::new("root".to_string()),
            environment,
            overrides: HashMap::new(),
        }
    }

    pub async fn load(&mut self) -> Result<()> {
        let loader = ConfigLoader::new()
            .add_file("config/default.toml")
            .add_file(self.environment_file())
            .add_env_prefix("CPH_".to_string());

        self.base_config = loader.build().await?;
        
        // 環境変数からのオーバーライド
        self.apply_env_overrides()?;
        
        Ok(())
    }

    fn environment_file(&self) -> String {
        match &self.environment {
            Environment::Development => "config/development.toml",
            Environment::Testing => "config/testing.toml",
            Environment::Production => "config/production.toml",
            Environment::Custom(name) => &format!("config/{}.toml", name),
        }.to_string()
    }

    fn apply_env_overrides(&mut self) -> Result<()> {
        for (key, value) in std::env::vars() {
            if key.starts_with("CPH_") {
                let config_key = key[4..].to_lowercase().replace('_', ".");
                self.overrides.insert(
                    config_key,
                    ConfigValue::String(value)
                );
            }
        }
        Ok(())
    }

    pub fn build_resolver(&self) -> ConfigResolver {
        let mut final_config = self.base_config.clone();
        
        // オーバーライドを適用
        for (key, value) in &self.overrides {
            self.apply_override(&mut final_config, key, value.clone());
        }
        
        ConfigResolver::new(final_config)
    }
}
```

### Phase 5: 統合とマイグレーション（優先度: 低）

#### 5.1 既存config crateとの統合
```rust
// src/interfaces/config_compat.rs
use config::{Config as LegacyConfig, ConfigError as LegacyError};

pub struct ConfigCompat {
    resolver: ConfigResolver,
}

impl ConfigCompat {
    pub fn new(resolver: ConfigResolver) -> Self {
        Self { resolver }
    }

    pub fn to_legacy_config(&mut self) -> Result<LegacyConfig> {
        let mut builder = LegacyConfig::builder();
        
        // ConfigNodeをLegacy Configに変換
        self.export_to_legacy(&mut builder)?;
        
        builder.build()
            .map_err(|e| ConfigError::LegacyCompatError(e.to_string()))
    }

    pub fn from_legacy_config(legacy: &LegacyConfig) -> Result<ConfigNode> {
        // Legacy ConfigをConfigNodeに変換
        let mut root = ConfigNode::new("root".to_string());
        
        // 実装省略
        
        Ok(root)
    }
}
```

## 実装上の考慮事項

### 1. パフォーマンス最適化
- 多層キャッシュシステムの実装
- 遅延評価による初期化時間の短縮
- 並行アクセス対応のRead-Writeロック
- 設定値の事前検証によるランタイムエラーの削減

### 2. 型安全性の確保
- ジェネリクスを活用した型安全な設定アクセス
- コンパイル時の設定スキーマ検証
- serde活用による柔軟なシリアライゼーション
- Validate crateによる値の検証

### 3. 拡張性の確保
- プラグイン可能な設定ソース
- カスタム設定フォーマットのサポート
- 動的な設定プロバイダーの追加
- イベント駆動の設定変更通知

## 期待される効果

1. **開発効率向上**
   - 型安全な設定アクセス
   - コンパイル時エラー検出
   - IDE支援の向上

2. **実行時安定性向上**
   - 設定値の事前検証
   - 型安全性による実行時エラーの削減
   - より明確なエラーメッセージ

3. **保守性向上**
   - 設定スキーマの明確化
   - 環境別設定の体系的管理
   - 設定変更の追跡可能性

## リスクと対策

### リスク
- 既存設定ファイルとの互換性問題
- 移行期間中の二重管理
- 学習コストの増加

### 対策
- 互換性レイヤーの提供
- 段階的な移行計画
- 充実したドキュメンテーション
- 既存のconfig crateとの共存期間

## 実装優先順位

1. **即座に実装すべき項目**
   - ConfigNodeモデルの基本実装
   - ConfigResolverの基本機能
   - ファイルベースの設定読み込み

2. **短期的に実装すべき項目**
   - SQLite永続化層
   - 環境変数サポート
   - 基本的な設定検証

3. **中長期的に検討する項目**
   - 動的設定更新機能
   - 設定変更通知システム
   - 高度な設定スキーマ検証