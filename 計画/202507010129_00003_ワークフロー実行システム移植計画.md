# ワークフロー実行システム移植計画

## 現状の問題点

### 1. Pythonワークフローシステムの複雑性
- domain/workflow.py、step.py、dependency.pyなど複雑な依存関係解決機構
- 動的な型システムによる実行時エラーのリスク
- パフォーマンスのボトルネック

### 2. Rustプロジェクトとの不整合
- 現在のRustプロジェクトにワークフロー実行機能が欠如
- PythonとRustの二重管理によるメンテナンスコスト
- 型安全性とパフォーマンスの機会損失

## 対応方針

### Phase 1: ワークフロー基盤の設計（優先度: 高）

#### 1.1 コアモデルの定義
```rust
// src/domain/workflow.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workflow {
    pub id: String,
    pub name: String,
    pub steps: Vec<Step>,
    pub dependencies: HashMap<String, Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Step {
    pub id: String,
    pub step_type: StepType,
    pub parameters: HashMap<String, serde_json::Value>,
    pub retry_config: Option<RetryConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepType {
    Shell(ShellStep),
    Docker(DockerStep),
    File(FileStep),
    Test(TestStep),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionResult {
    pub workflow_id: String,
    pub status: ExecutionStatus,
    pub step_results: Vec<StepResult>,
    pub execution_time: std::time::Duration,
}
```

#### 1.2 依存関係解決エンジン
```rust
// src/domain/dependency_resolver.rs
use petgraph::graph::DiGraph;
use petgraph::algo::toposort;

pub struct DependencyResolver {
    graph: DiGraph<String, ()>,
}

impl DependencyResolver {
    pub fn new() -> Self {
        Self {
            graph: DiGraph::new(),
        }
    }

    pub fn add_step(&mut self, step_id: String) -> NodeIndex {
        self.graph.add_node(step_id)
    }

    pub fn add_dependency(&mut self, from: NodeIndex, to: NodeIndex) {
        self.graph.add_edge(from, to, ());
    }

    pub fn resolve(&self) -> Result<Vec<String>, CyclicDependencyError> {
        toposort(&self.graph, None)
            .map(|indices| {
                indices.into_iter()
                    .map(|idx| self.graph[idx].clone())
                    .collect()
            })
            .map_err(|_| CyclicDependencyError)
    }
}
```

### Phase 2: 並列実行エンジン（優先度: 高）

#### 2.1 非同期実行フレームワーク
```rust
// src/application/workflow_executor.rs
use tokio::sync::mpsc;
use tokio::task::JoinSet;
use futures::future::FutureExt;

pub struct WorkflowExecutor {
    max_parallel: usize,
    timeout: Duration,
}

impl WorkflowExecutor {
    pub async fn execute(&self, workflow: Workflow) -> Result<ExecutionResult> {
        let resolved_steps = self.resolve_dependencies(&workflow)?;
        let execution_plan = self.create_execution_plan(resolved_steps);
        
        let mut results = Vec::new();
        let mut join_set = JoinSet::new();
        
        for batch in execution_plan {
            for step in batch {
                let step_executor = self.create_step_executor(&step);
                join_set.spawn(async move {
                    step_executor.execute().await
                });
            }
            
            // バッチの完了を待つ
            while let Some(result) = join_set.join_next().await {
                results.push(result??);
            }
        }
        
        Ok(ExecutionResult {
            workflow_id: workflow.id,
            status: self.determine_status(&results),
            step_results: results,
            execution_time: start.elapsed(),
        })
    }

    fn create_execution_plan(&self, steps: Vec<Step>) -> Vec<Vec<Step>> {
        // 依存関係に基づいてバッチを作成
        // 同じバッチ内のステップは並列実行可能
    }
}
```

#### 2.2 ステップ実行戦略
```rust
// src/infrastructure/step_executors/mod.rs
#[async_trait]
pub trait StepExecutor: Send + Sync {
    async fn execute(&self, step: &Step) -> Result<StepResult>;
    async fn validate(&self, step: &Step) -> Result<()>;
    fn can_retry(&self, error: &Error) -> bool;
}

pub struct ShellStepExecutor {
    shell_driver: Arc<dyn ShellDriver>,
}

#[async_trait]
impl StepExecutor for ShellStepExecutor {
    async fn execute(&self, step: &Step) -> Result<StepResult> {
        self.validate(step).await?;
        
        let command = self.build_command(step)?;
        let result = self.shell_driver.execute(command).await?;
        
        Ok(StepResult {
            step_id: step.id.clone(),
            status: if result.exit_code == 0 { 
                StepStatus::Success 
            } else { 
                StepStatus::Failed 
            },
            output: result.stdout,
            error: result.stderr,
            execution_time: result.duration,
        })
    }
}
```

### Phase 3: 設定とテンプレート（優先度: 中）

#### 3.1 ワークフロー設定管理
```rust
// src/domain/workflow_config.rs
use tera::{Context, Tera};

pub struct WorkflowConfig {
    pub variables: HashMap<String, String>,
    pub templates: HashMap<String, String>,
    pub environment: Environment,
}

pub struct TemplateEngine {
    tera: Tera,
}

impl TemplateEngine {
    pub fn render(&self, template: &str, context: &Context) -> Result<String> {
        self.tera.render_str(template, context)
            .map_err(|e| TemplateError::RenderError(e.to_string()))
    }

    pub fn expand_step(&self, step: &Step, config: &WorkflowConfig) -> Result<Step> {
        let mut expanded = step.clone();
        
        // パラメータのテンプレート展開
        for (key, value) in &step.parameters {
            if let Some(str_value) = value.as_str() {
                let rendered = self.render(str_value, &config.to_context())?;
                expanded.parameters.insert(key.clone(), json!(rendered));
            }
        }
        
        Ok(expanded)
    }
}
```

#### 3.2 実行コンテキスト管理
```rust
// src/application/execution_context.rs
pub struct ExecutionContext {
    pub workflow_id: String,
    pub session_id: String,
    pub variables: HashMap<String, String>,
    pub secrets: SecretStore,
    pub artifacts: ArtifactStore,
}

impl ExecutionContext {
    pub fn get_variable(&self, key: &str) -> Option<&String> {
        self.variables.get(key)
    }

    pub async fn store_artifact(&mut self, name: &str, data: Vec<u8>) -> Result<()> {
        self.artifacts.store(&self.workflow_id, name, data).await
    }

    pub fn with_step_context(&self, step: &Step) -> StepContext {
        StepContext {
            workflow_context: self,
            step_id: step.id.clone(),
            step_variables: step.parameters.clone(),
        }
    }
}
```

### Phase 4: エラーハンドリングとリトライ（優先度: 中）

#### 4.1 構造化エラーハンドリング
```rust
// src/domain/errors.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum WorkflowError {
    #[error("Step execution failed: {step_id}")]
    StepExecutionError {
        step_id: String,
        source: Box<dyn Error + Send + Sync>,
    },
    
    #[error("Dependency resolution failed")]
    DependencyError(#[from] DependencyError),
    
    #[error("Template rendering failed")]
    TemplateError(#[from] TemplateError),
    
    #[error("Timeout exceeded: {duration:?}")]
    TimeoutError {
        duration: Duration,
    },
}

#[derive(Debug, Clone)]
pub struct RetryConfig {
    pub max_attempts: u32,
    pub backoff: BackoffStrategy,
    pub retryable_errors: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum BackoffStrategy {
    Fixed(Duration),
    Exponential { base: Duration, max: Duration },
    Linear { increment: Duration },
}
```

#### 4.2 リトライメカニズム
```rust
// src/application/retry_executor.rs
pub struct RetryExecutor {
    config: RetryConfig,
}

impl RetryExecutor {
    pub async fn execute_with_retry<F, T>(&self, mut operation: F) -> Result<T>
    where
        F: FnMut() -> Future<Output = Result<T>> + Send,
        T: Send,
    {
        let mut attempt = 0;
        let mut last_error = None;
        
        while attempt < self.config.max_attempts {
            match operation().await {
                Ok(result) => return Ok(result),
                Err(e) => {
                    if !self.is_retryable(&e) {
                        return Err(e);
                    }
                    
                    last_error = Some(e);
                    attempt += 1;
                    
                    if attempt < self.config.max_attempts {
                        let delay = self.calculate_delay(attempt);
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }
        
        Err(last_error.unwrap_or_else(|| {
            WorkflowError::RetryExhausted {
                attempts: self.config.max_attempts,
            }
        }))
    }
}
```

### Phase 5: 統合とマイグレーション（優先度: 低）

#### 5.1 Python互換レイヤー
```rust
// src/interfaces/python_compat.rs
use pyo3::prelude::*;

#[pyclass]
struct PyWorkflow {
    inner: Workflow,
}

#[pymethods]
impl PyWorkflow {
    #[new]
    fn new(json_str: &str) -> PyResult<Self> {
        let workflow: Workflow = serde_json::from_str(json_str)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(
                format!("Failed to parse workflow: {}", e)
            ))?;
        
        Ok(PyWorkflow { inner: workflow })
    }

    fn execute(&self) -> PyResult<String> {
        // Rust実装を呼び出し
        let runtime = tokio::runtime::Runtime::new()?;
        let result = runtime.block_on(async {
            let executor = WorkflowExecutor::new();
            executor.execute(self.inner.clone()).await
        })?;
        
        Ok(serde_json::to_string(&result)?)
    }
}
```

#### 5.2 段階的移行戦略
1. **Phase 1**: Rust側でワークフローモデルとパーサーを実装
2. **Phase 2**: 単純なステップ（Shell、File）の実行をRustに移行
3. **Phase 3**: 複雑なステップ（Docker、Composite）の移行
4. **Phase 4**: 依存関係解決とスケジューリングの移行
5. **Phase 5**: Python実装の完全な置き換え

## 実装上の考慮事項

### 1. パフォーマンス最適化
- ゼロコピーでのデータ共有
- 効率的なメモリプールの活用
- 非同期I/Oの徹底活用
- 並列実行の最大化

### 2. 型安全性の確保
- 強い型付けによる実行時エラーの防止
- コンパイル時の依存関係検証
- エラーハンドリングの明示化
- ステップパラメータの型検証

### 3. 拡張性の確保
- プラグインシステムの導入
- カスタムステップタイプのサポート
- 外部ワークフローエンジンとの統合
- イベント駆動アーキテクチャ

## 期待される効果

1. **パフォーマンス向上**
   - 実行速度の50%以上向上
   - メモリ使用量の30%削減
   - 並列実行効率の改善

2. **信頼性向上**
   - コンパイル時エラー検出
   - 型安全性による実行時エラーの削減
   - より堅牢なエラーハンドリング

3. **保守性向上**
   - 単一言語での実装
   - より明確なアーキテクチャ
   - テストの容易化

## リスクと対策

### リスク
- 既存Pythonワークフローとの互換性問題
- 移行期間中の二重メンテナンス
- 新規バグの導入リスク

### 対策
- 段階的な移行アプローチ
- 包括的なテストスイートの構築
- Python互換レイヤーの提供
- 並行運用期間の設定

## 実装優先順位

1. **即座に実装すべき項目**
   - ワークフローモデルの定義
   - 基本的なステップ実行機能
   - エラーハンドリング基盤

2. **短期的に実装すべき項目**
   - 依存関係解決エンジン
   - 並列実行サポート
   - テンプレートエンジン統合

3. **中長期的に検討する項目**
   - 高度な最適化機能
   - プラグインシステム
   - 分散実行サポート