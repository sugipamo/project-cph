# コンポジットリクエストパターン移植計画

## 現状の問題点

### 1. Pythonのコンポジットリクエスト実装の複雑性
- domain/request_handlers配下の複雑な階層構造
- BaseHandler、CompositeHandler、ConcreteHandlerの多層継承
- 動的な処理チェーンの構築と管理

### 2. Rustプロジェクトとの不整合
- 現在のRustプロジェクトにChain of Responsibilityパターンが欠如
- リクエスト処理の柔軟性不足
- コマンド処理の拡張性制限

## 対応方針

### Phase 1: リクエストハンドラー基盤（優先度: 高）

#### 1.1 ハンドラートレイトの定義
```rust
// src/domain/request_handler.rs
use async_trait::async_trait;
use std::any::Any;

#[async_trait]
pub trait RequestHandler: Send + Sync {
    type Request: Send + Sync;
    type Response: Send + Sync;
    type Error: std::error::Error + Send + Sync;

    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error>;
    
    fn can_handle(&self, request: &Self::Request) -> bool {
        true
    }
    
    fn priority(&self) -> i32 {
        0
    }
}

#[async_trait]
pub trait ChainableHandler: RequestHandler {
    async fn handle_with_next(
        &self,
        request: Self::Request,
        next: Option<&dyn ChainableHandler<
            Request = Self::Request,
            Response = Self::Response,
            Error = Self::Error
        >>,
    ) -> Result<Self::Response, Self::Error>;
}

pub struct HandlerChain<Req, Res, Err> {
    handlers: Vec<Box<dyn ChainableHandler<Request = Req, Response = Res, Error = Err>>>,
}

impl<Req, Res, Err> HandlerChain<Req, Res, Err>
where
    Req: Send + Sync + 'static,
    Res: Send + Sync + 'static,
    Err: std::error::Error + Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self {
            handlers: Vec::new(),
        }
    }

    pub fn add_handler(mut self, handler: Box<dyn ChainableHandler<Request = Req, Response = Res, Error = Err>>) -> Self {
        self.handlers.push(handler);
        self.handlers.sort_by_key(|h| -h.priority());
        self
    }

    pub async fn handle(&self, request: Req) -> Result<Res, Err> {
        self.handle_recursive(&request, 0).await
    }

    async fn handle_recursive(&self, request: &Req, index: usize) -> Result<Res, Err> {
        if index >= self.handlers.len() {
            return Err(HandlerError::NoHandlerFound);
        }

        let handler = &self.handlers[index];
        
        if handler.can_handle(request) {
            let next = if index + 1 < self.handlers.len() {
                Some(&*self.handlers[index + 1])
            } else {
                None
            };
            
            handler.handle_with_next(request.clone(), next).await
        } else {
            self.handle_recursive(request, index + 1).await
        }
    }
}
```

#### 1.2 コンポジットハンドラー実装
```rust
// src/application/handlers/composite_handler.rs
pub struct CompositeHandler<Req, Res, Err> {
    name: String,
    handlers: Vec<Box<dyn RequestHandler<Request = Req, Response = Res, Error = Err>>>,
    strategy: CompositionStrategy,
}

#[derive(Debug, Clone)]
pub enum CompositionStrategy {
    Sequential,     // 順次実行
    Parallel,       // 並列実行
    FirstSuccess,   // 最初の成功で終了
    AllSuccess,     // 全て成功が必要
    Aggregate,      // 結果を集約
}

impl<Req, Res, Err> CompositeHandler<Req, Res, Err>
where
    Req: Clone + Send + Sync + 'static,
    Res: Send + Sync + 'static,
    Err: std::error::Error + Send + Sync + 'static,
{
    pub fn new(name: String, strategy: CompositionStrategy) -> Self {
        Self {
            name,
            handlers: Vec::new(),
            strategy,
        }
    }

    pub fn add_handler(mut self, handler: Box<dyn RequestHandler<Request = Req, Response = Res, Error = Err>>) -> Self {
        self.handlers.push(handler);
        self
    }
}

#[async_trait]
impl<Req, Res, Err> RequestHandler for CompositeHandler<Req, Res, Err>
where
    Req: Clone + Send + Sync + 'static,
    Res: Send + Sync + 'static + Default,
    Err: std::error::Error + Send + Sync + 'static,
{
    type Request = Req;
    type Response = Res;
    type Error = Err;

    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        match self.strategy {
            CompositionStrategy::Sequential => {
                self.handle_sequential(request).await
            }
            CompositionStrategy::Parallel => {
                self.handle_parallel(request).await
            }
            CompositionStrategy::FirstSuccess => {
                self.handle_first_success(request).await
            }
            CompositionStrategy::AllSuccess => {
                self.handle_all_success(request).await
            }
            CompositionStrategy::Aggregate => {
                self.handle_aggregate(request).await
            }
        }
    }
}
```

### Phase 2: 具体的なハンドラー実装（優先度: 高）

#### 2.1 コマンドハンドラー
```rust
// src/application/handlers/command_handlers.rs
pub struct CompileHandler {
    compiler: Arc<dyn Compiler>,
    logger: Arc<dyn Logger>,
}

#[derive(Debug, Clone)]
pub struct CompileRequest {
    pub source_file: PathBuf,
    pub language: Language,
    pub options: CompilerOptions,
}

#[derive(Debug, Clone)]
pub struct CompileResponse {
    pub success: bool,
    pub executable: Option<PathBuf>,
    pub errors: Vec<CompilerError>,
    pub warnings: Vec<CompilerWarning>,
}

#[async_trait]
impl RequestHandler for CompileHandler {
    type Request = CompileRequest;
    type Response = CompileResponse;
    type Error = CompileError;

    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        self.logger.info(&format!("Compiling {} with {:?}", request.source_file.display(), request.language));
        
        let result = self.compiler
            .compile(&request.source_file, &request.options)
            .await?;
        
        Ok(CompileResponse {
            success: result.success,
            executable: result.executable,
            errors: result.errors,
            warnings: result.warnings,
        })
    }
}

pub struct ExecuteHandler {
    executor: Arc<dyn Executor>,
    logger: Arc<dyn Logger>,
}

#[async_trait]
impl RequestHandler for ExecuteHandler {
    type Request = ExecuteRequest;
    type Response = ExecuteResponse;
    type Error = ExecutionError;

    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        // タイムアウト付き実行
        let result = timeout(
            request.timeout,
            self.executor.execute(&request.executable, &request.input)
        ).await??;
        
        Ok(ExecuteResponse {
            exit_code: result.exit_code,
            stdout: result.stdout,
            stderr: result.stderr,
            execution_time: result.duration,
            memory_usage: result.memory_usage,
        })
    }
}
```

#### 2.2 検証ハンドラー
```rust
// src/application/handlers/validation_handlers.rs
pub struct InputValidationHandler {
    validators: Vec<Box<dyn Validator>>,
}

#[async_trait]
impl ChainableHandler for InputValidationHandler {
    type Request = TestRequest;
    type Response = TestResponse;
    type Error = TestError;

    async fn handle_with_next(
        &self,
        request: Self::Request,
        next: Option<&dyn ChainableHandler<Request = Self::Request, Response = Self::Response, Error = Self::Error>>,
    ) -> Result<Self::Response, Self::Error> {
        // 入力検証
        for validator in &self.validators {
            validator.validate(&request)?;
        }
        
        // 検証成功後、次のハンドラーに渡す
        if let Some(next_handler) = next {
            next_handler.handle(request).await
        } else {
            Err(TestError::NoNextHandler)
        }
    }
}

pub struct OutputValidationHandler {
    expected_output: String,
    comparison_mode: ComparisonMode,
}

#[derive(Debug, Clone)]
pub enum ComparisonMode {
    Exact,
    TrimmedLines,
    IgnoreWhitespace,
    Regex,
    Custom(Box<dyn Fn(&str, &str) -> bool + Send + Sync>),
}

impl OutputValidationHandler {
    fn compare_output(&self, actual: &str, expected: &str) -> bool {
        match &self.comparison_mode {
            ComparisonMode::Exact => actual == expected,
            ComparisonMode::TrimmedLines => {
                let actual_lines: Vec<&str> = actual.lines().map(|l| l.trim()).collect();
                let expected_lines: Vec<&str> = expected.lines().map(|l| l.trim()).collect();
                actual_lines == expected_lines
            }
            ComparisonMode::IgnoreWhitespace => {
                let actual_normalized: String = actual.split_whitespace().collect();
                let expected_normalized: String = expected.split_whitespace().collect();
                actual_normalized == expected_normalized
            }
            ComparisonMode::Regex => {
                // Regex comparison implementation
                false
            }
            ComparisonMode::Custom(f) => f(actual, expected),
        }
    }
}
```

### Phase 3: リクエストパイプライン（優先度: 中）

#### 3.1 パイプラインビルダー
```rust
// src/application/pipeline/builder.rs
pub struct PipelineBuilder<Req, Res, Err> {
    stages: Vec<PipelineStage<Req, Res, Err>>,
}

pub struct PipelineStage<Req, Res, Err> {
    name: String,
    handler: Box<dyn RequestHandler<Request = Req, Response = Res, Error = Err>>,
    error_handler: Option<Box<dyn ErrorHandler<Err>>>,
    retry_policy: Option<RetryPolicy>,
}

impl<Req, Res, Err> PipelineBuilder<Req, Res, Err>
where
    Req: Clone + Send + Sync + 'static,
    Res: Send + Sync + 'static,
    Err: std::error::Error + Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self {
            stages: Vec::new(),
        }
    }

    pub fn add_stage(mut self, name: &str, handler: Box<dyn RequestHandler<Request = Req, Response = Res, Error = Err>>) -> Self {
        self.stages.push(PipelineStage {
            name: name.to_string(),
            handler,
            error_handler: None,
            retry_policy: None,
        });
        self
    }

    pub fn with_error_handler(mut self, handler: Box<dyn ErrorHandler<Err>>) -> Self {
        if let Some(stage) = self.stages.last_mut() {
            stage.error_handler = Some(handler);
        }
        self
    }

    pub fn with_retry(mut self, policy: RetryPolicy) -> Self {
        if let Some(stage) = self.stages.last_mut() {
            stage.retry_policy = Some(policy);
        }
        self
    }

    pub fn build(self) -> Pipeline<Req, Res, Err> {
        Pipeline::new(self.stages)
    }
}

pub struct Pipeline<Req, Res, Err> {
    stages: Vec<PipelineStage<Req, Res, Err>>,
}

impl<Req, Res, Err> Pipeline<Req, Res, Err>
where
    Req: Clone + Send + Sync + 'static,
    Res: Send + Sync + 'static,
    Err: std::error::Error + Send + Sync + 'static,
{
    pub async fn execute(&self, request: Req) -> Result<Res, Err> {
        let mut current_request = request;
        let mut current_response = None;

        for stage in &self.stages {
            match self.execute_stage(&stage, current_request.clone()).await {
                Ok(response) => {
                    current_response = Some(response);
                    // Transform response to next request if needed
                }
                Err(e) => {
                    if let Some(error_handler) = &stage.error_handler {
                        error_handler.handle(e)?;
                    } else {
                        return Err(e);
                    }
                }
            }
        }

        current_response.ok_or_else(|| PipelineError::NoResponse)
    }

    async fn execute_stage(&self, stage: &PipelineStage<Req, Res, Err>, request: Req) -> Result<Res, Err> {
        if let Some(retry_policy) = &stage.retry_policy {
            self.execute_with_retry(stage, request, retry_policy).await
        } else {
            stage.handler.handle(request).await
        }
    }
}
```

### Phase 4: インターセプターとミドルウェア（優先度: 中）

#### 4.1 インターセプター
```rust
// src/application/interceptors/mod.rs
#[async_trait]
pub trait Interceptor<Req, Res>: Send + Sync {
    async fn pre_handle(&self, request: &mut Req) -> Result<(), InterceptorError>;
    async fn post_handle(&self, request: &Req, response: &mut Res) -> Result<(), InterceptorError>;
}

pub struct LoggingInterceptor {
    logger: Arc<dyn Logger>,
}

#[async_trait]
impl<Req, Res> Interceptor<Req, Res> for LoggingInterceptor
where
    Req: Debug + Send + Sync,
    Res: Debug + Send + Sync,
{
    async fn pre_handle(&self, request: &mut Req) -> Result<(), InterceptorError> {
        self.logger.debug(&format!("Processing request: {:?}", request));
        Ok(())
    }

    async fn post_handle(&self, request: &Req, response: &mut Res) -> Result<(), InterceptorError> {
        self.logger.debug(&format!("Response for {:?}: {:?}", request, response));
        Ok(())
    }
}

pub struct MetricsInterceptor {
    metrics: Arc<Metrics>,
}

#[async_trait]
impl<Req, Res> Interceptor<Req, Res> for MetricsInterceptor
where
    Req: Send + Sync,
    Res: Send + Sync,
{
    async fn pre_handle(&self, _request: &mut Req) -> Result<(), InterceptorError> {
        self.metrics.increment_counter("requests.total");
        Ok(())
    }

    async fn post_handle(&self, _request: &Req, _response: &mut Res) -> Result<(), InterceptorError> {
        self.metrics.increment_counter("requests.success");
        Ok(())
    }
}
```

### Phase 5: 高度なパターン（優先度: 低）

#### 5.1 デコレーターパターン
```rust
// src/application/decorators/mod.rs
pub struct CachingDecorator<H> {
    inner: H,
    cache: Arc<RwLock<HashMap<String, CachedResponse>>>,
    ttl: Duration,
}

#[async_trait]
impl<H> RequestHandler for CachingDecorator<H>
where
    H: RequestHandler,
    H::Request: Hash + Eq + Clone,
    H::Response: Clone,
{
    type Request = H::Request;
    type Response = H::Response;
    type Error = H::Error;

    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        let cache_key = self.compute_cache_key(&request);
        
        // キャッシュチェック
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.get(&cache_key) {
                if cached.expires_at > Instant::now() {
                    return Ok(cached.response.clone());
                }
            }
        }
        
        // キャッシュミスの場合
        let response = self.inner.handle(request).await?;
        
        // キャッシュに保存
        {
            let mut cache = self.cache.write().await;
            cache.insert(cache_key, CachedResponse {
                response: response.clone(),
                expires_at: Instant::now() + self.ttl,
            });
        }
        
        Ok(response)
    }
}
```

## 実装上の考慮事項

### 1. 型安全性
- ジェネリクスによる柔軟な型定義
- コンパイル時の型チェック
- トレイト境界の適切な設定

### 2. パフォーマンス
- 非同期処理の最適化
- メモリ効率的なチェーン構築
- 不要なクローンの回避

### 3. エラーハンドリング
- 詳細なエラー型の定義
- エラーの伝播と回復
- デバッグ情報の保持

## 期待される効果

1. **拡張性の向上**
   - 新しいハンドラーの追加が容易
   - 処理の組み合わせが柔軟
   - プラグイン可能なアーキテクチャ

2. **保守性の向上**
   - 責任の明確な分離
   - テスタブルな設計
   - 再利用可能なコンポーネント

3. **パフォーマンス向上**
   - 並列処理の活用
   - キャッシング機能
   - 効率的なパイプライン実行

## リスクと対策

### リスク
- 過度な抽象化による複雑性
- 実行時オーバーヘッド
- デバッグの困難さ

### 対策
- シンプルなデフォルト実装
- パフォーマンステスト
- 詳細なログとトレース
- 明確なドキュメント

## 実装優先順位

1. **即座に実装すべき項目**
   - 基本的なハンドラートレイト
   - シンプルなチェーン実装
   - コンパイル・実行ハンドラー

2. **短期的に実装すべき項目**
   - コンポジットハンドラー
   - 検証ハンドラー
   - 基本的なインターセプター

3. **中長期的に検討する項目**
   - 高度なパイプライン機能
   - デコレーターパターン
   - 分散処理対応