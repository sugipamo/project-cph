# ワークフロー実行エンジン実装計画

## 概要
old_srcのworkflow/ディレクトリに実装されているワークフロー実行エンジンをRustに移植する計画。

## 背景と目的
- **現状**: 現在のRustプロジェクトには複雑なタスク実行機能が未実装
- **old_srcの実装**: JSONベースのワークフロー定義、依存関係の解決、並列実行をサポート
- **目的**: 競技プログラミングの様々なタスクを統一的に実行できるエンジンの構築

## 実装すべき機能

### 1. ワークフロー定義
- JSONまたはYAML形式でのワークフロー定義
- ステップの依存関係の記述
- 条件分岐とループのサポート

### 2. ステップ実行器
- Shell、Docker、ファイル操作などの各種実行器
- 非同期実行とタイムアウト処理
- エラーハンドリングとリトライ機構

### 3. 依存関係の解決と最適化
- トポロジカルソートによる実行順序の決定
- 並列実行可能なステップの検出
- リソース最適化（mkdir、copyなどの統合）

### 4. 実行結果の管理
- 各ステップの実行結果の記録
- エラーログとデバッグ情報の収集
- 実行統計の集計

## 実装方針

### ディレクトリ構造
```
src/application/workflow/
├── mod.rs
├── definition.rs      # ワークフロー定義
├── step.rs           # ステップ定義
├── executor.rs       # 実行エンジン
├── scheduler.rs      # スケジューラー
└── result.rs         # 実行結果
```

### 主要な型定義
```rust
// ワークフローステップ
#[derive(Serialize, Deserialize)]
struct WorkflowStep {
    id: String,
    step_type: StepType,
    dependencies: Vec<String>,
    retry_policy: Option<RetryPolicy>,
}

// ステップタイプ
enum StepType {
    Shell(ShellCommand),
    Docker(DockerCommand),
    FileOperation(FileOp),
    Composite(Vec<WorkflowStep>),
}

// 実行エンジンのトレイト
trait WorkflowExecutor {
    async fn execute(&self, workflow: Workflow) -> Result<WorkflowResult>;
    fn validate(&self, workflow: &Workflow) -> Result<()>;
}
```

## 技術選定
- **tokio**: 非同期ランタイム
- **petgraph**: グラフ構造と依存関係の解決
- **futures**: 並列実行の管理
- **serde_json**: ワークフロー定義の解析

## 期待される効果
1. 複雑なビルド・テストプロセスの自動化
2. 並列実行による処理時間の短縮
3. 再利用可能なワークフローの定義
4. エラー時の詳細なデバッグ情報

## 実装優先度
**高**: コアとなる実行機能であり、他の多くの機能がこれに依存するため