# Rust移植計画 - old_srcからの移行戦略

## 1. 概要
old_srcのPythonコードベースをRustに移植するための包括的な計画書です。中長期を見据えた実装を行い、副作用はsrc/infrastructure配下に集中させ、main.rsから注入する設計とします。

## 2. 現状分析

### 2.1 old_srcの構造
- **cli/**: CLIアプリケーションのエントリーポイント
- **config/**: 設定管理システム
- **infrastructure/**: 副作用を扱うインフラストラクチャ層
  - drivers/: 各種ドライバー実装（Docker、File、Shell等）
  - persistence/: 永続化層（SQLite）
  - providers/: 外部リソースへのアクセス
- **operations/**: ビジネスロジックのインターフェース定義
- **repositories/**: データアクセス層
- **services/**: アプリケーションサービス層
- **workflow/**: ワークフロー実行エンジン

### 2.2 主要な副作用コンポーネント
1. **Docker Driver**: Dockerコンテナの管理
2. **File System Driver**: ファイルシステム操作
3. **Shell Driver**: シェルコマンド実行
4. **SQLite Manager**: データベース管理
5. **Output Manager**: ログ出力管理

## 3. 移植方針

### 3.1 アーキテクチャ設計
```
src/
├── main.rs              # エントリーポイント（DI設定）
├── domain/              # ドメインモデル
├── application/         # アプリケーションサービス
├── infrastructure/      # 副作用の実装
│   ├── drivers/
│   ├── persistence/
│   └── providers/
└── interfaces/          # トレイト定義
```

### 3.2 段階的移植計画

#### Phase 1: 基盤構築（1-2週間）
1. プロジェクト構造の確立
2. 基本的なトレイト定義
3. エラーハンドリング設計
4. ロギングシステムの実装

#### Phase 2: コア機能の移植（2-3週間）
1. 設定管理システム
2. ファイルシステム操作
3. シェルコマンド実行
4. 基本的なCLIインターフェース

#### Phase 3: Docker統合（2週間）
1. Docker APIクライアント
2. コンテナ管理機能
3. イメージ管理機能

#### Phase 4: 永続化層（1-2週間）
1. SQLiteインテグレーション
2. マイグレーションシステム
3. リポジトリパターンの実装

#### Phase 5: ワークフロー機能（2週間）
1. ステップ実行エンジン
2. 依存関係解決
3. 並列実行サポート

## 4. 技術選定

### 4.1 必要なクレート
- **tokio**: 非同期ランタイム
- **clap**: CLIパーサー
- **serde**: シリアライゼーション
- **sqlx**: SQLiteアクセス
- **bollard**: Docker API
- **anyhow/thiserror**: エラーハンドリング
- **tracing**: ロギング
- **config**: 設定管理

### 4.2 設計パターン
- **依存性注入**: main.rsでの副作用の注入
- **リポジトリパターン**: データアクセスの抽象化
- **Result型**: エラーハンドリング
- **トレイトベース**: インターフェースの定義

## 5. 移植優先順位

### 高優先度
1. CLIインターフェース（cli/）
2. 設定管理（config/）
3. ファイル操作（infrastructure/drivers/file/）
4. シェル実行（infrastructure/drivers/shell/）

### 中優先度
1. Docker統合（infrastructure/drivers/docker/）
2. 永続化層（infrastructure/persistence/）
3. ロギング（infrastructure/drivers/logging/）

### 低優先度
1. 高度なワークフロー機能
2. デバッグツール
3. パフォーマンス最適化

## 6. リスクと対策

### 6.1 技術的リスク
- **非同期処理の複雑性**: tokioの学習曲線
- **ライフタイム管理**: Rustの所有権システム
- **外部依存**: Docker APIの変更

### 6.2 対策
- 段階的な実装とテスト
- シンプルな同期版から開始
- インターフェースによる抽象化

## 7. 成功指標
- 既存のPython版と同等の機能
- パフォーマンスの向上（特に起動時間）
- メモリ使用量の削減
- 型安全性による信頼性向上

## 8. 次のステップ
1. 基本的なCargo.tomlの設定
2. プロジェクト構造の作成
3. 最初のトレイト定義
4. CLIエントリーポイントの実装開始