# 設定管理システムの構築計画

## 背景
old_srcでは、PureConfigManagerを中心とした副作用のない設定管理システムが実装されている。システム設定、環境設定、実行時設定など複数のレイヤーを持ち、デフォルト値を禁止することで明示的な設定を強制している。Rustプロジェクトでも同様の堅牢な設定管理が必要である。

## 現状分析
- old_srcの設定システムは複数のレイヤー（system、environment、runtime）を持つ
- ConfigResolverが優先順位に従って設定を解決
- デフォルト値の使用を禁止し、明示的な設定を要求
- 純粋関数として実装され、副作用がない

## Rustでの実装設計

### 1. 設定構造体の定義
```rust
// src/config/types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemConfig {
    pub workspace_dir: PathBuf,
    pub cache_dir: PathBuf,
    pub log_level: LogLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    pub timeout: Duration,
    pub max_retries: u32,
    pub parallel_jobs: usize,
}

#[derive(Debug, Clone)]
pub struct Config {
    pub system: SystemConfig,
    pub execution: ExecutionConfig,
    pub output: OutputConfig,
}
```

### 2. 設定マネージャー
```rust
// src/config/manager.rs
pub struct ConfigManager {
    layers: Vec<ConfigLayer>,
}

pub enum ConfigLayer {
    System(SystemConfig),
    Environment(EnvironmentConfig),
    Runtime(RuntimeConfig),
}

impl ConfigManager {
    pub fn new() -> Self;
    pub fn add_layer(&mut self, layer: ConfigLayer);
    pub fn resolve(&self) -> Result<Config>;
    fn validate(&self, config: &Config) -> Result<()>;
}
```

### 3. 設定リゾルバー
```rust
// src/config/resolver.rs
pub struct ConfigResolver;

impl ConfigResolver {
    pub fn resolve(layers: &[ConfigLayer]) -> Result<Config> {
        // 優先順位: Runtime > Environment > System
        // デフォルト値は使用せず、必須項目が未設定ならエラー
    }
    
    fn merge_configs(base: Config, overlay: PartialConfig) -> Config;
}
```

## 実装ステップ

### フェーズ1: 基本設定型の定義
1. 各種設定構造体の定義（System、Execution、Output）
2. SerdeによるJSON/YAML対応
3. バリデーションルールの定義

### フェーズ2: 設定レイヤーシステムの実装
1. ConfigLayerの実装
2. 優先順位に基づくマージロジック
3. 部分的な設定のオーバーレイ機能

### フェーズ3: 設定読み込み機能
1. ファイルからの設定読み込み
2. 環境変数からの設定読み込み
3. コマンドライン引数からの設定読み込み

### フェーズ4: バリデーションと型安全性
1. 必須項目のチェック
2. 値の範囲チェック
3. 相互依存する設定項目の整合性チェック

## 設定ファイル例
```toml
# config/default.toml
[system]
workspace_dir = "/home/user/cph"
cache_dir = "/home/user/.cache/cph"
log_level = "info"

[execution]
timeout = 300  # seconds
max_retries = 3
parallel_jobs = 4

[output]
format = "json"
color = true
verbose = false
```

## デフォルト値禁止の実装
```rust
// すべての設定項目をOption<T>として定義
#[derive(Deserialize)]
pub struct PartialSystemConfig {
    pub workspace_dir: Option<PathBuf>,
    pub cache_dir: Option<PathBuf>,
    pub log_level: Option<LogLevel>,
}

// resolveメソッドで必須チェック
impl ConfigResolver {
    fn ensure_required<T>(value: Option<T>, field: &str) -> Result<T> {
        value.ok_or_else(|| ConfigError::MissingRequired(field.to_string()))
    }
}
```

## 期待される効果
- **明示性**: デフォルト値に依存しない明示的な設定
- **柔軟性**: 複数の設定ソースからの読み込み
- **型安全性**: コンパイル時の設定値チェック
- **テスタビリティ**: 副作用のない純粋な実装

## 課題と対策
- **課題**: 設定項目の増加に伴う複雑性
- **対策**: 設定のグループ化と階層構造の活用
- **課題**: 実行時の設定変更
- **対策**: イミュータブルな設定とホットリロード機能の分離

## 参考実装
- old_src/config/pure_config_manager.py
- old_src/config/config_resolver.py
- old_src/config/system_config_loader.py