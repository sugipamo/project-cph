# DIコンテナ実装計画

## 概要
old_srcのinfrastructure/di_container.pyに実装されている依存性注入コンテナをRustに移植する計画。

## 背景と目的
- **現状**: main.rsにAppContainerの枠組みはあるが、本格的なDI機能は未実装
- **old_srcの実装**: DIKeyによる型安全なサービス識別と自動的な依存性解決
- **目的**: Rustの型システムを活用した依存性注入の実現

## 実装すべき機能

### 1. サービスレジストリ
- トレイトオブジェクトを使用したサービスの登録
- ライフタイム管理（Singleton、Transient）
- 遅延初期化のサポート

### 2. 依存性の自動解決
- コンストラクタ引数の自動注入
- 循環依存の検出
- エラーハンドリング

### 3. 型安全なサービス取得
- ジェネリクスを使用した型安全なAPI
- コンパイル時の型チェック

## 実装方針

### Rustにおける課題と解決策
1. **動的型付けの欠如**
   - 解決策: トレイトオブジェクトとAny型の組み合わせ
   - または: マクロによるコード生成

2. **ライフタイム管理**
   - 解決策: Arc<dyn Trait>による共有所有権
   - スレッドセーフティ: Arc<Mutex<T>>またはArc<RwLock<T>>

### 実装アプローチ案

#### 案1: トレイトオブジェクトベース
```rust
struct Container {
    services: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
}

impl Container {
    fn register<T: 'static + Send + Sync>(&mut self, service: T) {
        self.services.insert(TypeId::of::<T>(), Box::new(service));
    }
    
    fn resolve<T: 'static>(&self) -> Option<&T> {
        self.services
            .get(&TypeId::of::<T>())
            .and_then(|service| service.downcast_ref::<T>())
    }
}
```

#### 案2: マクロベース
```rust
di_container! {
    services: {
        FileSystem: LocalFileSystem,
        Logger: ConsoleLogger,
        ConfigManager: JsonConfigManager,
    }
}
```

### ディレクトリ構造
```
src/infrastructure/di/
├── mod.rs
├── container.rs      # コンテナ実装
├── registry.rs       # サービスレジストリ
├── macros.rs        # DIマクロ
└── errors.rs        # エラー型定義
```

## 技術選定
- **std::any::Any**: 型消去
- **std::sync::Arc**: 共有所有権
- **dashmap**: スレッドセーフなHashMap
- **once_cell**: 遅延初期化

## Rustの特性を活かした改善点
1. **コンパイル時の依存性チェック**
   - マクロによる静的な依存関係の検証

2. **ゼロコスト抽象化**
   - 実行時オーバーヘッドの最小化

3. **所有権システムの活用**
   - メモリ安全性の保証

## 期待される効果
1. テスタビリティの向上（モックの注入が容易）
2. 疎結合なアーキテクチャの実現
3. 設定による振る舞いの切り替え
4. 保守性の向上

## 実装優先度
**中**: 基盤機能として重要だが、初期段階では手動での依存性管理でも対応可能なため