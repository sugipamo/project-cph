# フォーマッターとコンテキスト管理移植計画

## 現状の問題点

### 1. Pythonのフォーマッター実装の複雑性
- domain/formatter.py、interfaces/output_formatter.pyの複雑な階層構造
- テキスト、JSON、テーブル、カラー出力の混在
- 出力フォーマットの動的切り替え機構

### 2. コンテキスト管理の課題
- ExecutionContext、EnvironmentContext、LoggingContextなど複数のコンテキスト
- 実行時状態の不透明な伝播
- グローバル状態への依存

## 対応方針

### Phase 1: フォーマッター基盤（優先度: 高）

#### 1.1 フォーマッタートレイトの定義
```rust
// src/domain/formatter.rs
use std::fmt::Display;
use serde::Serialize;

pub trait Formatter: Send + Sync {
    fn format_output<T: Serialize>(&self, data: &T) -> Result<String>;
    fn format_error(&self, error: &dyn std::error::Error) -> String;
    fn format_progress(&self, current: usize, total: usize, message: &str) -> String;
    fn supports_color(&self) -> bool;
}

pub trait OutputWriter: Send + Sync {
    fn write(&mut self, content: &str) -> Result<()>;
    fn write_line(&mut self, content: &str) -> Result<()>;
    fn flush(&mut self) -> Result<()>;
}

#[derive(Debug, Clone)]
pub enum OutputFormat {
    Text,
    Json,
    Table,
    Markdown,
    Html,
}

pub struct FormatterFactory;

impl FormatterFactory {
    pub fn create(format: OutputFormat, config: FormatterConfig) -> Box<dyn Formatter> {
        match format {
            OutputFormat::Text => Box::new(TextFormatter::new(config)),
            OutputFormat::Json => Box::new(JsonFormatter::new(config)),
            OutputFormat::Table => Box::new(TableFormatter::new(config)),
            OutputFormat::Markdown => Box::new(MarkdownFormatter::new(config)),
            OutputFormat::Html => Box::new(HtmlFormatter::new(config)),
        }
    }
}
```

#### 1.2 テキストフォーマッター実装
```rust
// src/infrastructure/formatters/text_formatter.rs
use colored::*;
use textwrap::fill;

pub struct TextFormatter {
    config: FormatterConfig,
    color_enabled: bool,
}

#[derive(Debug, Clone)]
pub struct FormatterConfig {
    pub use_color: bool,
    pub line_width: usize,
    pub indent_size: usize,
    pub timestamp_format: String,
}

impl TextFormatter {
    pub fn new(config: FormatterConfig) -> Self {
        let color_enabled = config.use_color && atty::is(atty::Stream::Stdout);
        Self {
            config,
            color_enabled,
        }
    }

    fn colorize(&self, text: &str, color: Color) -> String {
        if self.color_enabled {
            text.color(color).to_string()
        } else {
            text.to_string()
        }
    }

    fn format_status(&self, status: &str) -> String {
        match status.to_lowercase().as_str() {
            "success" | "ac" | "passed" => self.colorize(status, Color::Green),
            "failed" | "wa" | "error" => self.colorize(status, Color::Red),
            "warning" | "tle" | "mle" => self.colorize(status, Color::Yellow),
            "info" | "running" => self.colorize(status, Color::Blue),
            _ => status.to_string(),
        }
    }
}

impl Formatter for TextFormatter {
    fn format_output<T: Serialize>(&self, data: &T) -> Result<String> {
        let value = serde_json::to_value(data)?;
        
        let mut output = String::new();
        self.format_value(&mut output, &value, 0)?;
        
        Ok(output)
    }

    fn format_error(&self, error: &dyn std::error::Error) -> String {
        let error_prefix = self.colorize("Error: ", Color::Red);
        format!("{}{}", error_prefix, error)
    }

    fn format_progress(&self, current: usize, total: usize, message: &str) -> String {
        let percentage = (current as f64 / total as f64 * 100.0) as u32;
        let bar_width = 40;
        let filled = (bar_width * current / total).min(bar_width);
        
        let bar = format!(
            "[{}{}]",
            "=".repeat(filled),
            " ".repeat(bar_width - filled)
        );
        
        format!(
            "{} {}% {}",
            self.colorize(&bar, Color::Cyan),
            percentage,
            message
        )
    }

    fn supports_color(&self) -> bool {
        self.color_enabled
    }
}
```

### Phase 2: 構造化出力フォーマッター（優先度: 高）

#### 2.1 JSONフォーマッター
```rust
// src/infrastructure/formatters/json_formatter.rs
use serde_json;

pub struct JsonFormatter {
    pretty: bool,
    compact: bool,
}

impl JsonFormatter {
    pub fn new(config: FormatterConfig) -> Self {
        Self {
            pretty: config.get("pretty").unwrap_or(true),
            compact: config.get("compact").unwrap_or(false),
        }
    }
}

impl Formatter for JsonFormatter {
    fn format_output<T: Serialize>(&self, data: &T) -> Result<String> {
        if self.compact {
            serde_json::to_string(data)
                .map_err(|e| FormatterError::SerializationError(e.to_string()))
        } else if self.pretty {
            serde_json::to_string_pretty(data)
                .map_err(|e| FormatterError::SerializationError(e.to_string()))
        } else {
            serde_json::to_string(data)
                .map_err(|e| FormatterError::SerializationError(e.to_string()))
        }
    }

    fn format_error(&self, error: &dyn std::error::Error) -> String {
        json!({
            "error": true,
            "message": error.to_string(),
            "type": "error"
        }).to_string()
    }

    fn format_progress(&self, current: usize, total: usize, message: &str) -> String {
        json!({
            "progress": {
                "current": current,
                "total": total,
                "percentage": (current as f64 / total as f64 * 100.0),
                "message": message
            }
        }).to_string()
    }

    fn supports_color(&self) -> bool {
        false
    }
}
```

#### 2.2 テーブルフォーマッター
```rust
// src/infrastructure/formatters/table_formatter.rs
use prettytable::{Table, Row, Cell, format};

pub struct TableFormatter {
    config: FormatterConfig,
}

impl TableFormatter {
    pub fn new(config: FormatterConfig) -> Self {
        Self { config }
    }

    fn create_table<T: Serialize>(&self, data: &T) -> Result<Table> {
        let value = serde_json::to_value(data)?;
        let mut table = Table::new();
        
        match value {
            Value::Array(items) => {
                if let Some(first) = items.first() {
                    // ヘッダー作成
                    if let Value::Object(map) = first {
                        let headers: Vec<Cell> = map.keys()
                            .map(|k| Cell::new(k))
                            .collect();
                        table.add_row(Row::new(headers));
                    }
                    
                    // データ行追加
                    for item in items {
                        if let Value::Object(map) = item {
                            let cells: Vec<Cell> = map.values()
                                .map(|v| Cell::new(&self.value_to_string(v)))
                                .collect();
                            table.add_row(Row::new(cells));
                        }
                    }
                }
            }
            Value::Object(map) => {
                for (key, value) in map {
                    table.add_row(Row::new(vec![
                        Cell::new(&key),
                        Cell::new(&self.value_to_string(&value))
                    ]));
                }
            }
            _ => {
                table.add_row(Row::new(vec![
                    Cell::new(&self.value_to_string(&value))
                ]));
            }
        }
        
        Ok(table)
    }

    fn value_to_string(&self, value: &Value) -> String {
        match value {
            Value::String(s) => s.clone(),
            Value::Number(n) => n.to_string(),
            Value::Bool(b) => b.to_string(),
            Value::Null => "null".to_string(),
            _ => serde_json::to_string(value).unwrap_or_default(),
        }
    }
}

impl Formatter for TableFormatter {
    fn format_output<T: Serialize>(&self, data: &T) -> Result<String> {
        let table = self.create_table(data)?;
        Ok(table.to_string())
    }
}
```

### Phase 3: コンテキスト管理（優先度: 高）

#### 3.1 実行コンテキスト
```rust
// src/application/context/execution_context.rs
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub struct ExecutionContext {
    pub session_id: String,
    pub problem_id: Option<String>,
    pub language: Language,
    pub environment: Environment,
    pub metadata: HashMap<String, Value>,
    logger: Arc<dyn Logger>,
    formatter: Arc<dyn Formatter>,
}

impl ExecutionContext {
    pub fn new(
        session_id: String,
        language: Language,
        environment: Environment,
        logger: Arc<dyn Logger>,
        formatter: Arc<dyn Formatter>,
    ) -> Self {
        Self {
            session_id,
            problem_id: None,
            language,
            environment,
            metadata: HashMap::new(),
            logger,
            formatter,
        }
    }

    pub fn with_problem(&mut self, problem_id: String) -> &mut Self {
        self.problem_id = Some(problem_id);
        self
    }

    pub fn add_metadata(&mut self, key: String, value: Value) -> &mut Self {
        self.metadata.insert(key, value);
        self
    }

    pub fn child_context(&self) -> Self {
        let mut child = self.clone();
        child.session_id = format!("{}-{}", self.session_id, Uuid::new_v4());
        child
    }

    pub fn log(&self, level: LogLevel, message: &str) {
        self.logger.log(level, &self.format_log_message(message));
    }

    fn format_log_message(&self, message: &str) -> String {
        format!(
            "[{}] [{}] {}",
            self.session_id,
            self.problem_id.as_deref().unwrap_or("global"),
            message
        )
    }
}
```

#### 3.2 環境コンテキスト
```rust
// src/application/context/environment_context.rs
#[derive(Debug, Clone)]
pub struct EnvironmentContext {
    pub runtime: RuntimeEnvironment,
    pub variables: HashMap<String, String>,
    pub paths: PathContext,
    pub limits: ExecutionLimits,
}

#[derive(Debug, Clone)]
pub enum RuntimeEnvironment {
    Local {
        work_dir: PathBuf,
        temp_dir: PathBuf,
    },
    Docker {
        image: String,
        volumes: Vec<VolumeMount>,
        network: Option<String>,
    },
    Remote {
        host: String,
        port: u16,
        credentials: Credentials,
    },
}

#[derive(Debug, Clone)]
pub struct PathContext {
    pub base_dir: PathBuf,
    pub source_file: PathBuf,
    pub executable: Option<PathBuf>,
    pub test_data_dir: PathBuf,
    pub output_dir: PathBuf,
}

#[derive(Debug, Clone)]
pub struct ExecutionLimits {
    pub time_limit: Duration,
    pub memory_limit: usize,
    pub stack_limit: usize,
    pub process_limit: usize,
}

impl EnvironmentContext {
    pub fn resolve_path(&self, relative: &Path) -> PathBuf {
        if relative.is_absolute() {
            relative.to_path_buf()
        } else {
            self.paths.base_dir.join(relative)
        }
    }

    pub fn expand_variables(&self, text: &str) -> String {
        let mut result = text.to_string();
        
        for (key, value) in &self.variables {
            let placeholder = format!("${{{}}}", key);
            result = result.replace(&placeholder, value);
        }
        
        // 環境変数も展開
        for (key, value) in std::env::vars() {
            let placeholder = format!("${{env:{}}}", key);
            result = result.replace(&placeholder, &value);
        }
        
        result
    }
}
```

### Phase 4: 統合出力システム（優先度: 中）

#### 4.1 出力パイプライン
```rust
// src/application/output/pipeline.rs
use tokio::sync::mpsc;

pub struct OutputPipeline {
    formatter: Arc<dyn Formatter>,
    writers: Vec<Box<dyn OutputWriter>>,
    filters: Vec<Box<dyn OutputFilter>>,
}

#[async_trait]
pub trait OutputFilter: Send + Sync {
    async fn filter(&self, content: &str) -> Option<String>;
}

pub struct OutputMessage {
    pub level: OutputLevel,
    pub content: String,
    pub metadata: HashMap<String, Value>,
    pub timestamp: DateTime<Utc>,
}

impl OutputPipeline {
    pub fn new(formatter: Arc<dyn Formatter>) -> Self {
        Self {
            formatter,
            writers: Vec::new(),
            filters: Vec::new(),
        }
    }

    pub fn add_writer(&mut self, writer: Box<dyn OutputWriter>) {
        self.writers.push(writer);
    }

    pub fn add_filter(&mut self, filter: Box<dyn OutputFilter>) {
        self.filters.push(filter);
    }

    pub async fn process(&mut self, message: OutputMessage) -> Result<()> {
        // フォーマット
        let formatted = self.formatter.format_output(&message)?;
        
        // フィルタリング
        let mut content = formatted;
        for filter in &self.filters {
            if let Some(filtered) = filter.filter(&content).await {
                content = filtered;
            } else {
                return Ok(()); // フィルタが出力を拒否
            }
        }
        
        // 書き込み
        for writer in &mut self.writers {
            writer.write_line(&content)?;
        }
        
        Ok(())
    }
}
```

#### 4.2 コンテキストアウェア出力
```rust
// src/application/output/context_aware.rs
pub struct ContextAwareOutput {
    pipeline: OutputPipeline,
    context: Arc<RwLock<ExecutionContext>>,
}

impl ContextAwareOutput {
    pub fn new(
        formatter: Arc<dyn Formatter>,
        context: Arc<RwLock<ExecutionContext>>,
    ) -> Self {
        Self {
            pipeline: OutputPipeline::new(formatter),
            context,
        }
    }

    pub async fn info(&mut self, message: &str) -> Result<()> {
        self.output(OutputLevel::Info, message).await
    }

    pub async fn success(&mut self, message: &str) -> Result<()> {
        self.output(OutputLevel::Success, message).await
    }

    pub async fn error(&mut self, error: &dyn std::error::Error) -> Result<()> {
        let formatted = self.pipeline.formatter.format_error(error);
        self.output(OutputLevel::Error, &formatted).await
    }

    pub async fn progress(&mut self, current: usize, total: usize, message: &str) -> Result<()> {
        let formatted = self.pipeline.formatter.format_progress(current, total, message);
        self.output(OutputLevel::Progress, &formatted).await
    }

    async fn output(&mut self, level: OutputLevel, content: &str) -> Result<()> {
        let context = self.context.read().await;
        
        let message = OutputMessage {
            level,
            content: content.to_string(),
            metadata: context.metadata.clone(),
            timestamp: Utc::now(),
        };
        
        self.pipeline.process(message).await
    }
}
```

### Phase 5: 高度な機能（優先度: 低）

#### 5.1 ストリーミング出力
```rust
// src/application/output/streaming.rs
pub struct StreamingOutput {
    sender: mpsc::Sender<OutputMessage>,
    formatter: Arc<dyn Formatter>,
}

impl StreamingOutput {
    pub fn new(capacity: usize) -> (Self, mpsc::Receiver<OutputMessage>) {
        let (sender, receiver) = mpsc::channel(capacity);
        
        (
            Self {
                sender,
                formatter: Arc::new(TextFormatter::default()),
            },
            receiver
        )
    }

    pub async fn stream<S: Stream<Item = String>>(&self, stream: S) -> Result<()> {
        pin_mut!(stream);
        
        while let Some(chunk) = stream.next().await {
            let message = OutputMessage {
                level: OutputLevel::Stream,
                content: chunk,
                metadata: HashMap::new(),
                timestamp: Utc::now(),
            };
            
            self.sender.send(message).await?;
        }
        
        Ok(())
    }
}
```

## 実装上の考慮事項

### 1. パフォーマンス最適化
- 大量出力時のバッファリング
- 非同期I/Oの活用
- メモリ効率的なストリーミング
- 遅延フォーマッティング

### 2. 拡張性の確保
- カスタムフォーマッターの追加容易性
- プラグイン可能な出力フィルター
- 新しい出力先の追加
- カスタムコンテキストフィールド

### 3. エラーハンドリング
- 出力エラーの適切な処理
- フォーマッティングエラーの回復
- パイプライン障害の伝播
- グレースフルデグレード

## 期待される効果

1. **柔軟性の向上**
   - 出力形式の動的切り替え
   - コンテキストベースのフォーマッティング
   - カスタマイズ可能な出力パイプライン

2. **保守性の向上**
   - 明確な責任分離
   - テスタブルな設計
   - 拡張可能なアーキテクチャ

3. **ユーザビリティの向上**
   - 一貫した出力形式
   - 適切なエラーメッセージ
   - プログレス表示の統一

## リスクと対策

### リスク
- 既存出力形式との互換性問題
- パフォーマンスオーバーヘッド
- 複雑性の増加

### 対策
- 互換性モードの提供
- ベンチマークによる性能検証
- シンプルなデフォルト実装
- 段階的な機能追加

## 実装優先順位

1. **即座に実装すべき項目**
   - 基本的なフォーマッタートレイト
   - テキストフォーマッター
   - 実行コンテキスト

2. **短期的に実装すべき項目**
   - JSONフォーマッター
   - テーブルフォーマッター
   - 出力パイプライン

3. **中長期的に検討する項目**
   - ストリーミング出力
   - 高度なフィルタリング
   - カスタムフォーマッター