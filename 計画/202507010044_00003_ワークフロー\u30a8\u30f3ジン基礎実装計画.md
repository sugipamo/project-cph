# ワークフローエンジン基礎実装計画

## 概要
「基本ワークフロー」で定義されているユーザーフローを実現するため、コンテスト問題の取り組みから提出までを管理するワークフローエンジンを実装する。old_srcの複雑なワークフロー実装を参考にしつつ、Rustで簡潔かつ拡張可能な設計を目指す。

## 現状分析

### 要求機能
- 問題URLからの情報自動取得
- テスト環境の準備
- 並列テスト実行
- 提出準備と最終チェック

### 参考実装（old_src）
- workflow/step/にステップベースの実装
- 依存関係管理機能
- 並列実行サポート

### 課題
1. ワークフロー定義の柔軟性不足
2. エラーハンドリングの複雑さ
3. 状態管理の困難さ

## 改善方針

### 1. ステートマシンベースの設計
```rust
// src/domain/workflow/state.rs
pub enum WorkflowState {
    Initial,
    ProblemFetched { url: String, problem_info: ProblemInfo },
    EnvironmentPrepared { template: Template },
    TestsExecuted { results: Vec<TestResult> },
    ReadyToSubmit { final_code: String },
    Completed,
}

pub trait WorkflowTransition {
    fn can_transition(&self, from: &WorkflowState) -> bool;
    fn execute(&self, state: WorkflowState) -> Result<WorkflowState>;
}
```

### 2. コマンドパターンの採用
- 各操作をコマンドとして実装
- アンドゥ/リドゥの可能性を確保
- 非同期実行のサポート

### 3. 実装計画
1. Phase 1: 基本的なワークフロー定義（1週間）
2. Phase 2: コマンド実装（2週間）
3. Phase 3: 状態管理とpersistence（1週間）
4. Phase 4: CLI統合（3日）

## 期待される効果
- ユーザー体験の向上
- エラーからの回復可能性
- ワークフローのカスタマイズ性
- 実行履歴の管理

## リスクと対策
- **リスク**: 過度に複雑な状態遷移
- **対策**: 最小限の状態から開始し、段階的に拡張

## 成功指標
- 問題取得から提出まで3コマンド以内で完了
- エラー発生時の適切なリカバリー
- 実行時間の90%以上が実際の処理に使用される