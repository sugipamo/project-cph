# ドメイン層純粋関数実装計画

## 概要
ドメイン層を完全な純粋関数で構成し、ビジネスロジックの予測可能性とテスト容易性を確保する。

## 現状分析
Pythonコードベースのドメイン層の優れた点:
- 純粋関数によるワークフロー変換
- 不変データ構造（Step, StepContext等）
- 関数合成によるパイプライン処理

## 目標
- **完全な副作用排除**: ドメイン層での副作用ゼロ
- **不変性の徹底**: すべてのデータ構造を不変に
- **関数型プログラミング**: 高階関数とモナドの活用

## 設計方針

### 1. コアドメインモデル
```rust
// 不変データ構造
#[derive(Clone, Debug, PartialEq)]
pub struct Workflow {
    pub id: WorkflowId,
    pub steps: Vec<Step>,
    pub dependencies: Vec<Dependency>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Step {
    pub id: StepId,
    pub step_type: StepType,
    pub context: StepContext,
}

// すべてのフィールドは不変
impl Step {
    pub fn new(id: StepId, step_type: StepType, context: StepContext) -> Self {
        Self { id, step_type, context }
    }
}
```

### 2. 純粋関数パイプライン
```rust
// ワークフロー変換パイプライン
pub fn transform_workflow(workflow: Workflow) -> Result<Workflow, DomainError> {
    workflow
        .validate()?
        .resolve_dependencies()?
        .optimize_steps()?
        .verify_constraints()
}

// 各変換は純粋関数
impl Workflow {
    fn validate(self) -> Result<Self, DomainError> {
        // バリデーションロジック（副作用なし）
        Ok(self)
    }
    
    fn resolve_dependencies(self) -> Result<Self, DomainError> {
        // 依存関係解決（純粋な計算）
        Ok(self)
    }
}
```

### 3. エラーハンドリング
```rust
// Result型による明示的なエラーハンドリング
#[derive(Debug, thiserror::Error)]
pub enum DomainError {
    #[error("Invalid workflow: {0}")]
    InvalidWorkflow(String),
    
    #[error("Dependency cycle detected")]
    DependencyCycle,
    
    #[error("Step not found: {0}")]
    StepNotFound(StepId),
}
```

## 実装項目

### 基本データ構造
- [ ] Workflow, Step, Dependency の定義
- [ ] StepType, StepContext の実装
- [ ] RequestType, ExecutionInterface の定義

### ステップ処理システム
- [ ] StepGenerator トレイトの実装
- [ ] テンプレート展開機能
- [ ] ファイルパターン処理
- [ ] 条件評価システム

### 依存関係解決
- [ ] 依存グラフの構築
- [ ] トポロジカルソート
- [ ] 循環依存検出
- [ ] 準備ステップの自動生成

### 最適化パイプライン
- [ ] 冗長ステップの除去
- [ ] 並列実行可能性の分析
- [ ] リソース使用の最適化

## 実施計画

### Phase 1: 基本構造の実装（2週間）
- [ ] コアデータ型の定義
- [ ] 基本的な変換関数
- [ ] ユニットテストの作成

### Phase 2: 高度な機能（3週間）
- [ ] 依存関係解決エンジン
- [ ] 最適化アルゴリズム
- [ ] バリデーションシステム

### Phase 3: 統合とテスト（1週間）
- [ ] 他層との統合
- [ ] プロパティベーステスト
- [ ] パフォーマンステスト

## テスト戦略

### ユニットテスト
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    
    proptest! {
        #[test]
        fn workflow_transformation_is_pure(workflow in arbitrary_workflow()) {
            let result1 = transform_workflow(workflow.clone());
            let result2 = transform_workflow(workflow);
            assert_eq!(result1, result2);
        }
    }
}
```

### プロパティベーステスト
- 純粋性の検証（同じ入力→同じ出力）
- 不変性の検証
- 変換の可逆性

## 成功指標
- 副作用を含む関数: 0個
- テストカバレッジ: 95%以上
- プロパティテストの網羅性: 主要な不変条件をカバー

## パフォーマンス考慮
- 遅延評価の活用
- メモ化による重複計算の回避
- 並列処理可能な設計

## 長期的な展望
- 形式的検証の導入
- DSLによるワークフロー記述
- ビジュアルデバッガーの開発