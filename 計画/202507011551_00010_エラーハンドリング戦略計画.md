# エラーハンドリング戦略計画

## 概要
old_srcの階層的なエラーハンドリングとエラーコンバータの仕組みをRustのエラーハンドリングのベストプラクティスに適応させて実装する。

## 現状分析
### old_srcの実装
- エラーコードによる分類
- ErrorConverterによる変換
- Pythonの例外階層を活用
- リトライデコレータによる自動リトライ

### 現在のRustプロジェクト
- 基本的なエラー型は定義済み
- thiserrorを使用
- エラーコンテキストは限定的
- リトライ機構なし

## 実装方針
### 1. エラー型の階層化
```rust
// src/errors/mod.rs
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Infrastructure error: {0}")]
    Infrastructure(#[from] InfrastructureError),
    
    #[error("Domain error: {0}")]
    Domain(#[from] DomainError),
    
    #[error("Application error: {0}")]
    Application(#[from] ApplicationError),
}

#[derive(Debug, thiserror::Error)]
pub enum InfrastructureError {
    #[error("File system error: {message}")]
    FileSystem {
        message: String,
        #[source]
        source: std::io::Error,
        path: Option<PathBuf>,
    },
    
    #[error("Docker error: {0}")]
    Docker(#[from] DockerError),
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
}
```

### 2. エラーコンテキスト
```rust
// src/errors/context.rs
pub trait ErrorContext<T> {
    fn context<C>(self, context: C) -> Result<T, AppError>
    where
        C: Display + Send + Sync + 'static;
        
    fn with_context<C, F>(self, f: F) -> Result<T, AppError>
    where
        C: Display + Send + Sync + 'static,
        F: FnOnce() -> C;
}

impl<T, E> ErrorContext<T> for Result<T, E>
where
    E: Into<AppError>,
{
    // 実装
}
```

### 3. エラー分類とリトライ
```rust
// src/errors/classification.rs
pub trait ErrorClassification {
    fn is_retryable(&self) -> bool;
    fn suggested_retry_after(&self) -> Option<Duration>;
    fn error_code(&self) -> ErrorCode;
}

#[derive(Debug, Clone, Copy)]
pub enum ErrorCode {
    // 一時的なエラー（リトライ可能）
    NetworkTimeout,
    ResourceBusy,
    RateLimited,
    
    // 永続的なエラー（リトライ不可）
    InvalidInput,
    NotFound,
    PermissionDenied,
}
```

### 4. リトライメカニズム
```rust
// src/infrastructure/retry.rs
pub struct RetryPolicy {
    max_attempts: u32,
    backoff: BackoffStrategy,
    retryable_errors: HashSet<ErrorCode>,
}

pub async fn with_retry<F, T, E>(
    policy: &RetryPolicy,
    operation: F,
) -> Result<T, E>
where
    F: Fn() -> Future<Output = Result<T, E>>,
    E: ErrorClassification,
{
    // 実装
}
```

## エラー処理のベストプラクティス
### 1. 早期リターン
```rust
fn process_file(path: &Path) -> Result<String> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read file: {}", path.display()))?;
    
    let parsed = parse_content(&content)
        .context("Failed to parse file content")?;
    
    Ok(parsed)
}
```

### 2. エラーの変換と伝播
```rust
impl From<std::io::Error> for FileSystemError {
    fn from(err: std::io::Error) -> Self {
        FileSystemError {
            message: err.to_string(),
            source: err,
            path: None,
        }
    }
}
```

### 3. カスタムResult型
```rust
pub type AppResult<T> = Result<T, AppError>;
pub type InfraResult<T> = Result<T, InfrastructureError>;
```

## 実装ステップ
1. エラー型の階層的な定義
2. ErrorContextトレイトの実装
3. エラー分類システムの構築
4. リトライポリシーとメカニズム
5. 既存エラーの移行
6. エラーレポーティング機能

## 考慮事項
- エラーメッセージの国際化対応
- スタックトレースの保持（デバッグビルド）
- エラーのシリアライズ（API応答用）
- パニックの適切な使用（回復不可能なエラーのみ）