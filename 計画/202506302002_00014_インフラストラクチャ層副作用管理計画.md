# インフラストラクチャ層副作用管理計画

## 概要
すべての副作用をインフラストラクチャ層に集約し、main.rsからの依存性注入により制御可能にする。

## 現状分析
Pythonコードベースの優れた設計:
- Provider Patternによる副作用の集約
- Mock実装によるテスト容易性
- DIコンテナによる依存性管理

## 目標
- **副作用の完全分離**: 他層での副作用ゼロ
- **テスタビリティ**: すべての副作用をモック可能に
- **型安全性**: Rustの型システムで副作用を明示

## 設計方針

### 1. トレイトベースの抽象化
```rust
// ファイルシステムの抽象化
#[async_trait]
pub trait FileSystem: Send + Sync {
    async fn read(&self, path: &Path) -> Result<String, FileSystemError>;
    async fn write(&self, path: &Path, content: &str) -> Result<(), FileSystemError>;
    async fn exists(&self, path: &Path) -> Result<bool, FileSystemError>;
}

// 実装
pub struct RealFileSystem;

#[async_trait]
impl FileSystem for RealFileSystem {
    async fn read(&self, path: &Path) -> Result<String, FileSystemError> {
        tokio::fs::read_to_string(path)
            .await
            .map_err(FileSystemError::from)
    }
}

// モック実装
pub struct MockFileSystem {
    files: Arc<Mutex<HashMap<PathBuf, String>>>,
}
```

### 2. 依存性注入コンテナ
```rust
pub struct Container {
    file_system: Arc<dyn FileSystem>,
    shell_executor: Arc<dyn ShellExecutor>,
    docker_client: Arc<dyn DockerClient>,
    database: Arc<dyn Database>,
}

impl Container {
    pub fn new() -> Self {
        Self {
            file_system: Arc::new(RealFileSystem),
            shell_executor: Arc::new(RealShellExecutor),
            docker_client: Arc::new(RealDockerClient),
            database: Arc::new(SqliteDatabase::new()),
        }
    }
    
    pub fn with_mocks() -> Self {
        Self {
            file_system: Arc::new(MockFileSystem::new()),
            shell_executor: Arc::new(MockShellExecutor::new()),
            docker_client: Arc::new(MockDockerClient::new()),
            database: Arc::new(InMemoryDatabase::new()),
        }
    }
}
```

### 3. ドライバーパターン
```rust
// 統一ドライバーインターフェース
#[async_trait]
pub trait Driver: Send + Sync {
    type Request;
    type Response;
    type Error: std::error::Error;
    
    async fn execute(&self, request: Self::Request) -> Result<Self::Response, Self::Error>;
}

// ファイルドライバー
pub struct FileDriver {
    file_system: Arc<dyn FileSystem>,
}

#[async_trait]
impl Driver for FileDriver {
    type Request = FileRequest;
    type Response = FileResponse;
    type Error = FileDriverError;
    
    async fn execute(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        match request {
            FileRequest::Read(path) => {
                let content = self.file_system.read(&path).await?;
                Ok(FileResponse::Content(content))
            }
            // 他の操作...
        }
    }
}
```

## 実装項目

### プロバイダー層
- [ ] FileSystemProvider（ファイル操作）
- [ ] ShellProvider（シェルコマンド実行）
- [ ] DockerProvider（Docker操作）
- [ ] DatabaseProvider（データベース操作）
- [ ] NetworkProvider（ネットワーク操作）

### ドライバー層
- [ ] UnifiedDriver（統一エントリーポイント）
- [ ] FileDriver（ファイル操作特化）
- [ ] DockerDriver（Docker操作特化）
- [ ] ShellDriver（シェル実行特化）

### 依存性注入
- [ ] DIコンテナの実装
- [ ] ライフタイム管理
- [ ] 設定ベースの切り替え

## 実施計画

### Phase 1: 基盤構築（2週間）
- [ ] トレイト定義
- [ ] 基本的なプロバイダー実装
- [ ] DIコンテナの基本実装

### Phase 2: ドライバー実装（3週間）
- [ ] 各種ドライバーの実装
- [ ] エラーハンドリング統一
- [ ] ログ出力統合

### Phase 3: テスト基盤（2週間）
- [ ] モック実装の完成
- [ ] テストユーティリティ
- [ ] 統合テスト

## エラーハンドリング
```rust
#[derive(Debug, thiserror::Error)]
pub enum InfrastructureError {
    #[error("File system error: {0}")]
    FileSystem(#[from] FileSystemError),
    
    #[error("Shell execution error: {0}")]
    ShellExecution(#[from] ShellError),
    
    #[error("Docker operation error: {0}")]
    Docker(#[from] DockerError),
}

// リトライ機能
pub async fn with_retry<F, T, E>(
    operation: F,
    max_attempts: u32,
) -> Result<T, E>
where
    F: Fn() -> Future<Output = Result<T, E>>,
{
    // リトライロジック
}
```

## テスト戦略
```rust
#[tokio::test]
async fn test_file_operations() {
    // モックを使用したテスト
    let container = Container::with_mocks();
    let file_driver = FileDriver::new(container.file_system.clone());
    
    // テストデータの準備
    let test_content = "test content";
    let test_path = Path::new("/test.txt");
    
    // 書き込みテスト
    let write_request = FileRequest::Write(test_path.to_owned(), test_content.to_owned());
    file_driver.execute(write_request).await.unwrap();
    
    // 読み込みテスト
    let read_request = FileRequest::Read(test_path.to_owned());
    let response = file_driver.execute(read_request).await.unwrap();
    
    assert_eq!(response, FileResponse::Content(test_content.to_owned()));
}
```

## 成功指標
- 他層での副作用: 0件
- モックカバレッジ: 100%
- テスト実行時間: 実装の10%以下

## セキュリティ考慮
- パス traversal 攻撃の防止
- コマンドインジェクションの防止
- 権限管理の実装

## パフォーマンス最適化
- 非同期処理の活用
- コネクションプーリング
- キャッシング戦略

## 長期展望
- プラグインシステムの構築
- 新しい外部システムの容易な追加
- 分散システムへの対応