# 永続化層とリポジトリパターン移植計画

## 現状の問題点

### 1. Python永続化層の複雑性
- infrastructure/persistence配下の多数のリポジトリ実装
- SQLite、ファイルシステム、メモリストアの混在
- トランザクション管理の不一致

### 2. Rustプロジェクトとの不整合
- 現在のRustプロジェクトに統一的な永続化層が欠如
- リポジトリパターンの未実装
- データアクセスの一貫性欠如

## 対応方針

### Phase 1: リポジトリ基盤の構築（優先度: 高）

#### 1.1 リポジトリトレイトの定義
```rust
// src/domain/repository.rs
use async_trait::async_trait;
use std::error::Error;

#[async_trait]
pub trait Repository<T, ID>: Send + Sync {
    type Error: Error + Send + Sync + 'static;
    
    async fn find_by_id(&self, id: &ID) -> Result<Option<T>, Self::Error>;
    async fn find_all(&self) -> Result<Vec<T>, Self::Error>;
    async fn save(&self, entity: &T) -> Result<(), Self::Error>;
    async fn delete(&self, id: &ID) -> Result<bool, Self::Error>;
    async fn exists(&self, id: &ID) -> Result<bool, Self::Error>;
}

#[async_trait]
pub trait QueryRepository<T, Q>: Repository<T, String> {
    async fn find_by_query(&self, query: &Q) -> Result<Vec<T>, Self::Error>;
    async fn count_by_query(&self, query: &Q) -> Result<usize, Self::Error>;
}

#[async_trait]
pub trait TransactionalRepository<T, ID>: Repository<T, ID> {
    type Transaction: Send + Sync;
    
    async fn begin_transaction(&self) -> Result<Self::Transaction, Self::Error>;
    async fn commit(&self, tx: Self::Transaction) -> Result<(), Self::Error>;
    async fn rollback(&self, tx: Self::Transaction) -> Result<(), Self::Error>;
}
```

#### 1.2 エンティティの定義
```rust
// src/domain/entities/mod.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

pub trait Entity {
    type ID: Clone + Send + Sync;
    
    fn id(&self) -> &Self::ID;
    fn created_at(&self) -> &DateTime<Utc>;
    fn updated_at(&self) -> &DateTime<Utc>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    pub id: String,
    pub problem_id: String,
    pub test_case_id: String,
    pub status: TestStatus,
    pub output: String,
    pub error: Option<String>,
    pub execution_time: Duration,
    pub memory_usage: u64,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Entity for TestResult {
    type ID = String;
    
    fn id(&self) -> &Self::ID {
        &self.id
    }
    
    fn created_at(&self) -> &DateTime<Utc> {
        &self.created_at
    }
    
    fn updated_at(&self) -> &DateTime<Utc> {
        &self.updated_at
    }
}
```

### Phase 2: SQLite実装（優先度: 高）

#### 2.1 SQLiteリポジトリ基盤
```rust
// src/infrastructure/persistence/sqlite/mod.rs
use sqlx::{SqlitePool, SqliteConnection, Transaction};
use std::sync::Arc;

pub struct SqliteRepositoryBase {
    pool: Arc<SqlitePool>,
}

impl SqliteRepositoryBase {
    pub async fn new(database_url: &str) -> Result<Self> {
        let pool = SqlitePool::connect(database_url).await?;
        
        // マイグレーション実行
        sqlx::migrate!("./migrations")
            .run(&pool)
            .await?;
        
        Ok(Self {
            pool: Arc::new(pool),
        })
    }
    
    pub fn pool(&self) -> &SqlitePool {
        &self.pool
    }
}

// src/infrastructure/persistence/sqlite/test_result_repository.rs
pub struct SqliteTestResultRepository {
    base: SqliteRepositoryBase,
}

#[async_trait]
impl Repository<TestResult, String> for SqliteTestResultRepository {
    type Error = SqliteError;
    
    async fn find_by_id(&self, id: &String) -> Result<Option<TestResult>, Self::Error> {
        let result = sqlx::query_as!(
            TestResult,
            r#"
            SELECT 
                id, problem_id, test_case_id, 
                status as "status: TestStatus",
                output, error, 
                execution_time as "execution_time: Duration",
                memory_usage as "memory_usage: i64",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM test_results
            WHERE id = ?1
            "#,
            id
        )
        .fetch_optional(self.base.pool())
        .await?;
        
        Ok(result)
    }
    
    async fn save(&self, entity: &TestResult) -> Result<(), Self::Error> {
        sqlx::query!(
            r#"
            INSERT INTO test_results (
                id, problem_id, test_case_id, status, 
                output, error, execution_time, memory_usage,
                created_at, updated_at
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)
            ON CONFLICT(id) DO UPDATE SET
                status = excluded.status,
                output = excluded.output,
                error = excluded.error,
                execution_time = excluded.execution_time,
                memory_usage = excluded.memory_usage,
                updated_at = excluded.updated_at
            "#,
            entity.id,
            entity.problem_id,
            entity.test_case_id,
            entity.status,
            entity.output,
            entity.error,
            entity.execution_time,
            entity.memory_usage,
            entity.created_at,
            entity.updated_at
        )
        .execute(self.base.pool())
        .await?;
        
        Ok(())
    }
}
```

#### 2.2 マイグレーション管理
```rust
// migrations/001_initial_schema.sql
CREATE TABLE IF NOT EXISTS test_results (
    id TEXT PRIMARY KEY,
    problem_id TEXT NOT NULL,
    test_case_id TEXT NOT NULL,
    status TEXT NOT NULL,
    output TEXT NOT NULL,
    error TEXT,
    execution_time INTEGER NOT NULL,
    memory_usage INTEGER NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX idx_test_results_problem_id ON test_results(problem_id);
CREATE INDEX idx_test_results_created_at ON test_results(created_at);

// src/infrastructure/persistence/migrations.rs
pub struct MigrationManager {
    pool: SqlitePool,
}

impl MigrationManager {
    pub async fn run_migrations(&self) -> Result<()> {
        sqlx::migrate!("./migrations")
            .run(&self.pool)
            .await
            .map_err(|e| PersistenceError::MigrationFailed(e.to_string()))?;
        
        Ok(())
    }
    
    pub async fn rollback_last(&self) -> Result<()> {
        // ロールバック実装
    }
}
```

### Phase 3: ファイルシステム実装（優先度: 中）

#### 3.1 ファイルベースリポジトリ
```rust
// src/infrastructure/persistence/file/mod.rs
use tokio::fs;
use std::path::{Path, PathBuf};

pub struct FileRepository<T> {
    base_path: PathBuf,
    _phantom: PhantomData<T>,
}

impl<T> FileRepository<T> 
where
    T: Serialize + DeserializeOwned + Entity<ID = String>,
{
    pub fn new(base_path: impl AsRef<Path>) -> Self {
        Self {
            base_path: base_path.as_ref().to_path_buf(),
            _phantom: PhantomData,
        }
    }
    
    fn entity_path(&self, id: &str) -> PathBuf {
        self.base_path.join(format!("{}.json", id))
    }
}

#[async_trait]
impl<T> Repository<T, String> for FileRepository<T>
where
    T: Serialize + DeserializeOwned + Entity<ID = String> + Send + Sync,
{
    type Error = FileError;
    
    async fn find_by_id(&self, id: &String) -> Result<Option<T>, Self::Error> {
        let path = self.entity_path(id);
        
        if !path.exists() {
            return Ok(None);
        }
        
        let content = fs::read_to_string(&path).await?;
        let entity: T = serde_json::from_str(&content)?;
        
        Ok(Some(entity))
    }
    
    async fn save(&self, entity: &T) -> Result<(), Self::Error> {
        let path = self.entity_path(entity.id());
        let content = serde_json::to_string_pretty(entity)?;
        
        // 親ディレクトリを作成
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).await?;
        }
        
        // アトミックな書き込み
        let temp_path = path.with_extension("tmp");
        fs::write(&temp_path, content).await?;
        fs::rename(&temp_path, &path).await?;
        
        Ok(())
    }
    
    async fn find_all(&self) -> Result<Vec<T>, Self::Error> {
        let mut entities = Vec::new();
        let mut entries = fs::read_dir(&self.base_path).await?;
        
        while let Some(entry) = entries.next_entry().await? {
            if entry.path().extension() == Some(OsStr::new("json")) {
                let content = fs::read_to_string(entry.path()).await?;
                if let Ok(entity) = serde_json::from_str::<T>(&content) {
                    entities.push(entity);
                }
            }
        }
        
        Ok(entities)
    }
}
```

### Phase 4: キャッシュ層の実装（優先度: 中）

#### 4.1 キャッシュリポジトリ
```rust
// src/infrastructure/persistence/cache/mod.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use lru::LruCache;

pub struct CachedRepository<T, R> {
    inner: R,
    cache: Arc<RwLock<LruCache<String, T>>>,
    ttl: Duration,
}

impl<T, R> CachedRepository<T, R>
where
    T: Clone + Send + Sync,
    R: Repository<T, String>,
{
    pub fn new(inner: R, capacity: usize, ttl: Duration) -> Self {
        Self {
            inner,
            cache: Arc::new(RwLock::new(LruCache::new(capacity))),
            ttl,
        }
    }
}

#[async_trait]
impl<T, R> Repository<T, String> for CachedRepository<T, R>
where
    T: Clone + Send + Sync + 'static,
    R: Repository<T, String> + Send + Sync,
{
    type Error = R::Error;
    
    async fn find_by_id(&self, id: &String) -> Result<Option<T>, Self::Error> {
        // キャッシュチェック
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.peek(id) {
                return Ok(Some(cached.clone()));
            }
        }
        
        // キャッシュミスの場合、内部リポジトリから取得
        let result = self.inner.find_by_id(id).await?;
        
        if let Some(ref entity) = result {
            let mut cache = self.cache.write().await;
            cache.put(id.clone(), entity.clone());
        }
        
        Ok(result)
    }
    
    async fn save(&self, entity: &T) -> Result<(), Self::Error> {
        self.inner.save(entity).await?;
        
        // キャッシュを更新
        let mut cache = self.cache.write().await;
        cache.put(entity.id().clone(), entity.clone());
        
        Ok(())
    }
    
    async fn delete(&self, id: &String) -> Result<bool, Self::Error> {
        let result = self.inner.delete(id).await?;
        
        if result {
            let mut cache = self.cache.write().await;
            cache.pop(id);
        }
        
        Ok(result)
    }
}
```

### Phase 5: Unit of Workパターン（優先度: 低）

#### 5.1 UnitOfWork実装
```rust
// src/application/unit_of_work.rs
pub struct UnitOfWork {
    test_results: Arc<dyn Repository<TestResult, String>>,
    problems: Arc<dyn Repository<Problem, String>>,
    submissions: Arc<dyn Repository<Submission, String>>,
    transaction: Option<SqliteTransaction>,
}

impl UnitOfWork {
    pub fn new(
        test_results: Arc<dyn Repository<TestResult, String>>,
        problems: Arc<dyn Repository<Problem, String>>,
        submissions: Arc<dyn Repository<Submission, String>>,
    ) -> Self {
        Self {
            test_results,
            problems,
            submissions,
            transaction: None,
        }
    }
    
    pub async fn begin(&mut self) -> Result<()> {
        // トランザクション開始
        Ok(())
    }
    
    pub async fn commit(&mut self) -> Result<()> {
        if let Some(tx) = self.transaction.take() {
            tx.commit().await?;
        }
        Ok(())
    }
    
    pub async fn rollback(&mut self) -> Result<()> {
        if let Some(tx) = self.transaction.take() {
            tx.rollback().await?;
        }
        Ok(())
    }
    
    pub fn test_results(&self) -> &Arc<dyn Repository<TestResult, String>> {
        &self.test_results
    }
}
```

## 実装上の考慮事項

### 1. パフォーマンス最適化
- コネクションプーリングの活用
- バッチ処理の実装
- 適切なインデックスの設計
- N+1問題の回避

### 2. データ整合性
- トランザクション管理の徹底
- 楽観的ロックの実装
- 一意性制約の適用
- カスケード削除の制御

### 3. 拡張性の確保
- 新しいストレージバックエンドの追加容易性
- クエリビルダーの抽象化
- カスタムマッピングのサポート
- イベントソーシングへの対応準備

## 期待される効果

1. **データアクセスの統一**
   - 一貫したAPIでのデータ操作
   - ストレージの詳細の隠蔽
   - テストの容易化

2. **パフォーマンス向上**
   - 効率的なクエリの実行
   - キャッシュによる高速化
   - バッチ処理の最適化

3. **保守性向上**
   - 明確な責任分離
   - 変更の局所化
   - エラーハンドリングの一元化

## リスクと対策

### リスク
- 既存データとの互換性問題
- マイグレーションの複雑性
- パフォーマンスの劣化可能性

### 対策
- 段階的なマイグレーション戦略
- 包括的なベンチマークテスト
- ロールバック計画の準備
- データ検証ツールの開発

## 実装優先順位

1. **即座に実装すべき項目**
   - リポジトリトレイトの定義
   - 基本的なSQLite実装
   - テスト結果エンティティの永続化

2. **短期的に実装すべき項目**
   - ファイルシステムリポジトリ
   - 基本的なキャッシュ層
   - マイグレーション管理

3. **中長期的に検討する項目**
   - Unit of Workパターン
   - イベントソーシング対応
   - 分散トランザクション対応