# 依存性注入システムの導入計画

## 1. 現状分析

### 1.1 問題点
- **依存関係の密結合**: 副作用とビジネスロジックが混在
- **テストの困難性**: モックの注入が複雑
- **拡張性の制限**: 新しいプロバイダーの追加が困難
- **CLAUDE.md違反**: 副作用がinfrastructure層以外に散在

### 1.2 目標
- すべての副作用をinfrastructure層に集約
- main.rsからの依存性注入を実現
- テスタビリティの向上
- 中長期的な拡張性の確保

## 2. 設計方針

### 2.1 DIコンテナの選定
Rustにおける主要なDIフレームワークの比較：

| フレームワーク | 利点 | 欠点 | 推奨度 |
|---------------|------|------|--------|
| 手動DI | シンプル、型安全 | ボイラープレート多い | ★★★★☆ |
| shaku | 自動解決、マクロ支援 | 学習コスト高い | ★★★☆☆ |
| dependency-injection | 軽量 | 機能限定的 | ★★☆☆☆ |

**推奨**: 手動DIから開始し、必要に応じてshakuへ移行

### 2.2 アーキテクチャ設計

```rust
// src/infrastructure/di_container.rs
pub struct DiContainer {
    docker_provider: Arc<dyn DockerProvider>,
    file_system_provider: Arc<dyn FileSystemProvider>,
    shell_provider: Arc<dyn ShellProvider>,
    database_provider: Arc<dyn DatabaseProvider>,
}

impl DiContainer {
    pub fn new(config: AppConfig) -> Self {
        // 実装の選択と初期化
        let docker_provider = match config.docker_type {
            DockerType::Native => Arc::new(NativeDockerProvider::new()),
            DockerType::Mock => Arc::new(MockDockerProvider::new()),
        };
        
        // 他のプロバイダーも同様に初期化
        Self {
            docker_provider,
            // ...
        }
    }
}
```

## 3. 実装計画

### 3.1 Phase 1: インターフェース定義（1週間）

#### トレイト定義
```rust
// src/domain/ports/docker_port.rs
pub trait DockerPort: Send + Sync {
    async fn run_container(&self, config: &ContainerConfig) -> Result<ContainerOutput>;
    async fn stop_container(&self, id: &str) -> Result<()>;
}

// src/domain/ports/file_system_port.rs
pub trait FileSystemPort: Send + Sync {
    async fn read_file(&self, path: &Path) -> Result<String>;
    async fn write_file(&self, path: &Path, content: &str) -> Result<()>;
}
```

#### アダプター実装
```rust
// src/infrastructure/adapters/docker_adapter.rs
pub struct DockerAdapter {
    shell: Arc<dyn ShellProvider>,
}

impl DockerPort for DockerAdapter {
    async fn run_container(&self, config: &ContainerConfig) -> Result<ContainerOutput> {
        // Dockerコマンドの実行
    }
}
```

### 3.2 Phase 2: DIコンテナ実装（2週間）

#### コンテナ構造
```rust
// src/infrastructure/container.rs
pub struct Container {
    // 基本プロバイダー
    shell: Arc<dyn ShellProvider>,
    fs: Arc<dyn FileSystemProvider>,
    
    // ドメインポート実装
    docker_port: Arc<dyn DockerPort>,
    storage_port: Arc<dyn StoragePort>,
    
    // アプリケーションサービス
    workflow_service: Arc<WorkflowService>,
    test_service: Arc<TestService>,
}

impl Container {
    pub fn build(config: AppConfig) -> Result<Self> {
        // 依存関係の解決と構築
        let shell = Arc::new(SystemShellProvider::new());
        let fs = Arc::new(StdFileSystemProvider::new());
        
        let docker_port = Arc::new(DockerAdapter::new(shell.clone()));
        let storage_port = Arc::new(SqliteAdapter::new(&config.db_path)?);
        
        let workflow_service = Arc::new(WorkflowService::new(
            docker_port.clone(),
            storage_port.clone(),
        ));
        
        Ok(Self {
            shell,
            fs,
            docker_port,
            storage_port,
            workflow_service,
            // ...
        })
    }
}
```

#### main.rsでの使用
```rust
// src/main.rs
#[tokio::main]
async fn main() -> Result<()> {
    let config = AppConfig::load()?;
    let container = Container::build(config)?;
    
    let app = Application::new(container);
    app.run().await
}
```

### 3.3 Phase 3: 既存コードのリファクタリング（3-4週間）

#### 段階的移行戦略
1. **Week 1**: インフラ層の整理
   - 既存の副作用コードをinfrastructure層へ移動
   - プロバイダーインターフェースの実装

2. **Week 2**: ドメイン層の純粋化
   - ポートインターフェースの定義
   - 副作用の排除

3. **Week 3**: アプリケーション層の統合
   - サービスへのDI適用
   - ユースケースの整理

4. **Week 4**: プレゼンテーション層の接続
   - CLIハンドラーの更新
   - エラーハンドリングの統一

### 3.4 Phase 4: テスト環境の整備（1週間）

#### テスト用DIコンテナ
```rust
// tests/common/test_container.rs
pub struct TestContainer {
    mocks: MockRegistry,
}

impl TestContainer {
    pub fn new() -> Self {
        let mut mocks = MockRegistry::new();
        
        // モックの登録
        mocks.register::<dyn DockerPort>(Arc::new(MockDockerPort::new()));
        mocks.register::<dyn FileSystemPort>(Arc::new(MockFileSystemPort::new()));
        
        Self { mocks }
    }
    
    pub fn with_docker_mock<F>(&mut self, setup: F) -> &mut Self 
    where 
        F: FnOnce(&mut MockDockerPort)
    {
        // モックの設定
    }
}
```

## 4. 実装優先度

| タスク | 影響度 | 複雑度 | 優先度 |
|--------|--------|--------|--------|
| インターフェース定義 | 高 | 低 | 最高 |
| 基本DIコンテナ実装 | 高 | 中 | 高 |
| インフラ層の整理 | 高 | 中 | 高 |
| 既存コードの移行 | 中 | 高 | 中 |
| テスト環境整備 | 中 | 低 | 中 |

## 5. 成功指標

- すべての副作用がinfrastructure層に集約される
- main.rsが10行以内のシンプルな構造になる
- モックを使用したテストが50%増加
- 新機能追加時の実装時間が30%短縮

## 6. リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| 過度な抽象化 | 高 | YAGNI原則の徹底 |
| パフォーマンス低下 | 中 | ベンチマークの継続実施 |
| 移行期の不安定性 | 高 | 段階的移行と十分なテスト |

## 7. 移行チェックリスト

- [ ] すべてのトレイトがSend + Syncを実装
- [ ] 循環依存が存在しない
- [ ] モックが簡単に作成できる
- [ ] エラーハンドリングが統一されている
- [ ] ライフタイムの問題が解決されている