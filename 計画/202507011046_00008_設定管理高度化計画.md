# 設定管理高度化計画

## 概要
old_srcの階層的設定管理システムを現在のRustプロジェクトに統合し、柔軟で保守性の高い設定管理を実現する。

## 背景と目的
### old_srcの分析結果
- `config/` および `configuration/`: 多層的な設定管理
  - システム設定ローダー
  - 環境変数オーバーレイ
  - ランタイム設定
  - Pure functional な設定マージ機能
- Python デコレータによるリトライ設定
- 設定の検証とデフォルト値管理

### 現在のプロジェクトの状況
- `src/config/app_config.rs`: 基本的な設定構造のみ
- 環境変数の読み込みはあるが階層化なし
- 設定のオーバーライドや動的変更機能なし

## 実装方針

### 1. 階層的設定システム
```rust
// src/domain/config/layer.rs
pub enum ConfigLayer {
    Default,      // ハードコードされたデフォルト値
    System,       // システム設定ファイル (/etc/cphelper/)
    User,         // ユーザー設定ファイル (~/.config/cphelper/)
    Project,      // プロジェクト設定ファイル (./.cphelper/)
    Environment,  // 環境変数
    Runtime,      // 実行時の動的設定
}

pub struct LayeredConfig {
    layers: BTreeMap<ConfigLayer, ConfigValue>,
}
```

### 2. 設定マージ戦略
```rust
// src/domain/config/merge.rs
pub trait MergeStrategy {
    fn merge(&self, lower: ConfigValue, upper: ConfigValue) -> ConfigValue;
}

pub struct DeepMerge;  // オブジェクトの深いマージ
pub struct Replace;     // 完全置換
pub struct Append;      // 配列の追加
```

### 3. 設定スキーマと検証
```rust
// src/domain/config/schema.rs
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct AppConfig {
    #[validate(range(min = 1, max = 3600))]
    pub timeout_seconds: u64,
    
    #[validate(url)]
    pub api_endpoint: Option<String>,
    
    #[serde(default)]
    pub docker: DockerConfig,
    
    #[serde(default)]
    pub logging: LoggingConfig,
}

#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct DockerConfig {
    pub image: String,
    #[validate(range(min = 128, max = 8192))]
    pub memory_mb: u64,
    pub enable_network: bool,
}
```

### 4. 設定ソース実装
```rust
// src/infrastructure/config/sources/
pub trait ConfigSource {
    async fn load(&self) -> Result<ConfigValue, ConfigError>;
    fn layer(&self) -> ConfigLayer;
}

pub struct FileSource { path: PathBuf }
pub struct EnvSource { prefix: String }
pub struct CliSource { args: Vec<String> }
```

### 5. 動的設定リロード
```rust
// src/infrastructure/config/watcher.rs
pub struct ConfigWatcher {
    sources: Vec<Box<dyn ConfigSource>>,
    notifier: tokio::sync::watch::Sender<AppConfig>,
}

impl ConfigWatcher {
    pub async fn watch(&mut self) -> Result<(), ConfigError> {
        // ファイル変更の監視
        // 設定の再読み込みと検証
        // 変更通知の送信
    }
}
```

### 6. 設定アクセスパターン
```rust
// src/application/config/accessor.rs
pub struct ConfigAccessor {
    current: Arc<RwLock<AppConfig>>,
    watcher: ConfigWatcher,
}

impl ConfigAccessor {
    pub fn get<T>(&self, path: &str) -> Result<T, ConfigError> 
    where T: DeserializeOwned {
        // ドット記法によるネストした値へのアクセス
        // 例: "docker.memory_mb"
    }
    
    pub async fn set(&self, path: &str, value: Value) -> Result<(), ConfigError> {
        // ランタイム設定の更新
        // 検証と通知
    }
}
```

## 実装優先順位
1. 基本的な階層設定システム
2. ファイルベース設定の読み込み
3. 環境変数オーバーレイ
4. 設定検証機能
5. 動的リロードとホットリロード

## 技術的考慮事項
- config crateをベースに拡張
- serde による柔軟なシリアライゼーション
- validator crateによる設定検証
- notify crateによるファイル監視

## 期待される効果
- 開発/テスト/本番環境での設定切り替え簡易化
- 設定ミスの早期発見（検証機能）
- 設定変更時の再起動不要化
- チーム開発での設定共有改善

## 設定ファイル例
```toml
# ~/.config/cphelper/config.toml
[general]
timeout_seconds = 10
parallel_execution = true

[docker]
image = "cphelper/judge:latest"
memory_mb = 512
cpu_limit = 1.0
enable_network = false

[logging]
level = "info"
format = "json"
output = "stdout"

[languages.cpp]
compiler = "g++"
flags = ["-std=c++17", "-O2", "-Wall"]

[languages.python]
interpreter = "python3"
version = "3.9"
```

## 参考実装の特徴
old_srcの設定管理は:
- 複数ソースからの設定読み込み
- 実行時の設定オーバーライド
- デコレータによる設定の適用
- エラー時のフォールバック

これらの機能をRustの型安全性を活かしてより堅牢に実装する。