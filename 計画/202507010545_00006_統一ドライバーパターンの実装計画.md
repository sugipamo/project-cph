# 統一ドライバーパターンの実装計画

## 1. 現状分析

### 1.1 問題点（実装方針より）
- **過度な抽象化**: ドライバーインターフェースが過度に一般化
- **SOLID原則違反**: 単一責任原則と開放閉鎖原則の違反
- **設定管理の分散**: 各ドライバーで独自の設定管理
- **移行戦略の欠如**: 段階的移行が困難

### 1.2 目標
- シンプルで拡張可能なドライバーパターンの確立
- 設定管理の一元化
- テストしやすい構造の実現
- 段階的移行を可能にする設計

## 2. 設計方針

### 2.1 ドライバーアーキテクチャ

```rust
// src/infrastructure/drivers/mod.rs
pub trait Driver: Send + Sync {
    type Config;
    type Output;
    type Error: std::error::Error;
    
    fn new(config: Self::Config) -> Result<Self, Self::Error>
    where Self: Sized;
    
    async fn execute(&self, command: &str) -> Result<Self::Output, Self::Error>;
}

// 具体的なドライバートレイト
pub trait ShellDriver: Driver<Config = ShellConfig, Output = ShellOutput, Error = ShellError> {
    async fn run_command(&self, cmd: &str, args: &[&str]) -> Result<ShellOutput, ShellError>;
    async fn run_with_timeout(&self, cmd: &str, timeout: Duration) -> Result<ShellOutput, ShellError>;
}

pub trait DockerDriver: Driver<Config = DockerConfig, Output = ContainerOutput, Error = DockerError> {
    async fn run_container(&self, image: &str, cmd: &str) -> Result<ContainerOutput, DockerError>;
    async fn build_image(&self, dockerfile: &Path) -> Result<String, DockerError>;
}
```

### 2.2 統一設定管理

```rust
// src/infrastructure/config/driver_config.rs
#[derive(Debug, Clone, Deserialize)]
pub struct DriverConfigs {
    pub shell: ShellConfig,
    pub docker: DockerConfig,
    pub file_system: FileSystemConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ShellConfig {
    pub default_timeout: u64,
    pub max_retries: u32,
    pub shell_type: ShellType,
}

impl Default for ShellConfig {
    fn default() -> Self {
        Self {
            default_timeout: 30000,
            max_retries: 3,
            shell_type: ShellType::System,
        }
    }
}
```

## 3. 実装計画

### 3.1 Phase 1: 基本ドライバーの実装（1週間）

#### ShellDriverの実装
```rust
// src/infrastructure/drivers/shell/system_shell.rs
pub struct SystemShellDriver {
    config: ShellConfig,
}

impl ShellDriver for SystemShellDriver {
    async fn run_command(&self, cmd: &str, args: &[&str]) -> Result<ShellOutput, ShellError> {
        let mut command = Command::new(cmd);
        command.args(args);
        
        let output = command
            .output()
            .await
            .map_err(|e| ShellError::ExecutionFailed(e.to_string()))?;
            
        Ok(ShellOutput {
            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
            exit_code: output.status.code().unwrap_or(-1),
        })
    }
}
```

#### MockShellDriverの実装
```rust
// src/infrastructure/drivers/shell/mock_shell.rs
pub struct MockShellDriver {
    expectations: Vec<CommandExpectation>,
}

impl MockShellDriver {
    pub fn expect_command(&mut self, cmd: &str) -> &mut CommandExpectation {
        let expectation = CommandExpectation::new(cmd);
        self.expectations.push(expectation);
        self.expectations.last_mut().unwrap()
    }
}
```

### 3.2 Phase 2: DockerDriverの実装（2週間）

#### DockerDriver実装
```rust
// src/infrastructure/drivers/docker/native_docker.rs
pub struct NativeDockerDriver {
    shell: Arc<dyn ShellDriver>,
    config: DockerConfig,
}

impl DockerDriver for NativeDockerDriver {
    async fn run_container(&self, image: &str, cmd: &str) -> Result<ContainerOutput, DockerError> {
        let args = vec![
            "run",
            "--rm",
            &format!("--memory={}", self.config.memory_limit),
            &format!("--cpus={}", self.config.cpu_limit),
            image,
            cmd,
        ];
        
        let output = self.shell
            .run_command("docker", &args)
            .await
            .map_err(|e| DockerError::CommandFailed(e.to_string()))?;
            
        Ok(ContainerOutput::from(output))
    }
}
```

### 3.3 Phase 3: ドライバーファクトリーの実装（1週間）

```rust
// src/infrastructure/drivers/factory.rs
pub struct DriverFactory {
    config: DriverConfigs,
}

impl DriverFactory {
    pub fn new(config: DriverConfigs) -> Self {
        Self { config }
    }
    
    pub fn create_shell_driver(&self) -> Arc<dyn ShellDriver> {
        match self.config.shell.shell_type {
            ShellType::System => Arc::new(SystemShellDriver::new(self.config.shell.clone())),
            ShellType::Mock => Arc::new(MockShellDriver::new(self.config.shell.clone())),
        }
    }
    
    pub fn create_docker_driver(&self, shell: Arc<dyn ShellDriver>) -> Arc<dyn DockerDriver> {
        match self.config.docker.docker_type {
            DockerType::Native => Arc::new(NativeDockerDriver::new(shell, self.config.docker.clone())),
            DockerType::Mock => Arc::new(MockDockerDriver::new(self.config.docker.clone())),
        }
    }
}
```

### 3.4 Phase 4: 既存コードの移行（2-3週間）

#### 段階的移行戦略

1. **Week 1**: インターフェースの定義と基本実装
   ```rust
   // 旧コード
   let output = run_docker_command("python", "solution.py");
   
   // 新コード
   let docker = factory.create_docker_driver(shell.clone());
   let output = docker.run_container("python:3.9", "solution.py").await?;
   ```

2. **Week 2**: テストの移行
   ```rust
   #[test]
   async fn test_docker_execution() {
       let mut mock_docker = MockDockerDriver::new(DockerConfig::default());
       mock_docker.expect_run_container("python:3.9", "test.py")
           .returns(ContainerOutput::success("42"));
           
       let result = mock_docker.run_container("python:3.9", "test.py").await;
       assert_eq!(result.unwrap().stdout, "42");
   }
   ```

3. **Week 3**: 完全移行と旧コードの削除

## 4. 実装優先度

| タスク | 影響度 | 複雑度 | 優先度 |
|--------|--------|--------|--------|
| ShellDriver実装 | 高 | 低 | 最高 |
| DockerDriver実装 | 高 | 中 | 高 |
| ドライバーファクトリー | 中 | 低 | 中 |
| 既存コード移行 | 高 | 高 | 中 |
| FileSystemDriver実装 | 中 | 低 | 低 |

## 5. 成功指標

- ドライバーインターフェースの統一化
- モック作成時間が50%削減
- テストの実行速度が30%向上
- 新ドライバー追加が1日以内で可能

## 6. リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| 既存機能の破壊 | 高 | 十分なテストカバレッジ確保 |
| パフォーマンス劣化 | 中 | ベンチマークによる継続監視 |
| 過度な抽象化の再発 | 高 | KISS原則の徹底 |

## 7. ベストプラクティス

1. **インターフェース設計**
   - 最小限のメソッドで構成
   - 単一責任の原則を遵守
   - エラー型は具体的に定義

2. **設定管理**
   - すべてのドライバー設定を一元管理
   - デフォルト値を明確に定義
   - 環境変数での上書きをサポート

3. **テスト戦略**
   - 各ドライバーに対応するモック実装
   - 統合テストでの実ドライバー使用
   - パフォーマンステストの自動化