# ワークフロー実行システム導入計画

## 概要
old_srcの高度なワークフロー実行システムを、現在のRustプロジェクトに導入し、複雑なテスト実行やビルドプロセスを効率化する計画。

## 現状分析
### 現在のRustプロジェクト
- 単純な逐次実行
- テストケースの個別実行
- 並列処理の限定的なサポート

### old_srcのワークフロー実行システム
- ステップベースの実行モデル
- 依存関係の管理
- 並列/逐次実行の柔軟な制御
- コンポジットリクエストパターン
- 実行履歴の追跡

## 移行によるメリット
1. **実行効率の向上**
   - 並列実行による高速化
   - 依存関係に基づく最適な実行順序

2. **複雑なワークフローのサポート**
   - ビルド→テスト→提出の自動化
   - 条件分岐を含むワークフロー

3. **再現性の向上**
   - 実行履歴の記録
   - 失敗時の再実行

## 実装方針
1. **ステップ定義**
   ```rust
   trait Step {
       fn execute(&self, context: &Context) -> StepResult;
       fn dependencies(&self) -> Vec<StepId>;
   }
   ```

2. **ワークフロー実行エンジン**
   - DAG（有向非巡回グラフ）による依存関係管理
   - 並列実行スケジューラー

3. **実行コンテキスト**
   - ステップ間のデータ共有
   - 状態管理

## 技術的考察
### Rustでの並列処理
- `tokio`による非同期実行
- `rayon`による並列処理
- チャネルによるステップ間通信

### 競技プログラミング特有の要件
1. **テストケース並列実行**
   - 複数のテストケースを同時実行
   - メモリ/CPU制限の管理

2. **ビルドキャッシュ**
   - 変更がない場合の再ビルド回避

3. **タイムアウト管理**
   - テストケースごとの実行時間制限

## 実装優先度
**中〜高**：大規模なテストスイートを扱う場合に特に有効

## 想定される課題
1. 並列実行時のリソース競合
2. デバッグの複雑性
3. エラーハンドリングの難しさ

## 具体的なユースケース
### 1. コンテスト問題の一括テスト
```yaml
workflow:
  - step: compile
    command: "g++ -O2 solution.cpp"
  - step: test_samples
    depends_on: [compile]
    parallel: true
    commands:
      - "./a.out < sample1.in"
      - "./a.out < sample2.in"
  - step: test_hidden
    depends_on: [compile]
    parallel: true
    commands:
      - "./a.out < hidden1.in"
      - "./a.out < hidden2.in"
```

### 2. 多言語サポート
- 同じ問題を複数言語で実装している場合の並列テスト

### 3. ストレステスト
- ランダムテストケース生成と実行の自動化

## 実装段階
1. **Phase 1: 基本的なワークフロー実行**
   - 逐次実行のサポート
   - 簡単な依存関係管理

2. **Phase 2: 並列実行**
   - 並列実行エンジン
   - リソース管理

3. **Phase 3: 高度な機能**
   - 条件分岐
   - 動的ワークフロー生成

## 次のステップ
1. 現在のテスト実行フローの分析
2. ワークフローエンジンの設計
3. プロトタイプ実装