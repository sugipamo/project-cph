diff --git a/src/contest/error.rs b/src/contest/error.rs
index a66f8c1..1236a39 100644
--- a/src/contest/error.rs
+++ b/src/contest/error.rs
@@ -1,14 +1,13 @@
-use std::error::Error;
-use crate::error::{CphError, ContestError};
+use crate::error::{CphError, ContestError, ConfigError, LanguageError};
 
-pub fn site_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Contest(ContestError::Site(msg)))
+pub fn site_err(msg: String) -> CphError {
+    CphError::Contest(ContestError::Site { message: msg })
 }
 
-pub fn language_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Contest(ContestError::Language(msg)))
+pub fn language_err(msg: String) -> CphError {
+    CphError::Contest(ContestError::Language(LanguageError::Config { message: msg }))
 }
 
-pub fn config_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Contest(ContestError::Config(msg)))
+pub fn config_err(msg: String) -> CphError {
+    CphError::Contest(ContestError::Config(ConfigError::NotFound { path: msg }))
 }
diff --git a/src/docker/error.rs b/src/docker/error.rs
index e134810..af675e5 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,22 +1,21 @@
-use std::error::Error;
-use crate::error::CphError;
+use crate::error::{CphError, DockerError};
 
-pub fn docker_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Docker(msg))
+pub fn docker_err(msg: String) -> CphError {
+    CphError::Docker(DockerError::ExecutionFailed { message: msg })
 }
 
-pub fn container_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Docker(format!("コンテナエラー: {}", msg)))
+pub fn container_err(msg: String) -> CphError {
+    CphError::Docker(DockerError::ExecutionFailed { message: msg })
 }
 
-pub fn compilation_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Docker(format!("コンパイルエラー: {}", msg)))
+pub fn compilation_err(msg: String) -> CphError {
+    CphError::Docker(DockerError::ExecutionFailed { message: msg })
 }
 
-pub fn command_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Docker(format!("コマンドエラー: {}", msg)))
+pub fn command_err(msg: String) -> CphError {
+    CphError::Docker(DockerError::ExecutionFailed { message: msg })
 }
 
-pub fn state_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Docker(format!("状態エラー: {}", msg)))
+pub fn state_err(msg: String) -> CphError {
+    CphError::Docker(DockerError::ExecutionFailed { message: msg })
 } 
\ No newline at end of file
diff --git a/src/error.rs b/src/error.rs
index 939319f..c8e581a 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -5,42 +5,90 @@ use thiserror::Error;
 pub const NO_ACTIVE_CONTEST: &str = "アクティブなコンテストがありません。'work'コマンドで設定してください。";
 
 #[derive(Debug, Error)]
-pub enum ContestError {
-    #[error("設定エラー: {0}")]
-    Config(String),
-    
-    #[error("ファイルシステムエラー: {0}")]
-    FileSystem(String),
+pub enum ConfigError {
+    #[error("設定ファイルが見つかりません: {path}")]
+    NotFound { path: String },
     
-    #[error("言語エラー: {0}")]
-    Language(String),
+    #[error("設定ファイルの解析に失敗しました: {0}")]
+    Parse(#[from] serde_yaml::Error),
     
-    #[error("サイトエラー: {0}")]
-    Site(String),
+    #[error("無効な設定値: {field} - {message}")]
+    InvalidValue { field: String, message: String },
 }
 
 #[derive(Debug, Error)]
-pub enum CphError {
+pub enum FileSystemError {
+    #[error("ファイルが見つかりません: {path}")]
+    NotFound { path: String },
+    
+    #[error("アクセス権限がありません: {path}")]
+    Permission { path: String },
+    
     #[error("IOエラー: {0}")]
     Io(#[from] io::Error),
-
-    #[error("YAMLエラー: {0}")]
-    Yaml(#[from] serde_yaml::Error),
-
+    
     #[error("パスエラー: {0}")]
     Path(#[from] StripPrefixError),
+}
 
-    #[error("{0}")]
-    Contest(#[from] ContestError),
+#[derive(Debug, Error)]
+pub enum LanguageError {
+    #[error("サポートされていない言語です: {lang}")]
+    Unsupported { lang: String },
+    
+    #[error("コンパイラが見つかりません: {compiler}")]
+    CompilerNotFound { compiler: String },
+    
+    #[error("言語設定エラー: {message}")]
+    Config { message: String },
+}
 
-    #[error("Dockerエラー: {0}")]
-    Docker(String),
+#[derive(Debug, Error)]
+pub enum DockerError {
+    #[error("Dockerデーモンに接続できません")]
+    ConnectionFailed,
+    
+    #[error("イメージのビルドに失敗しました: {image}")]
+    BuildFailed { image: String },
+    
+    #[error("コンテナの実行に失敗しました: {message}")]
+    ExecutionFailed { message: String },
+    
+    #[error("ファイルシステムエラー: {0}")]
+    Fs(#[from] FileSystemError),
+}
 
+#[derive(Debug, Error)]
+pub enum ContestError {
+    #[error("設定エラー: {0}")]
+    Config(#[from] ConfigError),
+    
     #[error("ファイルシステムエラー: {0}")]
-    Fs(String),
+    FileSystem(#[from] FileSystemError),
+    
+    #[error("言語エラー: {0}")]
+    Language(#[from] LanguageError),
+    
+    #[error("サイトエラー: {message}")]
+    Site { message: String },
+}
 
+#[derive(Debug, Error)]
+pub enum CphError {
+    #[error("{0}")]
+    Contest(#[from] ContestError),
+    
     #[error("{0}")]
-    Message(String),
+    Docker(#[from] DockerError),
+    
+    #[error("{0}")]
+    Config(#[from] ConfigError),
+    
+    #[error("{0}")]
+    Fs(#[from] FileSystemError),
+    
+    #[error("{message}")]
+    Other { message: String },
 }
 
-pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>; 
\ No newline at end of file
+pub type Result<T> = std::result::Result<T, CphError>; 
\ No newline at end of file
diff --git a/src/fs/docker.rs b/src/fs/docker.rs
index 28ff6f5..90c3702 100644
--- a/src/fs/docker.rs
+++ b/src/fs/docker.rs
@@ -1,6 +1,6 @@
 use std::path::Path;
 use std::os::unix::fs::PermissionsExt;
-use crate::error::Result;
+use crate::error::{CphError, FileSystemError, Result};
 use nix::unistd::{Uid, Gid};
 
 pub trait DockerFileOperations {
@@ -9,18 +9,17 @@ pub trait DockerFileOperations {
     fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf>;
 }
 
-/// Docker環境でのファイル操作のデフォルト実装
 pub trait DefaultDockerFileOperations: DockerFileOperations {
-    /// ディレクトリの権限を確認・設定
     fn ensure_directory_permissions(&self, dir: &Path) -> Result<()> {
-        let metadata = std::fs::metadata(dir)?;
+        let metadata = std::fs::metadata(dir)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
         let mut perms = metadata.permissions();
         perms.set_mode(0o777);
-        std::fs::set_permissions(dir, perms)?;
+        std::fs::set_permissions(dir, perms)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
         Ok(())
     }
 
-    /// 現在のユーザーIDとグループIDを取得
     fn get_current_user_ids(&self) -> (Uid, Gid) {
         let uid = Uid::from_raw(std::process::id() as u32);
         let gid = Gid::from_raw(unsafe { libc::getgid() } as u32);
@@ -28,6 +27,20 @@ pub trait DefaultDockerFileOperations: DockerFileOperations {
     }
 }
 
+pub fn set_docker_dir_permissions<P: AsRef<Path>>(dir: P) -> Result<()> {
+    let dir = dir.as_ref();
+
+    let metadata = std::fs::metadata(dir)
+        .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
+
+    let mut perms = metadata.permissions();
+    perms.set_mode(0o777);
+    std::fs::set_permissions(dir, perms)
+        .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
+
+    Ok(())
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -52,24 +65,19 @@ mod tests {
         }
 
         fn set_permissions<P: AsRef<Path>>(&self, path: P, _mode: u32) -> Result<()> {
-            if path.exists() {
-                Ok(())
-            } else {
-                Err("Path does not exist".into())
-            }
-        }
-
-        fn set_ownership(&self, path: &Path, _uid: Option<Uid>, _gid: Option<Gid>) -> Result<()> {
-            if path.exists() {
+            if path.as_ref().exists() {
                 Ok(())
             } else {
-                Err("Path does not exist".into())
+                Err(CphError::Fs(FileSystemError::NotFound {
+                    path: path.as_ref().to_string_lossy().to_string()
+                }))
             }
         }
 
         fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf> {
-            let file_path = dir.join(filename);
-            fs::write(&file_path, content)?;
+            let file_path = dir.as_ref().join(filename);
+            fs::write(&file_path, content)
+                .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
             Ok(file_path)
         }
     }
@@ -77,23 +85,40 @@ mod tests {
     impl DefaultDockerFileOperations for MockDockerFileOps {}
 
     #[test]
-    fn test_mock_docker_file_ops() {
+    fn test_mock_docker_file_ops() -> Result<()> {
         let ops = MockDockerFileOps::new();
         
         // テスト一時ディレクトリの作成
-        let temp_dir = ops.create_temp_directory().unwrap();
+        let temp_dir = ops.create_temp_directory()?;
         assert!(temp_dir.exists());
 
         // ソースファイルの書き込み
-        let file_path = ops.write_source_file(&temp_dir, "test.txt", "test content").unwrap();
+        let file_path = ops.write_source_file(&temp_dir, "test.txt", "test content")?;
         assert!(file_path.exists());
-        assert_eq!(fs::read_to_string(file_path).unwrap(), "test content");
+        assert_eq!(fs::read_to_string(&file_path)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?, "test content");
 
         // 権限設定
-        assert!(ops.set_permissions(&temp_dir, 0o777).is_ok());
+        ops.set_permissions(&temp_dir, 0o777)?;
 
-        // 所有者設定
-        let (uid, gid) = ops.get_current_user_ids();
-        assert!(ops.set_ownership(&temp_dir, Some(uid), Some(gid)).is_ok());
+        Ok(())
+    }
+
+    #[test]
+    fn test_set_docker_dir_permissions() -> Result<()> {
+        let temp_dir = TempDir::new()
+            .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                format!("一時ディレクトリの作成に失敗しました: {}", e),
+            ))))?;
+
+        set_docker_dir_permissions(temp_dir.path())?;
+
+        let metadata = fs::metadata(temp_dir.path())
+            .map_err(|e| CphError::Fs(FileSystemError::Io(e)))?;
+        let mode = metadata.permissions().mode();
+        assert_eq!(mode & 0o777, 0o777);
+
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/fs/error.rs b/src/fs/error.rs
index 4d9ce2b..e71190b 100644
--- a/src/fs/error.rs
+++ b/src/fs/error.rs
@@ -1,10 +1,12 @@
-use std::error::Error;
-use crate::error::CphError;
+use crate::error::{CphError, FileSystemError};
 
-pub fn fs_err(msg: String) -> Box<dyn Error> {
-    Box::new(CphError::Fs(msg))
+pub fn fs_err(msg: String) -> CphError {
+    CphError::Fs(FileSystemError::NotFound { path: msg })
 }
 
-pub fn fs_err_with_source<E: std::error::Error>(msg: &str, source: E) -> Box<dyn Error> {
-    Box::new(CphError::Fs(format!("{}: {}", msg, source)))
+pub fn fs_err_with_source(msg: &str, source: impl std::error::Error) -> CphError {
+    CphError::Fs(FileSystemError::Io(std::io::Error::new(
+        std::io::ErrorKind::Other,
+        format!("{}: {}", msg, source),
+    )))
 } 
\ No newline at end of file
diff --git a/src/fs/manager.rs b/src/fs/manager.rs
index 38b1d1f..233787b 100644
--- a/src/fs/manager.rs
+++ b/src/fs/manager.rs
@@ -1,67 +1,62 @@
-use std::path::{Path, PathBuf};
-use crate::error::Result;
-use super::error::{fs_err, fs_err_with_source};
-use super::{FileOperationBuilder, FileTransaction};
+use std::path::PathBuf;
+use crate::error::{CphError, FileSystemError, Result};
 
 pub struct FileManager {
-    builder: FileOperationBuilder,
+    root: PathBuf,
 }
 
 impl FileManager {
-    pub fn new() -> Result<Self> {
-        Ok(Self {
-            builder: FileOperationBuilder::new(),
-        })
-    }
-
-    pub fn create_directory<P: AsRef<Path>>(&self, path: P) -> Result<()> {
-        let operation = self.builder.create_dir(path);
-        let mut transaction = FileTransaction::new(vec![operation]);
-        transaction.execute()
-    }
-
-    pub fn copy_file<P: AsRef<Path>>(&self, from: P, to: P) -> Result<()> {
-        let operation = self.builder.copy(from, to);
-        let mut transaction = FileTransaction::new(vec![operation]);
-        transaction.execute()
-    }
-
-    pub fn move_file<P: AsRef<Path>>(&self, from: P, to: P) -> Result<()> {
-        let copy_operation = self.builder.copy(from.as_ref(), to.as_ref());
-        let remove_operation = self.builder.remove(from);
-        let mut transaction = FileTransaction::new(vec![copy_operation, remove_operation]);
-        transaction.execute()
-    }
+    pub fn new(root: PathBuf) -> Self {
+        Self { root }
+    }
+
+    pub fn create_dir(&self, path: &str) -> Result<PathBuf> {
+        let full_path = self.root.join(path);
+        std::fs::create_dir_all(&full_path)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                format!("ディレクトリの作成に失敗しました: {}", e),
+            ))))?;
+        Ok(full_path)
+    }
+
+    pub fn write_file(&self, path: &str, content: &str) -> Result<PathBuf> {
+        let full_path = self.root.join(path);
+        if let Some(parent) = full_path.parent() {
+            std::fs::create_dir_all(parent)
+                .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    format!("ディレクトリの作成に失敗しました: {}", e),
+                ))))?;
+        }
+        std::fs::write(&full_path, content)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                format!("ファイルの書き込みに失敗しました: {}", e),
+            ))))?;
+        Ok(full_path)
+    }
+
+    pub fn set_permissions(&self, path: &str, mode: u32) -> Result<()> {
+        let full_path = self.root.join(path);
+        let metadata = std::fs::metadata(&full_path)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                format!("メタデータの取得に失敗しました: {}", e),
+            ))))?;
 
-    pub fn delete_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
-        let operation = self.builder.remove(path);
-        let mut transaction = FileTransaction::new(vec![operation]);
-        transaction.execute()
-    }
-
-    pub fn create_temp_directory(&self) -> Result<PathBuf> {
-        let temp_dir = tempfile::TempDir::new()
-            .map_err(|e| fs_err_with_source("一時ディレクトリの作成に失敗しました", e))?;
-        let path = temp_dir.path().to_path_buf();
-        Ok(path)
-    }
-
-    pub fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<PathBuf> {
-        let path = dir.as_ref().join(filename);
-        std::fs::write(&path, content)
-            .map_err(|e| fs_err_with_source("ソースファイルの書き込みに失敗しました", e))?;
-        Ok(path)
-    }
-
-    pub fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()> {
-        use std::os::unix::fs::PermissionsExt;
-        let path = path.as_ref();
-        let metadata = std::fs::metadata(path)
-            .map_err(|e| fs_err(format!("メタデータの取得に失敗しました: {}", e)))?;
         let mut perms = metadata.permissions();
-        perms.set_mode(mode);
-        std::fs::set_permissions(path, perms)
-            .map_err(|e| fs_err(format!("権限の設定に失敗しました: {}", e)))?;
+        #[cfg(unix)]
+        {
+            use std::os::unix::fs::PermissionsExt;
+            perms.set_mode(mode);
+        }
+        std::fs::set_permissions(&full_path, perms)
+            .map_err(|e| CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                format!("権限の設定に失敗しました: {}", e),
+            ))))?;
+
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/fs/mod.rs b/src/fs/mod.rs
index 5b60684..c781ea9 100644
--- a/src/fs/mod.rs
+++ b/src/fs/mod.rs
@@ -1,13 +1,13 @@
 mod backup;
-mod operations;
-mod transaction;
-mod manager;
 mod docker;
 mod error;
+mod manager;
+mod operations;
+mod transaction;
 
 pub use backup::BackupManager;
-pub use operations::{CopyOperation, CreateDirOperation, RemoveOperation, FileOperationBuilder};
-pub use transaction::{FileTransaction, FileOperation, TransactionState};
+pub use docker::set_docker_dir_permissions;
+pub use error::{fs_err, fs_err_with_source};
 pub use manager::FileManager;
-pub use docker::{DockerFileOperations, DefaultDockerFileOperations};
-pub use crate::error::Result; 
\ No newline at end of file
+pub use operations::{Copy, Create, Remove};
+pub use transaction::{FileOperation, Transaction}; 
\ No newline at end of file
diff --git a/src/fs/operations.rs b/src/fs/operations.rs
index 4a10640..dd91ddb 100644
--- a/src/fs/operations.rs
+++ b/src/fs/operations.rs
@@ -1,132 +1,103 @@
-use std::path::{Path, PathBuf};
-use crate::error::Result;
-use super::error::{fs_err, fs_err_with_source};
-use super::transaction::FileOperation;
+use std::path::PathBuf;
+use crate::error::{CphError, FileSystemError, Result};
+use crate::fs::fs_err_with_source;
 
-pub struct FileOperationBuilder;
-
-impl FileOperationBuilder {
-    pub fn new() -> Self {
-        Self
-    }
-
-    pub fn create_dir<P: AsRef<Path>>(&self, path: P) -> Box<dyn FileOperation> {
-        Box::new(CreateDirOperation {
-            path: path.as_ref().to_path_buf(),
-        })
-    }
-
-    pub fn copy<P: AsRef<Path>>(&self, from: P, to: P) -> Box<dyn FileOperation> {
-        Box::new(CopyOperation {
-            from: from.as_ref().to_path_buf(),
-            to: to.as_ref().to_path_buf(),
-        })
-    }
-
-    pub fn remove<P: AsRef<Path>>(&self, path: P) -> Box<dyn FileOperation> {
-        Box::new(RemoveOperation {
-            path: path.as_ref().to_path_buf(),
-        })
-    }
-}
-
-#[derive(Debug)]
-pub struct CreateDirOperation {
-    path: PathBuf,
-}
-
-impl FileOperation for CreateDirOperation {
-    fn execute(&self) -> Result<()> {
-        std::fs::create_dir_all(&self.path)
-            .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))
-    }
-
-    fn rollback(&self) -> Result<()> {
-        if self.path.exists() {
-            std::fs::remove_dir_all(&self.path)
-                .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
-        } else {
-            Ok(())
-        }
-    }
-}
-
-#[derive(Debug)]
-pub struct CopyOperation {
+pub struct Copy {
     from: PathBuf,
     to: PathBuf,
 }
 
-impl FileOperation for CopyOperation {
-    fn execute(&self) -> Result<()> {
+impl Copy {
+    pub fn new(from: PathBuf, to: PathBuf) -> Self {
+        Self { from, to }
+    }
+
+    pub fn execute(&self) -> Result<()> {
         if !self.from.exists() {
-            return Err(fs_err(format!(
-                "コピー元のファイルが存在しません: {:?}",
-                self.from
-            )));
+            return Err(CphError::Fs(FileSystemError::NotFound {
+                path: format!("コピー元のファイルが存在しません: {:?}", self.from)
+            }));
         }
 
         if self.from.is_dir() {
-            fs_extra::dir::copy(
-                &self.from,
-                &self.to,
-                &fs_extra::dir::CopyOptions::new(),
-            )
-            .map_err(|e| fs_err(format!("ディレクトリのコピーに失敗しました: {}", e)))?;
+            std::fs::create_dir_all(&self.to)
+                .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))?;
+
+            for entry in std::fs::read_dir(&self.from)
+                .map_err(|e| fs_err_with_source("ディレクトリの読み取りに失敗しました", e))? {
+                let entry = entry
+                    .map_err(|e| fs_err_with_source("ファイルの読み取りに失敗しました", e))?;
+                let path = entry.path();
+                let new_path = self.to.join(path.file_name().unwrap());
+                Copy::new(path, new_path).execute()?;
+            }
         } else {
-            fs_extra::file::copy(
-                &self.from,
-                &self.to,
-                &fs_extra::file::CopyOptions::new(),
-            )
-            .map_err(|e| fs_err(format!("ファイルのコピーに失敗しました: {}", e)))?;
+            if let Some(parent) = self.to.parent() {
+                std::fs::create_dir_all(parent)
+                    .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))?;
+            }
+            std::fs::copy(&self.from, &self.to)
+                .map_err(|e| fs_err_with_source("ファイルのコピーに失敗しました", e))?;
         }
 
         Ok(())
     }
 
-    fn rollback(&self) -> Result<()> {
+    pub fn rollback(&self) -> Result<()> {
         if self.to.exists() {
             if self.to.is_dir() {
                 std::fs::remove_dir_all(&self.to)
-                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
+                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))?;
             } else {
                 std::fs::remove_file(&self.to)
-                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))
+                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))?;
             }
-        } else {
-            Ok(())
         }
+        Ok(())
     }
 }
 
-#[derive(Debug)]
-pub struct RemoveOperation {
+pub struct Remove {
     path: PathBuf,
 }
 
-impl FileOperation for RemoveOperation {
-    fn execute(&self) -> Result<()> {
+impl Remove {
+    pub fn new(path: PathBuf) -> Self {
+        Self { path }
+    }
+
+    pub fn execute(&self) -> Result<()> {
         if self.path.exists() {
             if self.path.is_dir() {
                 std::fs::remove_dir_all(&self.path)
-                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
+                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))?;
             } else {
                 std::fs::remove_file(&self.path)
-                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))
+                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))?;
             }
-        } else {
-            Ok(())
         }
+        Ok(())
     }
+}
 
-    fn rollback(&self) -> Result<()> {
-        // 削除操作のロールバックは、ファイルの復元が必要
-        // ここでは単純な実装として、空のファイルを作成
-        if !self.path.exists() {
+pub struct Create {
+    path: PathBuf,
+    is_dir: bool,
+}
+
+impl Create {
+    pub fn new(path: PathBuf, is_dir: bool) -> Self {
+        Self { path, is_dir }
+    }
+
+    pub fn execute(&self) -> Result<()> {
+        if self.is_dir {
+            std::fs::create_dir_all(&self.path)
+                .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))?;
+        } else {
             if let Some(parent) = self.path.parent() {
                 std::fs::create_dir_all(parent)
-                    .map_err(|e| fs_err_with_source("親ディレクトリの作成に失敗しました", e))?;
+                    .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))?;
             }
             std::fs::File::create(&self.path)
                 .map_err(|e| fs_err_with_source("ファイルの作成に失敗しました", e))?;
diff --git a/src/fs/transaction.rs b/src/fs/transaction.rs
index 0fd07ea..a1efd7e 100644
--- a/src/fs/transaction.rs
+++ b/src/fs/transaction.rs
@@ -1,86 +1,57 @@
-use std::fmt::Debug;
-use crate::error::Result;
-use super::error::fs_err;
+use crate::error::{CphError, FileSystemError, Result};
 
-/// ファイル操作のトランザクション状態
-#[derive(Debug, PartialEq)]
-pub enum TransactionState {
-    /// 初期状態
-    Initial,
-    /// 実行中
-    InProgress,
-    /// コミット済み
-    Committed,
-    /// ロールバック済み
-    RolledBack,
-}
-
-/// ファイル操作のトレイト
-pub trait FileOperation: Debug {
-    /// 操作を実行
+pub trait FileOperation {
     fn execute(&self) -> Result<()>;
-    /// 操作をロールバック
     fn rollback(&self) -> Result<()>;
 }
 
-/// ファイル操作のトランザクション
-#[derive(Debug)]
-pub struct FileTransaction {
-    /// 操作のリスト
+pub struct Transaction {
     operations: Vec<Box<dyn FileOperation>>,
-    /// トランザクションの状態
-    state: TransactionState,
+    executed: bool,
 }
 
-impl FileTransaction {
-    /// 新しいトランザクションを作成
-    pub fn new(operations: Vec<Box<dyn FileOperation>>) -> Self {
+impl Transaction {
+    pub fn new() -> Self {
         Self {
-            operations,
-            state: TransactionState::Initial,
+            operations: Vec::new(),
+            executed: false,
         }
     }
 
-    /// トランザクションを実行
-    pub fn execute(&mut self) -> Result<()> {
-        if self.state != TransactionState::Initial {
-            return Err(fs_err("トランザクションは既に実行されています".to_string()));
-        }
-
-        self.state = TransactionState::InProgress;
-
-        // 各操作を実行
-        for operation in &self.operations {
-            if let Err(e) = operation.execute() {
-                // エラーが発生した場合、ロールバック
-                self.rollback()?;
-                return Err(fs_err(format!("操作の実行中にエラーが発生しました: {}", e)));
-            }
-        }
-
-        self.state = TransactionState::Committed;
-        Ok(())
+    pub fn add_operation(&mut self, operation: Box<dyn FileOperation>) {
+        self.operations.push(operation);
     }
 
-    /// トランザクションをロールバック
-    pub fn rollback(&mut self) -> Result<()> {
-        if self.state != TransactionState::InProgress {
-            return Ok(());
+    pub fn execute(&mut self) -> Result<()> {
+        if self.executed {
+            return Err(CphError::Fs(FileSystemError::NotFound {
+                path: "トランザクションは既に実行されています".to_string()
+            }));
         }
 
-        // 逆順で各操作をロールバック
-        for operation in self.operations.iter().rev() {
-            if let Err(e) = operation.rollback() {
-                return Err(fs_err(format!("ロールバック中にエラーが発生しました: {}", e)));
+        let mut executed_operations = Vec::new();
+        for operation in &self.operations {
+            match operation.execute() {
+                Ok(()) => executed_operations.push(operation),
+                Err(e) => {
+                    // ロールバック
+                    for executed_operation in executed_operations.iter().rev() {
+                        if let Err(rollback_err) = executed_operation.rollback() {
+                            return Err(CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                format!("ロールバック中にエラーが発生しました: {}", rollback_err),
+                            ))));
+                        }
+                    }
+                    return Err(CphError::Fs(FileSystemError::Io(std::io::Error::new(
+                        std::io::ErrorKind::Other,
+                        format!("操作の実行中にエラーが発生しました: {}", e),
+                    ))));
+                }
             }
         }
 
-        self.state = TransactionState::RolledBack;
+        self.executed = true;
         Ok(())
     }
-
-    /// トランザクションの状態を取得
-    pub fn state(&self) -> &TransactionState {
-        &self.state
-    }
-} 
\ No newline at end of file
+} 
diff --git a/src/test/mod.rs b/src/test/mod.rs
index d662cf3..393db9c 100644
--- a/src/test/mod.rs
+++ b/src/test/mod.rs
@@ -1,39 +1,49 @@
 use std::path::PathBuf;
-use crate::error::Result;
-use crate::contest::error::config_err;
+use crate::error::{CphError, ConfigError, Result};
 
+#[derive(Debug)]
 pub struct TestCase {
     pub input: String,
     pub expected: String,
 }
 
 pub fn load_test_cases(test_dir: &PathBuf) -> Result<Vec<TestCase>> {
-    let mut test_cases = Vec::new();
-
     let entries = std::fs::read_dir(test_dir)
-        .map_err(|e| config_err(format!("テストディレクトリの読み取りに失敗しました: {}", e)))?;
+        .map_err(|e| CphError::Config(ConfigError::NotFound {
+            path: format!("テストディレクトリの読み取りに失敗しました: {}", e)
+        }))?;
+
+    let mut test_cases = Vec::new();
 
     for entry in entries {
         let entry = entry
-            .map_err(|e| config_err(format!("テストファイルの読み取りに失敗しました: {}", e)))?;
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("テストファイルの読み取りに失敗しました: {}", e)
+            }))?;
+
         let path = entry.path();
+        if !path.is_file() || !path.extension().map_or(false, |ext| ext == "in") {
+            continue;
+        }
 
-        if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-            let test_file = path.to_str()
-                .ok_or_else(|| config_err("テストファイルのパスが無効です".to_string()))?;
-            let expected_path = PathBuf::from(test_file).with_extension("out");
-            if !expected_path.exists() {
-                return Err(config_err(format!("期待値ファイルが存在しません: {:?}", expected_path)));
-            }
+        let expected_path = path.with_extension("out");
+        if !expected_path.exists() {
+            return Err(CphError::Config(ConfigError::NotFound {
+                path: format!("期待値ファイルが存在しません: {:?}", expected_path)
+            }));
+        }
 
-            let input = std::fs::read_to_string(&path)
-                .map_err(|e| config_err(format!("入力ファイルの読み取りに失敗しました: {}", e)))?;
+        let input = std::fs::read_to_string(&path)
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("入力ファイルの読み取りに失敗しました: {}", e)
+            }))?;
 
-            let expected = std::fs::read_to_string(&expected_path)
-                .map_err(|e| config_err(format!("期待値ファイルの読み取りに失敗しました: {}", e)))?;
+        let expected = std::fs::read_to_string(&expected_path)
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("期待値ファイルの読み取りに失敗しました: {}", e)
+            }))?;
 
-            test_cases.push(TestCase { input, expected });
-        }
+        test_cases.push(TestCase { input, expected });
     }
 
     Ok(test_cases)
@@ -44,18 +54,25 @@ mod tests {
     use super::*;
     use std::fs;
     use tempfile::TempDir;
+    use crate::error::{CphError, ConfigError};
 
     #[test]
     fn test_load_test_cases() -> Result<()> {
         let temp_dir = TempDir::new()
-            .map_err(|e| config_err(format!("一時ディレクトリの作成に失敗しました: {}", e)))?;
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("一時ディレクトリの作成に失敗しました: {}", e)
+            }))?;
         let test_dir = temp_dir.path().to_path_buf();
 
         // テストケースファイルの作成
         fs::write(test_dir.join("test1.in"), "input1")
-            .map_err(|e| config_err(format!("テストファイルの作成に失敗しました: {}", e)))?;
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("テストファイルの作成に失敗しました: {}", e)
+            }))?;
         fs::write(test_dir.join("test1.out"), "output1")
-            .map_err(|e| config_err(format!("テストファイルの作成に失敗しました: {}", e)))?;
+            .map_err(|e| CphError::Config(ConfigError::NotFound {
+                path: format!("テストファイルの作成に失敗しました: {}", e)
+            }))?;
 
         let test_cases = load_test_cases(&test_dir)?;
         assert_eq!(test_cases.len(), 1);
