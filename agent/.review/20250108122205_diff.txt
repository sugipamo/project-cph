diff --git a/src/config/mod.rs b/src/config/mod.rs
index 61d7c3f..9285a7d 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -16,13 +16,13 @@ use std::fs;
 use anyhow::{Error, Result, Context as _, anyhow};
 
 // 基本的な設定ノード
-#[derive(Clone, PartialEq, Eq)]
+#[derive(Clone, PartialEq, Eq, Debug)]
 pub struct Node {
     value: Value,
     metadata: Metadata,
 }
 
-#[derive(Clone, PartialEq, Eq)]
+#[derive(Clone, PartialEq, Eq, Debug)]
 pub struct Metadata {
     path: String,
     description: Option<String>,
@@ -118,7 +118,7 @@ impl PartialEq for dyn CustomSchema {
 impl Eq for dyn CustomSchema {}
 
 // インの設定構造体
-#[derive(Clone, PartialEq, Eq)]
+#[derive(Clone, PartialEq, Eq, Debug)]
 pub struct Config {
     root: Arc<Node>,
 }
diff --git a/src/contest/model/mod.rs b/src/contest/model/mod.rs
index a56fd7d..d36bdc7 100644
--- a/src/contest/model/mod.rs
+++ b/src/contest/model/mod.rs
@@ -98,6 +98,40 @@ impl Contest {
             .delete_file(&workspace_path)?
             .commit()
     }
+
+    /// テストディレクトリのパスを取得します
+    /// 
+    /// # Returns
+    /// * `Result<PathBuf>` - テストディレクトリのパス
+    /// 
+    /// # Errors
+    /// - テストディレクトリが存在しない場合
+    pub fn get_test_dir(&self) -> Result<PathBuf> {
+        let path = PathBuf::from(&self.id).join("test");
+        if !path.exists() {
+            return Err(anyhow::anyhow!(
+                "テストディレクトリが見つかりません: {}", path.display()
+            ));
+        }
+        Ok(path)
+    }
+
+    /// ソースファイルのパスを取得します
+    /// 
+    /// # Returns
+    /// * `Result<PathBuf>` - ソースファイルのパス
+    /// 
+    /// # Errors
+    /// - ソースファイルが存在しない場合
+    pub fn get_source_file(&self) -> Result<PathBuf> {
+        let path = PathBuf::from(&self.id).join("src").join("main.rs");
+        if !path.exists() {
+            return Err(anyhow::anyhow!(
+                "ソースファイルが見つかりません: {}", path.display()
+            ));
+        }
+        Ok(path)
+    }
 }
 
 #[derive(Debug, Clone, PartialEq, Eq)]
diff --git a/src/contest/service/command.rs b/src/contest/service/command.rs
index b992c93..bd4193a 100644
--- a/src/contest/service/command.rs
+++ b/src/contest/service/command.rs
@@ -38,7 +38,9 @@ impl Service {
                     || Err(anyhow::anyhow!(contest::error("invalid_command", "コンテストが選択されていません"))),
                     |contest| {
                         println!("テストを実行します: test_number={test_number:?}");
-                        self.test_service.run_test(&contest, test_number)
+                        let result = self.test_service.run_test(&contest, test_number)?;
+                        println!("{}", result.summary());
+                        Ok(())
                     }
                 )
             }
diff --git a/src/contest/service/path.rs b/src/contest/service/path.rs
index d888a76..3a14eb9 100644
--- a/src/contest/service/path.rs
+++ b/src/contest/service/path.rs
@@ -2,153 +2,91 @@ use std::path::{Path, PathBuf};
 use anyhow::{Result, anyhow};
 use crate::message::contest;
 
+/// パスの種類を表す列挙型
+#[derive(Debug, Clone, Copy)]
+pub enum Type {
+    Contest,
+    Problem,
+    Source,
+    Test,
+}
+
+impl Type {
+    /// パスの種類を文字列として取得します
+    const fn as_str(self) -> &'static str {
+        match self {
+            Self::Contest => "コンテスト",
+            Self::Problem => "問題",
+            Self::Source => "ソース",
+            Self::Test => "テスト",
+        }
+    }
+}
+
+/// パス管理サービスを提供する構造体
+#[derive(Debug)]
 pub struct Service {
+    #[allow(dead_code)]
     base_dir: PathBuf,
 }
 
 impl Service {
+    /// 新しいパス管理サービスを作成します
+    ///
+    /// # Arguments
+    /// * `base_dir` - ベースディレクトリ
+    ///
+    /// # Returns
+    /// * `Self` - 新しいパス管理サービスインスタンス
     #[must_use = "この関数は新しいPathServiceインスタンスを返します"]
-    pub fn new(base_dir: impl Into<PathBuf>) -> Self {
+    pub fn new(base_dir: impl AsRef<Path>) -> Self {
         Self {
-            base_dir: base_dir.into(),
+            base_dir: base_dir.as_ref().to_path_buf(),
         }
     }
 
-    ///ベースディレクトリの存在を確認します。
-    /// 
+    /// パスの存在を検証します
+    ///
+    /// # Arguments
+    /// * `path` - 検証するパス
+    /// * `path_type` - パスの種類
+    ///
+    /// # Returns
+    /// * `Result<()>` - 検証結果
+    ///
     /// # Errors
-    /// - ベースディレクトリが存在しない場合
-    pub fn validate_base_dir(&self) -> Result<()> {
-        if !self.base_dir.exists() {
-            return Err(anyhow!(contest::error("contest_dir_not_found", self.base_dir.display())));
-        }
-        Ok(())
-    }
-
-    /// ソースディレクトリの存在を確認します。
-    /// 
-    /// # Errors
-    /// - ソースディレクトリが存在しない場合
-    pub fn validate_source_dir(&self, source_dir: impl AsRef<Path>) -> Result<()> {
-        let source_dir = source_dir.as_ref();
-        if !source_dir.exists() {
-            return Err(anyhow!(contest::error("source_dir_not_found", source_dir.display())));
-        }
-        Ok(())
-    }
-
-    /// ソース�ァイルの存在を確認します。
-    /// 
-    /// # Errors
-    /// - ソースファイルが存在しない場合
-    pub fn validate_source_file(&self, source_path: impl AsRef<Path>) -> Result<()> {
-        let source_path = source_path.as_ref();
-        if !source_path.exists() {
-            return Err(anyhow!(
-                "ソースファイルが存在しません: {:?}", source_path
-            ));
-        }
-        Ok(())
-    }
-
-    /// テストディレクトリの存在を確認します。
-    /// 
-    /// # Errors
-    /// - テストディレクトリが存在しない場合
-    pub fn validate_test_dir(&self, test_dir: impl AsRef<Path>) -> Result<()> {
-        let test_dir = test_dir.as_ref();
-        if !test_dir.exists() {
-            return Err(anyhow!(
-                "テストディレクトリが存在しません: {:?}", test_dir
-            ));
-        }
-        Ok(())
-    }
-
-    /// ビルドディレクトリを作成します。
-    /// 
-    /// # Errors
-    /// - ディレクトリの作成に失敗した場合
-    pub fn create_build_dir(&self, build_dir: impl AsRef<Path>) -> Result<()> {
-        let build_dir = build_dir.as_ref();
-        std::fs::create_dir_all(build_dir)
-            .map_err(|e| anyhow!(
-                "ビルドディレクトリの作成に失敗しました: {}", e
-            ))?;
-        Ok(())
-    }
-
-    /// コンテストディレクトリのパスを取得します。
-    /// 
-    /// # Errors
-    /// - コンテストディレクトリが存在しない場合
-    pub fn get_contest_dir(&self, contest_id: &str) -> Result<PathBuf> {
-        let path = self.base_dir.join(contest_id);
-        if !path.exists() {
-            return Err(anyhow!(
-                "コンテストディレクトリが見つかりません: {}", path.display()
-            ));
-        }
-        Ok(path)
-    }
-
-    /// 問題ディレクトリのパスを取得します。
-    /// 
-    /// # Errors
-    /// - コンテストディレクトリが存在しない場合
-    /// - 問題ディレクトリが存在しない場合
-    pub fn get_problem_dir(&self, contest_id: &str, problem_id: &str) -> Result<PathBuf> {
-        let path = self.get_contest_dir(contest_id)?.join(problem_id);
-        if !path.exists() {
-            return Err(anyhow!(
-                "問題ディレクトリが見つかりません: {}", path.display()
-            ));
-        }
-        Ok(path)
-    }
-
-    /// ソースファイルのパスを取得します。
-    /// 
-    /// # Errors
-    /// - コンテストディレクトリが存在しない場合
-    /// - 問題ディレクトリが存在しない場合
-    /// - ソースファイルが存在しない場合
-    pub fn get_source_file(&self, contest_id: &str, problem_id: &str) -> Result<PathBuf> {
-        let path = self.get_problem_dir(contest_id, problem_id)?.join("main.rs");
+    /// * パスが存在しない場合
+    pub fn validate_path_exists(path: impl AsRef<Path>, path_type: Type) -> Result<()> {
+        let path = path.as_ref();
         if !path.exists() {
-            return Err(anyhow!(
-                "ソースファイルが見つかりません: {}", path.display()
-            ));
+            return Err(anyhow!(contest::error(
+                "path_error",
+                format!("{}ディレクトリが存在しません: {}", path_type.as_str(), path.display())
+            )));
         }
-        Ok(path)
+        Ok(())
     }
 
-    /// テストディレクトリのパスを取得します。
-    /// 
+    /// ディレクトリを作成します
+    ///
+    /// # Arguments
+    /// * `path` - 作成するディレクトリのパス
+    /// * `path_type` - パスの種類
+    ///
+    /// # Returns
+    /// * `Result<()>` - 作成結果
+    ///
     /// # Errors
-    /// - コンテストディレクトリが存在しない場合
-    /// - 問題ディレクトリが存在しない場合
-    /// - テストディレクトリが存在しない場合
-    pub fn get_test_dir(&self, contest_id: &str, problem_id: &str) -> Result<PathBuf> {
-        let path = self.get_problem_dir(contest_id, problem_id)?.join("test");
+    /// * ディレクトリの作成に失敗した場合
+    pub fn create_directory(path: impl AsRef<Path>, path_type: Type) -> Result<()> {
+        let path = path.as_ref();
         if !path.exists() {
-            return Err(anyhow!(
-                "テストディレクトリが見つかりません: {}", path.display()
-            ));
+            std::fs::create_dir_all(path)
+                .map_err(|e| anyhow!(contest::error(
+                    "path_error",
+                    format!("{}ディレクトリの作成に失敗: {}: {}", path_type.as_str(), path.display(), e)
+                )))?;
         }
-        Ok(path)
-    }
-
-    /// コンテストディレクトリを作成します。
-    /// 
-    /// # Errors
-    /// - ディレクトリの作成に失敗した場合
-    pub fn create_contest_dir(&self, contest_id: &str) -> Result<PathBuf> {
-        let path = self.base_dir.join(contest_id);
-        std::fs::create_dir_all(&path)
-            .map_err(|e| anyhow!(
-                "コンテストディレクトリの作成に失敗しました: {}", e
-            ))?;
-        Ok(path)
+        Ok(())
     }
 }
\ No newline at end of file
diff --git a/src/contest/service/test.rs b/src/contest/service/test.rs
index 81f58c0..e536d65 100644
--- a/src/contest/service/test.rs
+++ b/src/contest/service/test.rs
@@ -1,35 +1,247 @@
-use anyhow::Result;
+use std::path::{Path, PathBuf};
+use anyhow::{Result as AnyhowResult, anyhow};
 use crate::config::Config;
 use crate::contest::model::Contest;
 use crate::message::contest;
+use crate::docker::execution::Runtime;
 
+/// テスト結果の状態を表す列挙型
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum Status {
+    Success,
+    Failure,
+    Error,
+}
+
+/// テストケースの結果を表す構造体
+#[derive(Debug)]
+pub struct CaseResult {
+    pub case_number: usize,
+    pub status: Status,
+    pub execution_time: std::time::Duration,
+    pub stdout: String,
+    pub stderr: String,
+    pub expected: String,
+    pub actual: String,
+}
+
+/// テスト実行の結果を表す構造体
+#[derive(Debug)]
+#[allow(clippy::module_name_repetitions)]
+pub struct TestResults {
+    pub total_cases: usize,
+    pub successful_cases: usize,
+    pub failed_cases: usize,
+    pub error_cases: usize,
+    pub total_time: std::time::Duration,
+    pub case_results: Vec<CaseResult>,
+}
+
+impl TestResults {
+    /// テスト結果の概要を文字列として取得します
+    #[must_use]
+    pub fn summary(&self) -> String {
+        format!(
+            "テスト結果: {} テスト中 {} 成功, {} 失敗, {} エラー (合計時間: {:.2}秒)",
+            self.total_cases,
+            self.successful_cases,
+            self.failed_cases,
+            self.error_cases,
+            self.total_time.as_secs_f64()
+        )
+    }
+}
+
+/// テスト実行サービスを提供する構造体
+#[derive(Debug)]
 pub struct Service {
     #[allow(dead_code)]
     config: Config,
+    #[allow(dead_code)]
+    runtime: Runtime,
 }
 
 impl Service {
-    /// 新しいテスターを作成します。
+    /// 新しいテストサービスを作成します
+    /// 
+    /// # Arguments
+    /// * `config` - 設定情報
+    /// 
+    /// # Returns
+    /// * `AnyhowResult<Self>` - 新しいテストサービスインスタンス
     /// 
     /// # Errors
     /// - 設定の読み込みに失敗した場合
     #[must_use = "この関数は新しいTestServiceインスタンスを返します"]
-    pub fn new(config: &Config) -> Result<Self> {
+    pub fn new(config: &Config) -> AnyhowResult<Self> {
         Ok(Self {
             config: config.clone(),
+            runtime: Runtime::new(),
         })
     }
 
-    /// テストを実行します。
+    /// テストを実行します
+    /// 
+    /// # Arguments
+    /// * `contest` - コンテスト情報
+    /// * `test_number` - 実行するテストケース番号（Noneの場合は全テストを実行）
+    /// 
+    /// # Returns
+    /// * `AnyhowResult<TestResults>` - テスト実行結果
     /// 
     /// # Errors
     /// - テストの実行に失敗した場合
-    pub fn run_test(&self, _contest: &Contest, test_number: Option<usize>) -> Result<()> {
-        // TODO: 実際のテスト実行処理を実装
-        match test_number {
-            Some(n) => println!("{}", contest::hint("optimize_code", format!("テストケース {n} を実行します"))),
-            None => println!("{}", contest::hint("optimize_code", "全てのテストケースを実行します")),
+    pub fn run_test(&self, contest: &Contest, test_number: Option<usize>) -> AnyhowResult<TestResults> {
+        let test_dir = contest.get_test_dir()?;
+        let source_file = contest.get_source_file()?;
+
+        // テストケースの一覧を取得
+        let test_cases = Self::get_test_cases(&test_dir, test_number)?;
+        if test_cases.is_empty() {
+            return Err(anyhow!(contest::error("test_failed", "テストケースが見つかりません")));
         }
-        Ok(())
+
+        let start_time = std::time::Instant::now();
+        let mut results = Vec::new();
+        let mut successful_cases = 0;
+        let mut failed_cases = 0;
+        let mut error_cases = 0;
+        let total_cases = test_cases.len();
+
+        // 各テストケースを実行
+        for (case_number, (input_file, expected_file)) in test_cases {
+            match Self::run_test_case(case_number, &source_file, &input_file, &expected_file) {
+                Ok(result) => {
+                    match result.status {
+                        Status::Success => successful_cases += 1,
+                        Status::Failure => failed_cases += 1,
+                        Status::Error => error_cases += 1,
+                    }
+                    results.push(result);
+                }
+                Err(e) => {
+                    error_cases += 1;
+                    results.push(CaseResult {
+                        case_number,
+                        status: Status::Error,
+                        execution_time: std::time::Duration::from_secs(0),
+                        stdout: String::new(),
+                        stderr: e.to_string(),
+                        expected: String::new(),
+                        actual: String::new(),
+                    });
+                }
+            }
+        }
+
+        Ok(TestResults {
+            total_cases,
+            successful_cases,
+            failed_cases,
+            error_cases,
+            total_time: start_time.elapsed(),
+            case_results: results,
+        })
+    }
+
+    /// テストケースの一覧を取得します
+    /// 
+    /// # Arguments
+    /// * `test_dir` - テストディレクトリ
+    /// * `test_number` - 取得するテストケース番号（Noneの場合は全テスト）
+    /// 
+    /// # Returns
+    /// * `AnyhowResult<Vec<(usize, (PathBuf, PathBuf))>>` - テストケース番号とテストファイルのペアのリスト
+    /// 
+    /// # Errors
+    /// - テストケースの読み取りに失敗した場合
+    fn get_test_cases(
+        test_dir: &Path,
+        test_number: Option<usize>,
+    ) -> AnyhowResult<Vec<(usize, (PathBuf, PathBuf))>> {
+        let mut cases = Vec::new();
+        
+        if let Some(n) = test_number {
+            let input = test_dir.join(format!("{n}.in"));
+            let expected = test_dir.join(format!("{n}.out"));
+            if input.exists() && expected.exists() {
+                cases.push((n, (input, expected)));
+            }
+        } else {
+            for entry in std::fs::read_dir(test_dir)? {
+                let entry = entry?;
+                let path = entry.path();
+                if let Some(ext) = path.extension() {
+                    if ext == "in" {
+                        if let Some(stem) = path.file_stem() {
+                            if let Ok(n) = stem.to_string_lossy().parse::<usize>() {
+                                let expected = test_dir.join(format!("{n}.out"));
+                                if expected.exists() {
+                                    cases.push((n, (path, expected)));
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            cases.sort_by_key(|(n, _)| *n);
+        }
+
+        Ok(cases)
+    }
+
+    /// 単一のテストケースを実行します
+    /// 
+    /// # Arguments
+    /// * `case_number` - テストケース番号
+    /// * `source_file` - ソースファイル
+    /// * `input_file` - 入力ファイル
+    /// * `expected_file` - 期待される出力ファイル
+    /// 
+    /// # Returns
+    /// * `AnyhowResult<CaseResult>` - テストケースの実実行結果
+    /// 
+    /// # Errors
+    /// - テストケースの実行に失敗した場合
+    fn run_test_case(
+        case_number: usize,
+        source_file: &Path,
+        input_file: &Path,
+        expected_file: &Path,
+    ) -> AnyhowResult<CaseResult> {
+        let start_time = std::time::Instant::now();
+
+        // コンテナを作成して実行
+        let mut runtime = Runtime::new().with_auto_remove(true);
+        runtime.create("rust:latest", &[])?;
+        let (stdout, stderr) = runtime.execute_command(&[
+            "exec",
+            source_file.to_string_lossy().as_ref(),
+            "<",
+            input_file.to_string_lossy().as_ref(),
+        ])?;
+
+        // 期待される出力を読み込み
+        let expected = std::fs::read_to_string(expected_file)?;
+        let actual = stdout.trim().to_string();
+
+        // 結果を比較
+        let status = if stderr.is_empty() && actual == expected.trim() {
+            Status::Success
+        } else if !stderr.is_empty() {
+            Status::Error
+        } else {
+            Status::Failure
+        };
+
+        Ok(CaseResult {
+            case_number,
+            status,
+            execution_time: start_time.elapsed(),
+            stdout,
+            stderr,
+            expected,
+            actual,
+        })
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/url.rs b/src/contest/service/url.rs
index e4a568f..a47cbcf 100644
--- a/src/contest/service/url.rs
+++ b/src/contest/service/url.rs
@@ -1,8 +1,33 @@
 use anyhow::{Result, anyhow};
 use crate::message::contest;
 
+/// URL生成を担当するトレイト
+pub trait Generator: std::fmt::Debug {
+    /// コンテストのURLを生成します
+    fn contest_url(&self, contest_id: &str) -> String;
+
+    /// 問題のURLを生成します
+    fn problem_url(&self, contest_id: &str, problem_id: &str) -> String;
+}
+
+/// `AtCoder`のURL生成を担当する構造体
+#[derive(Debug)]
+pub struct AtCoderGenerator;
+
+impl Generator for AtCoderGenerator {
+    fn contest_url(&self, contest_id: &str) -> String {
+        format!("https://atcoder.jp/contests/{contest_id}")
+    }
+
+    fn problem_url(&self, contest_id: &str, problem_id: &str) -> String {
+        format!("https://atcoder.jp/contests/{contest_id}/tasks/{problem_id}")
+    }
+}
+
+/// URL管理サービスを提供する構造体
+#[derive(Debug)]
 pub struct Service {
-    site: Option<String>,
+    site: Option<Box<dyn Generator>>,
     contest_id: Option<String>,
     problem_id: Option<String>,
 }
@@ -14,7 +39,11 @@ impl Default for Service {
 }
 
 impl Service {
-    #[must_use = "この関数は新しいServiceインスタンスを返します"]
+    /// 新しいURL管理サービスを作成します
+    ///
+    /// # Returns
+    /// * `Self` - 新しいURL管理サービスインスタンス
+    #[must_use = "この関数は新しいURLServiceインスタンスを返します"]
     pub const fn new() -> Self {
         Self {
             site: None,
@@ -23,109 +52,130 @@ impl Service {
         }
     }
 
-    /// サイトの指定を検証します。
-    /// 
-    /// # Errors
-    /// - サイトが指定されていない場合
-    pub fn validate_site(&self) -> Result<()> {
-        if self.site.is_none() {
-            return Err(anyhow!(contest::error("resource_not_found", "サイトが指定されていません")));
-        }
-        Ok(())
+    /// サイトを設定します
+    ///
+    /// # Arguments
+    /// * `site` - URL生成を担当する構造体
+    ///
+    /// # Returns
+    /// * `Self` - 設定を変更したURL管理サービスインスタンス
+    #[must_use = "この関数は新しいURLServiceインスタンスを返します"]
+    pub fn with_site(mut self, site: Box<dyn Generator>) -> Self {
+        self.site = Some(site);
+        self
     }
 
-    /// コンテストIDの指定を検証します。
-    /// 
-    /// # Errors
-    /// - コンテストIDが指定されていない場合
-    pub fn validate_contest_id(&self) -> Result<()> {
-        if self.contest_id.is_none() {
-            return Err(anyhow!(contest::error("resource_not_found", "コンテストIDが指定されていません")));
-        }
-        Ok(())
+    /// コンテストIDを設定します
+    ///
+    /// # Arguments
+    /// * `contest_id` - コンテストID
+    ///
+    /// # Returns
+    /// * `Self` - 設定を変更したURL管理サービスインスタンス
+    #[must_use = "この関数は新しいURLServiceインスタンスを返します"]
+    pub fn with_contest_id(mut self, contest_id: impl Into<String>) -> Self {
+        self.contest_id = Some(contest_id.into());
+        self
     }
 
-    /// 問題IDの指定を検証します。
-    /// 
-    /// # Errors
-    /// - 問題IDが指定されていない場合
-    pub fn validate_problem_id(&self) -> Result<()> {
-        if self.problem_id.is_none() {
-            return Err(anyhow!(contest::error("resource_not_found", "問題IDが指定されていません")));
-        }
-        Ok(())
+    /// 問題IDを設定します
+    ///
+    /// # Arguments
+    /// * `problem_id` - 問題ID
+    ///
+    /// # Returns
+    /// * `Self` - 設定を変更したURL管理サービスインスタンス
+    #[must_use = "この関数は新しいURLServiceインスタンスを返します"]
+    pub fn with_problem_id(mut self, problem_id: impl Into<String>) -> Self {
+        self.problem_id = Some(problem_id.into());
+        self
     }
 
-    /// コンテストのURLを取得します。
-    /// 
+    /// コンテストのURLを取得します
+    ///
+    /// # Returns
+    /// * `Result<String>` - コンテストのURL
+    ///
     /// # Errors
-    /// - サイトが指定されていない場合
-    /// - コンテストIDが指定されていない場合
-    /// - 未対応のサイトが指定された場合
-    /// 
-    /// # Panics
-    /// 
-    /// - `内部状態が不整合な場合（validate_site()が成功したのにsiteがNoneの場合など）`
-    #[must_use = "この関数はコンテストのURLを返します"]
+    /// * サイトが設定されていない場合
+    /// * コンテストIDが設定されていない場合
+    /// * 内部状態が不整合な場合（`validate_site`が成功したのに`site`が`None`の場合など）
     pub fn get_contest_url(&self) -> Result<String> {
         self.validate_site()?;
         self.validate_contest_id()?;
 
-        let site = self.site.as_deref().expect("サイトが指定されていません");
-        let contest_id = self.contest_id.as_ref().expect("コンテストIDが指定されていません");
+        let site = self.site.as_ref()
+            .ok_or_else(|| anyhow!(contest::error("url_error", "サイトが設定されていません")))?;
+        let contest_id = self.contest_id.as_ref()
+            .ok_or_else(|| anyhow!(contest::error("url_error", "コンテストIDが設定されていません")))?;
 
-        match site {
-            "atcoder" => Ok(format!(
-                "https://atcoder.jp/contests/{contest_id}"
-            )),
-            _ => Err(anyhow!(contest::error("invalid_url", format!("未対応のサイトです: {site}")))),
-        }
+        Ok(site.contest_url(contest_id))
     }
 
-    /// 問題のURLを取得します。
-    /// 
+    /// 問題のURLを取得します
+    ///
+    /// # Returns
+    /// * `Result<String>` - 問題のURL
+    ///
     /// # Errors
-    /// - サイトが指定されていない場合
-    /// - コンテストIDが指定されていない場合
-    /// - 問題IDが指定されていない場合
-    /// - 未対応のサイトが指定された場合
-    /// 
-    /// # Panics
-    /// 
-    /// - `内部状態が不整合な場合（validate_site()が成功したのにsiteがNoneの場合など）`
-    #[must_use = "この関数は問題のURLを返します"]
+    /// * サイトが設定されていない場合
+    /// * コンテストIDが設定されていない場合
+    /// * 問題IDが設定されていない場合
+    /// * 内部状態が不整合な場合（`validate_site`が成功したのに`site`が`None`の場合など）
     pub fn get_problem_url(&self) -> Result<String> {
         self.validate_site()?;
         self.validate_contest_id()?;
         self.validate_problem_id()?;
 
-        let site = self.site.as_deref().expect("サイトが指定されていません");
-        let contest_id = self.contest_id.as_ref().expect("コンテストIDが指定されていません");
-        let problem_id = self.problem_id.as_ref().expect("問題IDが指定されていません");
+        let site = self.site.as_ref()
+            .ok_or_else(|| anyhow!(contest::error("url_error", "サイトが設定されていません")))?;
+        let contest_id = self.contest_id.as_ref()
+            .ok_or_else(|| anyhow!(contest::error("url_error", "コンテストIDが設定されていません")))?;
+        let problem_id = self.problem_id.as_ref()
+            .ok_or_else(|| anyhow!(contest::error("url_error", "問題IDが設定されていません")))?;
 
-        match site {
-            "atcoder" => Ok(format!(
-                "https://atcoder.jp/contests/{contest_id}/tasks/{problem_id}"
-            )),
-            _ => Err(anyhow!(contest::error("invalid_url", format!("未対応のサイトです: {site}")))),
-        }
+        Ok(site.problem_url(contest_id, problem_id))
     }
 
-    #[must_use = "この関数は新しいServiceインスタンスを返します"]
-    pub fn with_site(mut self, site: impl Into<String>) -> Self {
-        self.site = Some(site.into());
-        self
+    /// サイトの設定を検証します
+    ///
+    /// # Returns
+    /// * `Result<()>` - 検証結果
+    ///
+    /// # Errors
+    /// * サイトが設定されていない場合
+    fn validate_site(&self) -> Result<()> {
+        if self.site.is_none() {
+            return Err(anyhow!(contest::error("url_error", "サイトが設定されていません")));
+        }
+        Ok(())
     }
 
-    #[must_use = "この関数は新しいServiceインスタンスを返します"]
-    pub fn with_contest_id(mut self, contest_id: impl Into<String>) -> Self {
-        self.contest_id = Some(contest_id.into());
-        self
+    /// コンテストIDの設定を検証します
+    ///
+    /// # Returns
+    /// * `Result<()>` - 検証結果
+    ///
+    /// # Errors
+    /// * コンテストIDが設定されていない場合
+    fn validate_contest_id(&self) -> Result<()> {
+        if self.contest_id.is_none() {
+            return Err(anyhow!(contest::error("url_error", "コンテストIDが設定されていません")));
+        }
+        Ok(())
     }
 
-    #[must_use = "この関数は新しいServiceインスタンスを返します"]
-    pub fn with_problem_id(mut self, problem_id: impl Into<String>) -> Self {
-        self.problem_id = Some(problem_id.into());
-        self
+    /// 問題IDの設定を検証します
+    ///
+    /// # Returns
+    /// * `Result<()>` - 検証結果
+    ///
+    /// # Errors
+    /// * 問題IDが設定されていない場合
+    fn validate_problem_id(&self) -> Result<()> {
+        if self.problem_id.is_none() {
+            return Err(anyhow!(contest::error("url_error", "問題IDが設定されていません")));
+        }
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/execution/command.rs b/src/docker/execution/command.rs
index 01ede43..25dfff2 100644
--- a/src/docker/execution/command.rs
+++ b/src/docker/execution/command.rs
@@ -1,17 +1,27 @@
-use std::process::Command;
+use std::process::{Command, Output};
 use std::borrow::Cow;
-use anyhow::{Result, anyhow};
+use anyhow::{Result, anyhow, Context};
 use crate::message::docker;
 
+/// Dockerコマンドの実行結果を表す構造体
+#[derive(Debug)]
+pub struct ExecutionResult {
+    pub stdout: String,
+    pub stderr: String,
+    pub exit_code: i32,
+}
+
 /// Dockerコマンドの実行を担当する構造体
 ///
 /// # Fields
 /// * `name` - 実行するDockerコマンド名
 /// * `args` - コマンドの引数リスト
+/// * `capture_stderr` - 標準エラー出力をキャプチャするかどうか
 #[derive(Clone)]
 pub struct Executor {
     name: String,
     args: Vec<String>,
+    capture_stderr: bool,
 }
 
 impl Executor {
@@ -27,6 +37,22 @@ impl Executor {
         Self {
             name: name.into(),
             args: Vec::new(),
+            capture_stderr: false,
+        }
+    }
+
+    /// 標準エラー出力のキャプチャを設定します
+    ///
+    /// # Arguments
+    /// * `capture` - キャプチャするかどうか
+    ///
+    /// # Returns
+    /// * `Self` - 新しいExecutorインスタンス
+    #[must_use = "この関数は新しいExecutorインスタンスを返します"]
+    pub fn capture_stderr(self, capture: bool) -> Self {
+        Self {
+            capture_stderr: capture,
+            ..self
         }
     }
 
@@ -44,6 +70,7 @@ impl Executor {
         Self {
             name: self.name,
             args,
+            capture_stderr: self.capture_stderr,
         }
     }
 
@@ -65,33 +92,68 @@ impl Executor {
         Self {
             name: self.name,
             args: new_args,
+            capture_stderr: self.capture_stderr,
         }
     }
 
+    /// コマンドを実行し、生の出力を返します
+    ///
+    /// # Returns
+    /// * `Result<Output>` - コマンドの実行結果
+    ///
+    /// # Errors
+    /// * コマンドの実行に失敗した場合
+    fn execute_raw(&self) -> Result<Output> {
+        Command::new("docker")
+            .arg(&self.name)
+            .args(&self.args)
+            .output()
+            .with_context(|| docker::error("command_failed", "コマンドの実行に失敗しました"))
+    }
+
     /// コマンドを実行し、結果を返します
     ///
     /// # Returns
-    /// * `Result<String>` - コマンドの実行結果
+    /// * `Result<ExecutionResult>` - コマンドの実行結果
     ///
     /// # Errors
     /// * コマンドの実行に失敗した場合
     /// * 出力の文字列変換に失敗した場合
-    #[must_use = "この関数はコマンドの実行結果を返します"]
-    pub fn execute(self) -> Result<String> {
-        let mut command = Command::new("docker");
-        command.arg(&self.name);
-        command.args(&self.args);
+    pub fn execute(self) -> Result<ExecutionResult> {
+        let output = self.execute_raw()?;
 
-        let output = command
-            .output()
-            .map_err(|e| anyhow!(docker::error("command_failed", e)))?;
+        let stdout = String::from_utf8(output.stdout)
+            .with_context(|| docker::error("command_failed", "標準出力の解析に失敗しました"))?;
+        let stderr = String::from_utf8(output.stderr)
+            .with_context(|| docker::error("command_failed", "標準エラー出力の解析に失敗しました"))?;
 
         if !output.status.success() {
-            let error = String::from_utf8_lossy(&output.stderr);
-            return Err(anyhow!(docker::error("command_failed", error)));
+            if self.capture_stderr {
+                return Ok(ExecutionResult {
+                    stdout,
+                    stderr,
+                    exit_code: output.status.code().unwrap_or(-1),
+                });
+            }
+            return Err(anyhow!(docker::error("command_failed", stderr)));
         }
 
-        String::from_utf8(output.stdout)
-            .map_err(|e| anyhow!(docker::error("command_failed", e)))
+        Ok(ExecutionResult {
+            stdout,
+            stderr,
+            exit_code: 0,
+        })
+    }
+
+    /// コマンドを実行し、標準出力のみを返します
+    ///
+    /// # Returns
+    /// * `Result<String>` - コマンドの標準出力
+    ///
+    /// # Errors
+    /// * コマンドの実行に失敗した場合
+    /// * 出力の文字列変換に失敗した場合
+    pub fn execute_output(self) -> Result<String> {
+        self.execute().map(|result| result.stdout)
     }
 } 
\ No newline at end of file
diff --git a/src/docker/execution/container.rs b/src/docker/execution/container.rs
index feb68d3..dbaf207 100644
--- a/src/docker/execution/container.rs
+++ b/src/docker/execution/container.rs
@@ -6,9 +6,11 @@ use crate::message::docker;
 ///
 /// # Fields
 /// * `container_id` - 管理対象のコンテナID（オプション）
+/// * `auto_remove` - コンテナを自動的に削除するかどうか
 #[derive(Debug)]
 pub struct Runtime {
     container_id: Option<String>,
+    auto_remove: bool,
 }
 
 impl Default for Runtime {
@@ -26,13 +28,28 @@ impl Runtime {
     pub const fn new() -> Self {
         Self {
             container_id: None,
+            auto_remove: true,
         }
     }
 
+    /// 自動削除の設定を変更します
+    ///
+    /// # Arguments
+    /// * `auto_remove` - コンテナを自動的に削除するかどうか
+    ///
+    /// # Returns
+    /// * `Self` - 設定を変更したRuntimeインスタンス
+    #[must_use = "この関数は新しいRuntimeインスタンスを返します"]
+    pub const fn with_auto_remove(mut self, auto_remove: bool) -> Self {
+        self.auto_remove = auto_remove;
+        self
+    }
+
     /// コンテナを作成します
     ///
     /// # Arguments
     /// * `image` - 使用するDockerイメージ名
+    /// * `options` - 追加のDockerオプション
     ///
     /// # Returns
     /// * `Result<()>` - 作成結果
@@ -40,14 +57,20 @@ impl Runtime {
     /// # Errors
     /// * コンテナが既に作成されている場合
     /// * コンテナの作成に失敗した場合
-    #[must_use = "この関数はコンテナの作成結果を返します"]
-    pub fn create(&mut self, image: &str) -> Result<()> {
+    pub fn create(&mut self, image: &str, options: &[&str]) -> Result<()> {
         if self.container_id.is_some() {
             return Err(anyhow!(docker::error("container_error", "コンテナは既に作成されています")));
         }
 
+        let mut args = vec!["create"];
+        if self.auto_remove {
+            args.push("--rm");
+        }
+        args.extend(options);
+        args.push(image);
+
         let output = Command::new("docker")
-            .args(["create", image])
+            .args(&args)
             .output()
             .map_err(|e| anyhow!(docker::error("container_error", e)))?;
 
@@ -184,4 +207,82 @@ impl Runtime {
 
         Ok(())
     }
+
+    /// コンテナを削除します
+    ///
+    /// # Returns
+    /// * `Result<()>` - 削除結果
+    ///
+    /// # Errors
+    /// * コンテナが作成されていない場合
+    /// * コンテナの削除に失敗した場合
+    pub fn remove(&mut self) -> Result<()> {
+        let container_id = self.container_id.take()
+            .ok_or_else(|| anyhow!(docker::error("container_error", "コンテナが作成されていません")))?;
+
+        let output = Command::new("docker")
+            .args(["rm", "-f", &container_id])
+            .output()
+            .map_err(|e| anyhow!(docker::error("container_error", e)))?;
+
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(anyhow!(docker::error("container_error", stderr)));
+        }
+
+        Ok(())
+    }
+
+    /// コンテナIDを取得します
+    ///
+    /// # Returns
+    /// * `Option<&str>` - コンテナID
+    #[must_use]
+    pub fn container_id(&self) -> Option<&str> {
+        self.container_id.as_deref()
+    }
+
+    /// コンテナ内でコマンドを実行します
+    ///
+    /// # Arguments
+    /// * `command` - 実行するコマンドとその引数
+    ///
+    /// # Returns
+    /// * `Result<(String, String)>` - 標準出力と標準エラー出力のタプル
+    ///
+    /// # Errors
+    /// * コンテナが作成されていない場合
+    /// * コマンドの実行に失敗した場合
+    pub fn execute_command(&self, command: &[&str]) -> Result<(String, String)> {
+        let container_id = self.container_id
+            .as_ref()
+            .ok_or_else(|| anyhow!(docker::error("container_error", "コンテナが作成されていません")))?;
+
+        let mut args = vec!["exec", container_id];
+        args.extend(command);
+
+        let output = Command::new("docker")
+            .args(&args)
+            .output()
+            .map_err(|e| anyhow!(docker::error("container_error", e)))?;
+
+        let stdout = String::from_utf8(output.stdout)
+            .map_err(|e| anyhow!(docker::error("container_error", format!("標準出力の解析に失敗: {e}"))))?;
+        let stderr = String::from_utf8(output.stderr)
+            .map_err(|e| anyhow!(docker::error("container_error", format!("標準エラー出力の解析に失敗: {e}"))))?;
+
+        Ok((stdout, stderr))
+    }
+}
+
+impl Drop for Runtime {
+    fn drop(&mut self) {
+        if self.auto_remove {
+            if let Some(container_id) = &self.container_id {
+                let _ = Command::new("docker")
+                    .args(["rm", "-f", container_id])
+                    .output();
+            }
+        }
+    }
 } 
\ No newline at end of file
