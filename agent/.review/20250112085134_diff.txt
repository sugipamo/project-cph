diff --git a/src/container/mod.rs b/src/container/mod.rs
index e0180cb..fc4b260 100644
--- a/src/container/mod.rs
+++ b/src/container/mod.rs
@@ -1,13 +1,8 @@
 pub mod communication;
 pub mod io;
 pub mod runtime;
-pub mod state;
-pub mod orchestrator;
+pub mod image_builder;
 
 pub use runtime::Runtime;
-pub use runtime::config::Config;
-pub use io::buffer::Buffer;
 pub use runtime::container::Container;
-pub use runtime::container::State;
-pub use communication::protocol::{Message, MessageKind};
-pub use orchestrator::Orchestrator; 
\ No newline at end of file
+pub use runtime::container::State; 
\ No newline at end of file
diff --git a/src/container/runtime/config.rs b/src/container/runtime/config.rs
index 6a9a20e..cc9e448 100644
--- a/src/container/runtime/config.rs
+++ b/src/container/runtime/config.rs
@@ -2,48 +2,117 @@ use std::path::PathBuf;
 use serde::{Deserialize, Serialize};
 use anyhow::Result;
 use crate::config::Config as GlobalConfig;
+use crate::container::image_builder::BuilderConfig;
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct ImageSpec {
+    pub image_type: String,
+    pub source: String,
+}
+
+impl ImageSpec {
+    pub fn new(image_type: impl Into<String>, source: impl Into<String>) -> Self {
+        Self {
+            image_type: image_type.into(),
+            source: source.into(),
+        }
+    }
+
+    /// コンテナビルダーの設定に変換します。
+    ///
+    /// # Returns
+    /// `BuilderConfig` - ビルダーの設定
+    #[must_use]
+    pub fn to_builder_config(&self) -> BuilderConfig {
+        BuilderConfig::new(self.image_type.clone(), self.source.clone())
+    }
+
+    /// イメージを準備します。
+    ///
+    /// # Arguments
+    /// * `tag` - イメージのタグ
+    ///
+    /// # Returns
+    /// * `Ok(String)` - 準備されたイメージのID
+    /// * `Err(_)` - イメージの準備に失敗した場合
+    ///
+    /// # Errors
+    /// * イメージのビルドに失敗した場合
+    /// * イメージのプルに失敗した場合
+    pub async fn prepare_image(&self, tag: &str) -> Result<String> {
+        let builder_config = self.to_builder_config();
+        if let Some(builder) = builder_config.create_builder() {
+            builder.build_image(tag).await?;
+            Ok(tag.to_string())
+        } else {
+            Ok(self.source.clone())
+        }
+    }
+}
+
+#[derive(Debug, Clone)]
 pub struct Config {
     pub id: String,
     pub image: String,
     pub working_dir: PathBuf,
     pub args: Vec<String>,
+    pub image_config: Option<ImageSpec>,
 }
 
 impl Default for Config {
     fn default() -> Self {
-        // グローバル設定から値を取得を試みる
-        if let Ok(config) = GlobalConfig::get_default_config() {
-            if let Ok(mount_point) = config.get::<String>("system.container.mount_point") {
-                return Self {
-                    id: String::new(),
-                    image: String::new(),
-                    working_dir: PathBuf::from(mount_point),
-                    args: Vec::new(),
-                };
-            }
-        }
-
-        // フォールバック値
         Self {
             id: String::new(),
             image: String::new(),
             working_dir: PathBuf::from("/compile"),
             args: Vec::new(),
+            image_config: None,
         }
     }
 }
 
 impl Config {
-    pub fn new(id: impl Into<String>, image: impl Into<String>, working_dir: impl Into<PathBuf>, args: Vec<String>) -> Self {
+    pub fn new(
+        id: impl Into<String>,
+        image: impl Into<String>,
+        working_dir: impl Into<PathBuf>,
+        args: Vec<String>,
+        image_config: Option<ImageSpec>,
+    ) -> Self {
         Self {
             id: id.into(),
             image: image.into(),
             working_dir: working_dir.into(),
             args,
+            image_config,
         }
     }
+
+    /// イメージを準備し、準備されたイメージ名を含む新しい設定を返します。
+    ///
+    /// # Returns
+    /// * `Ok(Self)` - 準備されたイメージを含む新しい設定
+    /// * `Err(_)` - イメージの準備に失敗した場合
+    ///
+    /// # Errors
+    /// * イメージのビルドに失敗した場合
+    /// * イメージのプルに失敗した場合
+    pub async fn prepare_image(&self) -> Result<Self> {
+        let image = if let Some(image_config) = &self.image_config {
+            let tag = format!("cph-{}", self.id);
+            image_config.prepare_image(&tag).await?
+        } else {
+            self.image.clone()
+        };
+
+        Ok(Self {
+            id: self.id.clone(),
+            image,
+            working_dir: self.working_dir.clone(),
+            args: self.args.clone(),
+            image_config: self.image_config.clone(),
+        })
+    }
 }
 
 #[derive(Clone, Debug)]
diff --git a/src/container/runtime/containerd.rs b/src/container/runtime/containerd.rs
index 9e26c92..9844c4c 100644
--- a/src/container/runtime/containerd.rs
+++ b/src/container/runtime/containerd.rs
@@ -124,10 +124,11 @@ impl Runtime for ContainerdRuntime {
     }
 
     async fn run(&self, config: &config::Config) -> Result<()> {
+        let prepared_config = config.prepare_image().await?;
         let container_id = self.create(
-            &config.image,
-            &config.args,
-            &config.working_dir,
+            &prepared_config.image,
+            &prepared_config.args,
+            &prepared_config.working_dir,
             &[]  // 空の環境変数リスト
         ).await?;
         self.start(&container_id).await?;
diff --git a/src/container/runtime/mock.rs b/src/container/runtime/mock.rs
index 8fc60d3..c2064d2 100644
--- a/src/container/runtime/mock.rs
+++ b/src/container/runtime/mock.rs
@@ -1,70 +1,93 @@
-use std::sync::Arc;
-use tokio::sync::Mutex;
+use std::path::Path;
+use anyhow::{Result, anyhow};
+use async_trait::async_trait;
+use tokio::time::sleep;
 use tokio::time::Duration;
-use super::container::State;
 use super::Runtime;
-use super::config::Config;
-use async_trait::async_trait;
-use anyhow::Result;
+use super::config;
 
-#[derive(Clone)]
-pub struct Mock {
+#[derive(Debug, Clone)]
+pub struct TestRuntime {
     should_fail: bool,
-    state: Arc<Mutex<State>>,
 }
 
-impl Mock {
+impl TestRuntime {
     #[must_use]
-    pub fn new() -> Self {
-        println!("MockRuntime: 新規作成");
+    pub const fn new() -> Self {
         Self {
             should_fail: false,
-            state: Arc::new(Mutex::new(State::Created)),
         }
     }
 
     #[must_use]
-    pub fn with_failure() -> Self {
+    pub const fn with_failure() -> Self {
         Self {
             should_fail: true,
-            state: Arc::new(Mutex::new(State::Created)),
         }
     }
-
-    pub async fn status(&self) -> State {
-        self.state.lock().await.clone()
-    }
 }
 
-impl Default for Mock {
-    fn default() -> Self {
-        Self::new()
+#[async_trait]
+impl Runtime for TestRuntime {
+    async fn create(
+        &self,
+        image: &str,
+        command: &[String],
+        working_dir: &Path,
+        env_vars: &[String],
+    ) -> Result<String> {
+        if self.should_fail {
+            return Err(anyhow!("モックエラー: コンテナの作成に失敗しました"));
+        }
+        println!("Mock: Creating container with image: {}, command: {:?}, working_dir: {:?}, env_vars: {:?}",
+            image, command, working_dir, env_vars);
+        Ok("mock-container-id".to_string())
     }
-}
 
-#[async_trait]
-impl Runtime for Mock {
-    async fn run(&self, _config: &Config) -> Result<()> {
-        println!("MockRuntime: 実行開始");
-        {
-            let mut state = self.state.lock().await;
-            *state = State::Running;
+    async fn start(&self, container_id: &str) -> Result<()> {
+        if self.should_fail {
+            return Err(anyhow!("モックエラー: コンテナの起動に失敗しました"));
         }
+        println!("Mock: Starting container: {}", container_id);
+        Ok(())
+    }
 
-        tokio::time::sleep(Duration::from_millis(100)).await;
+    async fn stop(&self, container_id: &str) -> Result<()> {
+        if self.should_fail {
+            return Err(anyhow!("モックエラー: コンテナの停止に失敗しました"));
+        }
+        println!("Mock: Stopping container: {}", container_id);
+        Ok(())
+    }
 
+    async fn remove(&self, container_id: &str) -> Result<()> {
         if self.should_fail {
-            return Err(anyhow::anyhow!("モックエラー"));
+            return Err(anyhow!("モックエラー: コンテナの削除に失敗しました"));
         }
+        println!("Mock: Removing container: {}", container_id);
+        Ok(())
+    }
 
-        {
-            let mut state = self.state.lock().await;
-            *state = State::Completed;
+    async fn run(&self, config: &config::Config) -> Result<()> {
+        if self.should_fail {
+            return Err(anyhow!("モックエラー: コンテナの実行に失敗しました"));
         }
+        let prepared_config = config.prepare_image().await?;
+        println!("Mock: Running container with config: {:?}", prepared_config);
+
+        // 実行中の状態をシミュレート
+        sleep(Duration::from_millis(200)).await;
+
         Ok(())
     }
 
     fn box_clone(&self) -> Box<dyn Runtime> {
         Box::new(self.clone())
     }
+}
+
+impl Default for TestRuntime {
+    fn default() -> Self {
+        Self::new()
+    }
 } 
\ No newline at end of file
diff --git a/src/container/runtime/mod.rs b/src/container/runtime/mod.rs
index 4058603..286df0d 100644
--- a/src/container/runtime/mod.rs
+++ b/src/container/runtime/mod.rs
@@ -3,6 +3,7 @@ pub mod config;
 pub mod container;
 pub mod containerd;
 pub mod mock;
+pub mod orchestrator;
 
 pub use container::Container;
 pub use builder::Builder;
@@ -14,34 +15,19 @@ use std::path::Path;
 
 #[async_trait]
 pub trait Runtime: Send + Sync {
-    async fn run(&self, config: &self::config::Config) -> Result<()>;
-    
     async fn create(
         &self,
         image: &str,
         command: &[String],
         working_dir: &Path,
-        env_vars: &[String]
-    ) -> Result<String> {
-        let _ = (image, command, working_dir, env_vars);
-        unimplemented!("create is not implemented for this runtime")
-    }
-    
-    async fn start(&self, container_id: &str) -> Result<()> {
-        let _ = container_id;
-        unimplemented!("start is not implemented for this runtime")
-    }
-    
-    async fn stop(&self, container_id: &str) -> Result<()> {
-        let _ = container_id;
-        unimplemented!("stop is not implemented for this runtime")
-    }
-    
-    async fn remove(&self, container_id: &str) -> Result<()> {
-        let _ = container_id;
-        unimplemented!("remove is not implemented for this runtime")
-    }
-    
+        env_vars: &[String],
+    ) -> Result<String>;
+
+    async fn start(&self, container_id: &str) -> Result<()>;
+    async fn stop(&self, container_id: &str) -> Result<()>;
+    async fn remove(&self, container_id: &str) -> Result<()>;
+    async fn run(&self, config: &config::Config) -> Result<()>;
+
     fn box_clone(&self) -> Box<dyn Runtime>;
 }
 
diff --git a/src/container/runtime/orchestrator.rs b/src/container/runtime/orchestrator.rs
index 011a255..4d91ad6 100644
--- a/src/container/runtime/orchestrator.rs
+++ b/src/container/runtime/orchestrator.rs
@@ -2,42 +2,76 @@ use std::sync::Arc;
 use anyhow::{Result, anyhow};
 use tokio::sync::Mutex;
 use crate::container::{
-    communication::ContainerNetwork,
-    io::buffer::OutputBuffer,
+    communication::transport::Network,
+    io::buffer::Buffer,
 };
-use super::{container::Container, config::ContainerConfig};
+use super::{container::Container, config::Config, containerd::ContainerdRuntime, Runtime};
 
 pub struct ParallelExecutor {
-    network: Arc<ContainerNetwork>,
-    buffer: Arc<OutputBuffer>,
+    runtime: Arc<dyn Runtime>,
+    #[allow(dead_code)]
+    network: Arc<Network>,
+    #[allow(dead_code)]
+    buffer: Arc<Buffer>,
     containers: Arc<Mutex<Vec<Container>>>,
 }
 
 impl ParallelExecutor {
-    pub fn new() -> Self {
-        Self {
-            network: Arc::new(ContainerNetwork::new()),
-            buffer: Arc::new(OutputBuffer::new()),
-            containers: Arc::new(Mutex::new(Vec::new())),
-        }
+    /// 新しいオーケストレーターを作成します。
+    ///
+    /// # Returns
+    /// * `Ok(Self)` - オーケストレーターの作成に成功
+    /// * `Err(_)` - オーケストレーターの作成に失敗
+    ///
+    /// # Errors
+    /// * ランタイムの初期化に失敗した場合
+    pub async fn new() -> Result<Self> {
+        let runtime = Arc::new(ContainerdRuntime::new().await?);
+        Self::with_runtime(runtime)
     }
 
-    async fn add_container(&self, container: Container) -> Result<()> {
-        let mut containers = self.containers.lock().await;
-        containers.push(container);
-        Ok(())
+    /// 指定されたランタイムでオーケストレーターを作成します。
+    ///
+    /// # Arguments
+    /// * `runtime` - コンテナランタイム
+    ///
+    /// # Returns
+    /// * `Ok(Self)` - オーケストレーターの作成に成功
+    /// * `Err(_)` - オーケストレーターの作成に失敗
+    ///
+    /// # Errors
+    /// * ネットワークの初期化に失敗した場合
+    pub fn with_runtime(runtime: Arc<dyn Runtime>) -> Result<Self> {
+        Ok(Self {
+            runtime,
+            network: Arc::new(Network::new()),
+            buffer: Arc::new(Buffer::new()),
+            containers: Arc::new(Mutex::new(Vec::new())),
+        })
     }
 
-    pub async fn execute(&self, configs: Vec<ContainerConfig>) -> Result<()> {
+    /// コンテナを実行します。
+    ///
+    /// # Arguments
+    /// * `configs` - コンテナの設定のリスト
+    ///
+    /// # Returns
+    /// * `Ok(())` - すべてのコンテナの実行に成功
+    /// * `Err(_)` - いずれかのコンテナの実行に失敗
+    ///
+    /// # Errors
+    /// * コンテナの作成に失敗した場合
+    /// * コンテナの起動に失敗した場合
+    /// * コンテナの実行中にエラーが発生した場合
+    pub async fn execute(&self, configs: Vec<Config>) -> Result<()> {
         let mut handles = vec![];
         
         for config in configs {
-            let network = Arc::clone(&self.network);
-            let buffer = Arc::clone(&self.buffer);
+            let runtime = Arc::clone(&self.runtime);
             let containers_ref = Arc::clone(&self.containers);
             
             let handle = tokio::spawn(async move {
-                let container = Container::new(config, network, buffer).await?;
+                let container = Container::new(runtime, config);
                 
                 // コンテナの追加は最小限のロック時間で行う
                 {
@@ -71,6 +105,15 @@ impl ParallelExecutor {
         Ok(())
     }
 
+    /// コンテナをクリーンアップします。
+    ///
+    /// # Returns
+    /// * `Ok(())` - すべてのコンテナのクリーンアップに成功
+    /// * `Err(_)` - いずれかのコンテナのクリーンアップに失敗
+    ///
+    /// # Errors
+    /// * コンテナの停止に失敗した場合
+    /// * コンテナの削除に失敗した場合
     pub async fn cleanup(&self) -> Result<()> {
         let containers = {
             let mut containers = self.containers.lock().await;
@@ -78,9 +121,9 @@ impl ParallelExecutor {
         };
 
         let mut cleanup_errors = Vec::new();
-        for mut container in containers {
-            if let Err(e) = container.cleanup().await {
-                cleanup_errors.push(format!("コンテナのクリーンアップに失敗: {}", e));
+        for container in containers {
+            if let Err(e) = container.cancel().await {
+                cleanup_errors.push(format!("コンテナのクリーンアップに失敗: {e}"));
             }
         }
 
diff --git a/tests/container/mod.rs b/tests/container/mod.rs
index 078ead7..24e9157 100644
--- a/tests/container/mod.rs
+++ b/tests/container/mod.rs
@@ -8,7 +8,7 @@ mod tests {
     use cph::container::{
         runtime::{
             Builder,
-            mock::Mock,
+            mock::MockRuntime,
         },
         State,
     };
@@ -17,7 +17,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_container_creation() -> Result<()> {
-        let runtime = Arc::new(Mock::new());
+        let runtime = Arc::new(MockRuntime::new());
         let container = Builder::new()
             .with_id("test-container")
             .with_image("test-image")
@@ -30,7 +30,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_container_execution() -> Result<()> {
-        let runtime = Arc::new(Mock::new());
+        let runtime = Arc::new(MockRuntime::new());
         let container = Builder::new()
             .with_id("test-container")
             .with_image("test-image")
diff --git a/tests/container/orchestrator.rs b/tests/container/orchestrator.rs
index f938d52..b62ef2d 100644
--- a/tests/container/orchestrator.rs
+++ b/tests/container/orchestrator.rs
@@ -1,100 +1,55 @@
-use cph::container::Orchestrator;
-use cph::container::runtime::mock::Mock;
-use cph::container::runtime::Builder;
-use cph::container::{Message, MessageKind};
+use cph::container::runtime::orchestrator::ParallelExecutor;
+use cph::container::runtime::config::Config;
+use cph::container::runtime::mock::MockRuntime;
 use std::sync::Arc;
 use anyhow::Result;
+use std::path::PathBuf;
 
 #[tokio::test]
 async fn test_container_creation() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
-    let orchestrator = Orchestrator::new();
+    let runtime = Arc::new(MockRuntime::new());
+    let executor = ParallelExecutor::with_runtime(runtime).await?;
     
-    let container = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "python",
-        "test.py",
-        vec!["python".to_string(), "test.py".to_string()]
-    ).await?;
-
-    let container2 = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "rust",
-        "main.rs",
-        vec!["cargo".to_string(), "run".to_string()]
-    ).await?;
-
-    let container3 = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "python",
-        "test2.py",
-        vec!["python".to_string(), "test2.py".to_string()]
-    ).await?;
-
-    orchestrator.link(&container.id(), &container2.id()).await?;
-    orchestrator.link(&container2.id(), &container3.id()).await?;
-
-    let isolated = orchestrator.get_isolated_containers().await;
-    assert_eq!(isolated.len(), 0);
+    let configs = vec![
+        Config::new(
+            "test-python",
+            "python:3.9",
+            PathBuf::from("/workspace/test"),
+            vec!["python".to_string(), "test.py".to_string()],
+            None,
+        ),
+        Config::new(
+            "test-rust",
+            "rust:1.70",
+            PathBuf::from("/workspace/src"),
+            vec!["cargo".to_string(), "run".to_string()],
+            None,
+        ),
+    ];
+
+    executor.execute(configs).await?;
+    executor.cleanup().await?;
 
     Ok(())
 }
 
 #[tokio::test]
-async fn test_container_execution() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
-    let orchestrator = Orchestrator::new();
-    
-    let _container = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "python",
-        "test.py",
-        vec!["python".to_string(), "test.py".to_string()]
-    ).await?;
-
-    let _container2 = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "rust",
-        "main.rs",
-        vec!["cargo".to_string(), "run".to_string()]
-    ).await?;
-
-    orchestrator.run_all().await?;
-    orchestrator.wait_all().await?;
-
-    Ok(())
-}
-
-#[tokio::test]
-async fn test_message_handling() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
-    let orchestrator = Orchestrator::new();
-    
-    let container = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "python",
-        "test.py",
-        vec!["python".to_string(), "test.py".to_string()]
-    ).await?;
-
-    let container2 = orchestrator.add_container_with_builder(
-        Builder::new().with_runtime(runtime.clone()),
-        "rust",
-        "main.rs",
-        vec!["cargo".to_string(), "run".to_string()]
-    ).await?;
-
-    orchestrator.link(container.id(), container2.id()).await?;
-
-    orchestrator.send_message(Message::normal("通常メッセージ", container.id(), container2.id())).await?;
-    orchestrator.send_message(Message::system("システムメッセージ", container.id(), container2.id())).await?;
-    orchestrator.send_message(Message::error("エラーメッセージ", container.id(), container2.id())).await?;
-
-    let status = orchestrator.get_status_summary().await;
+async fn test_error_handling() -> Result<()> {
+    let runtime = Arc::new(MockRuntime::with_failure());
+    let executor = ParallelExecutor::with_runtime(runtime).await?;
     
-    assert_eq!(status.message_counts.get(&MessageKind::Normal).unwrap(), &1);
-    assert_eq!(status.message_counts.get(&MessageKind::System).unwrap(), &1);
-    assert_eq!(status.message_counts.get(&MessageKind::Error).unwrap(), &1);
+    let configs = vec![
+        Config::new(
+            "test-error",
+            "invalid-image",
+            PathBuf::from("/workspace/test"),
+            vec!["invalid".to_string(), "command".to_string()],
+            None,
+        ),
+    ];
+
+    let result = executor.execute(configs).await;
+    assert!(result.is_err());
 
     Ok(())
 } 
\ No newline at end of file
diff --git a/tests/container/runtime/mod.rs b/tests/container/runtime/mod.rs
index ba0139b..4dc4605 100644
--- a/tests/container/runtime/mod.rs
+++ b/tests/container/runtime/mod.rs
@@ -2,7 +2,7 @@ use anyhow::Result;
 use cph::container::{
     runtime::{
         Builder,
-        mock::Mock,
+        mock::MockRuntime,
     },
     State,
 };
@@ -10,7 +10,7 @@ use std::sync::Arc;
 
 #[tokio::test]
 async fn test_container_lifecycle() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
+    let runtime = Arc::new(MockRuntime::new());
     let container = Builder::new()
         .with_id("test-container")
         .with_image("test-image")
@@ -38,7 +38,7 @@ async fn test_container_lifecycle() -> Result<()> {
 
 #[tokio::test]
 async fn test_error_handling() -> Result<()> {
-    let runtime = Arc::new(Mock::with_failure());
+    let runtime = Arc::new(MockRuntime::with_failure());
     
     let container = Builder::new()
         .with_id("test-container")
@@ -59,7 +59,7 @@ async fn test_error_handling() -> Result<()> {
 
 #[tokio::test]
 async fn test_python_execution() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
+    let runtime = Arc::new(MockRuntime::new());
     
     let container = Builder::new()
         .with_id("test-python")
@@ -90,7 +90,7 @@ async fn test_python_execution() -> Result<()> {
 
 #[tokio::test]
 async fn test_rust_execution() -> Result<()> {
-    let runtime = Arc::new(Mock::new());
+    let runtime = Arc::new(MockRuntime::new());
     
     let container = Builder::new()
         .with_id("test-rust")
