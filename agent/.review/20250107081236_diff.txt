diff --git a/Cargo.toml b/Cargo.toml
index 1e0e2e4..f80d6de 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -51,7 +51,7 @@ assert_cmd = "2.0"
 predicates = "3.0"
 tempfile = "3.8"
 tokio-test = "0.4"
-mockall = "0.11"
+mockall = "0.12.1"
 wiremock = "0.5"
 serde_json = "1.0"
 
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 198aaa4..d3f04cb 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -6,13 +6,13 @@
 // - イミュータブルな設定値
 // - カスタムスキーマによるバリデーション
 // - 柔軟な型変換システム
-// - 設定変更の追跡
 
 use std::sync::Arc;
 use std::collections::HashMap;
-use std::time::SystemTime;
 use serde_yaml::Value;
 use regex::Regex;
+use std::path::Path;
+use std::fs;
 
 // 基本的な設定ノード
 #[derive(Clone, Debug)]
@@ -68,21 +68,6 @@ pub trait FromConfigValue: Sized {
 #[derive(Clone)]
 pub struct Config {
     root: Arc<ConfigNode>,
-    listeners: Arc<Vec<Arc<dyn ConfigListener>>>,
-    history: Arc<Vec<ConfigChange>>,
-}
-
-#[derive(Clone, Debug)]
-pub struct ConfigChange {
-    timestamp: SystemTime,
-    path: String,
-    old_value: Option<Arc<Value>>,
-    new_value: Arc<Value>,
-}
-
-// 設定変更通知のトレイト
-pub trait ConfigListener: Send + Sync {
-    fn on_change(&self, old: &ConfigNode, new: &ConfigNode);
 }
 
 // エラー型
@@ -92,6 +77,7 @@ pub enum ConfigError {
     TypeError { expected: &'static str, found: String },
     ValidationError { message: String },
     ValueError { message: String },
+    IoError(String),
 }
 
 pub type ConfigResult<T> = Result<T, ConfigError>;
@@ -109,18 +95,18 @@ impl ConfigNode {
         }
     }
 
-    pub fn as_typed<T: FromConfigValue>(&self) -> ConfigResult<T> {
-        T::from_config_value(&self.value)
+    pub fn with_schema(mut self, schema: ConfigSchema) -> Self {
+        Arc::make_mut(&mut self.metadata).schema = Some(Arc::new(schema));
+        self
     }
 
-    pub fn with_value(&self, value: Value) -> ConfigResult<Self> {
-        if let Some(schema) = &self.metadata.schema {
-            schema.validate(&value)?;
-        }
-        Ok(Self {
-            value: Arc::new(value),
-            metadata: self.metadata.clone(),
-        })
+    pub fn with_description(mut self, description: String) -> Self {
+        Arc::make_mut(&mut self.metadata).description = Some(description);
+        self
+    }
+
+    pub fn as_typed<T: FromConfigValue>(&self) -> ConfigResult<T> {
+        T::from_config_value(&self.value)
     }
 }
 
@@ -129,33 +115,51 @@ impl Config {
     pub fn new(root_value: Value) -> Self {
         Self {
             root: Arc::new(ConfigNode::new(root_value, String::from("root"))),
-            listeners: Arc::new(Vec::new()),
-            history: Arc::new(Vec::new()),
-        }
-    }
-
-    pub fn with_listener<L: ConfigListener + 'static>(self, listener: L) -> Self {
-        let mut listeners = (*self.listeners).clone();
-        listeners.push(Arc::new(listener));
-        Self {
-            listeners: Arc::new(listeners),
-            ..self
         }
     }
 
-    fn notify_listeners(&self, old: &ConfigNode, new: &ConfigNode) {
-        for listener in self.listeners.iter() {
-            listener.on_change(old, new);
-        }
+    pub fn load_from_file<P: AsRef<Path>>(path: P) -> ConfigResult<Self> {
+        let contents = fs::read_to_string(path)
+            .map_err(|e| ConfigError::IoError(e.to_string()))?;
+        let value = serde_yaml::from_str(&contents)
+            .map_err(|e| ConfigError::ValueError { message: e.to_string() })?;
+        Ok(Self::new(value))
     }
 
     pub fn get<T: FromConfigValue>(&self, path: &str) -> ConfigResult<T> {
-        self.get_node(path).and_then(|node| node.as_typed())
+        self.get_node(path)?.as_typed()
     }
 
     fn get_node(&self, path: &str) -> ConfigResult<ConfigNode> {
-        self.resolve_path(path)
-            .map(|value| ConfigNode::new(value, path.to_string()))
+        let value = self.resolve_path(path)?;
+        Ok(ConfigNode::new(value, path.to_string()))
+    }
+
+    fn resolve_path(&self, path: &str) -> ConfigResult<Value> {
+        if path == "root" {
+            return Ok((*self.root.value).clone());
+        }
+
+        let parts: Vec<&str> = path.split('.').collect();
+        let mut current = &*self.root.value;
+
+        for part in parts {
+            match current {
+                Value::Mapping(map) => {
+                    current = map.get(&Value::String(part.to_string()))
+                        .ok_or_else(|| ConfigError::PathNotFound(path.to_string()))?;
+                }
+                Value::Sequence(seq) => {
+                    let index = part.parse::<usize>()
+                        .map_err(|_| ConfigError::PathNotFound(path.to_string()))?;
+                    current = seq.get(index)
+                        .ok_or_else(|| ConfigError::PathNotFound(path.to_string()))?;
+                }
+                _ => return Err(ConfigError::PathNotFound(path.to_string())),
+            }
+        }
+
+        Ok(current.clone())
     }
 }
 
@@ -166,94 +170,67 @@ impl ConfigAccess for Config {
     }
 
     fn get_all(&self, pattern: &str) -> ConfigResult<Vec<ConfigNode>> {
-        self.find_matching_paths(pattern)
+        let regex = Regex::new(pattern)
+            .map_err(|e| ConfigError::ValueError { message: e.to_string() })?;
+
+        Ok(self.find_matching_paths(pattern)
             .into_iter()
-            .map(|path| self.get(&path))
-            .collect()
+            .filter_map(|path| {
+                if regex.is_match(&path) {
+                    self.get_node(&path).ok()
+                } else {
+                    None
+                }
+            })
+            .collect())
     }
 
     fn exists(&self, path: &str) -> bool {
-        self.resolve_path(path).is_ok()
+        self.get_node(path).is_ok()
     }
 }
 
-// 基本型のFromConfigValue実装
+// 基本的な型変換の実装
 impl FromConfigValue for String {
     fn from_config_value(value: &Value) -> ConfigResult<Self> {
         match value {
             Value::String(s) => Ok(s.clone()),
-            Value::Number(n) => Ok(n.to_string()),
-            Value::Bool(b) => Ok(b.to_string()),
             _ => Err(ConfigError::TypeError {
-                expected: "string-convertible",
+                expected: "string",
                 found: value.type_str().to_string(),
             }),
         }
     }
 }
 
-impl FromConfigValue for bool {
+impl FromConfigValue for i64 {
     fn from_config_value(value: &Value) -> ConfigResult<Self> {
         match value {
-            Value::Bool(b) => Ok(*b),
-            Value::String(s) => match s.to_lowercase().as_str() {
-                "true" | "yes" | "on" | "1" => Ok(true),
-                "false" | "no" | "off" | "0" => Ok(false),
-                _ => Err(ConfigError::ValueError {
-                    message: format!("無効な真偽値: {}", s),
-                }),
-            },
+            Value::Number(n) => n.as_i64().ok_or_else(|| ConfigError::TypeError {
+                expected: "integer",
+                found: "non-integer number".to_string(),
+            }),
             _ => Err(ConfigError::TypeError {
-                expected: "boolean",
+                expected: "number",
                 found: value.type_str().to_string(),
             }),
         }
     }
 }
 
-impl FromConfigValue for i64 {
+impl FromConfigValue for bool {
     fn from_config_value(value: &Value) -> ConfigResult<Self> {
         match value {
-            Value::Number(n) => n.as_i64().ok_or_else(|| ConfigError::ValueError {
-                message: "数値が範囲外です".to_string(),
-            }),
-            Value::String(s) => s.parse().map_err(|_| ConfigError::ValueError {
-                message: format!("無効な数値: {}", s),
-            }),
+            Value::Bool(b) => Ok(*b),
             _ => Err(ConfigError::TypeError {
-                expected: "number",
+                expected: "boolean",
                 found: value.type_str().to_string(),
             }),
         }
     }
 }
 
-// ヘルパーメソッド
-impl Config {
-    fn resolve_path(&self, path: &str) -> ConfigResult<Value> {
-        let parts: Vec<&str> = path.split('.').collect();
-        let mut current = self.root.value.clone();
-        
-        for part in parts {
-            match &*current {
-                Value::Mapping(map) => {
-                    current = Arc::new(map.get(part).ok_or_else(|| ConfigError::PathNotFound(
-                        path.to_string(),
-                    ))?.clone());
-                }
-                _ => return Err(ConfigError::PathNotFound(path.to_string())),
-            }
-        }
-        
-        Ok((*current).clone())
-    }
-
-    fn find_matching_paths(&self, _pattern: &str) -> Vec<String> {
-        // TODO: 実装
-        vec![]
-    }
-}
-
+// ヘルパートレイト
 pub trait ValueExt {
     fn type_str(&self) -> &'static str;
 }
@@ -261,13 +238,13 @@ pub trait ValueExt {
 impl std::fmt::Display for ConfigError {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            ConfigError::PathNotFound(path) => write!(f, "パスが見つかりません: {}", path),
-            ConfigError::TypeError { expected, found } => 
-                write!(f, "型エラー: 期待される型 {}, 実際の型 {}", expected, found),
-            ConfigError::ValidationError { message } => 
-                write!(f, "バリデーションエラー: {}", message),
-            ConfigError::ValueError { message } => 
-                write!(f, "値エラー: {}", message),
+            ConfigError::PathNotFound(path) => write!(f, "Path not found: {}", path),
+            ConfigError::TypeError { expected, found } => {
+                write!(f, "Type error: expected {}, found {}", expected, found)
+            }
+            ConfigError::ValidationError { message } => write!(f, "Validation error: {}", message),
+            ConfigError::ValueError { message } => write!(f, "Value error: {}", message),
+            ConfigError::IoError(message) => write!(f, "IO error: {}", message),
         }
     }
 }
@@ -289,13 +266,13 @@ impl ValueExt for Value {
 impl ConfigSchema {
     pub fn validate(&self, value: &Value) -> ConfigResult<()> {
         match self {
-            ConfigSchema::Primitive(ptype) => match (ptype, value) {
+            ConfigSchema::Primitive(primitive_type) => match (primitive_type, value) {
                 (PrimitiveType::String, Value::String(_)) => Ok(()),
                 (PrimitiveType::Number, Value::Number(_)) => Ok(()),
                 (PrimitiveType::Boolean, Value::Bool(_)) => Ok(()),
                 (PrimitiveType::Null, Value::Null) => Ok(()),
                 _ => Err(ConfigError::TypeError {
-                    expected: ptype.type_str(),
+                    expected: primitive_type.type_str(),
                     found: value.type_str().to_string(),
                 }),
             },
@@ -311,12 +288,12 @@ impl ConfigSchema {
                         found: value.type_str().to_string(),
                     })
                 }
-            },
-            ConfigSchema::Object(fields) => {
+            }
+            ConfigSchema::Object(properties) => {
                 if let Value::Mapping(map) = value {
-                    for (key, schema) in fields {
-                        if let Some(field_value) = map.get(key) {
-                            schema.validate(field_value)?;
+                    for (key, schema) in properties {
+                        if let Some(value) = map.get(&Value::String(key.clone())) {
+                            schema.validate(value)?;
                         }
                     }
                     Ok(())
@@ -326,7 +303,7 @@ impl ConfigSchema {
                         found: value.type_str().to_string(),
                     })
                 }
-            },
+            }
             ConfigSchema::Union(schemas) => {
                 for schema in schemas {
                     if schema.validate(value).is_ok() {
@@ -334,10 +311,10 @@ impl ConfigSchema {
                     }
                 }
                 Err(ConfigError::ValidationError {
-                    message: "値がユニオン型のいずれにも一致しません".to_string(),
+                    message: "Value does not match any schema in union".to_string(),
                 })
-            },
-            ConfigSchema::Custom(schema) => schema.validate(value),
+            }
+            ConfigSchema::Custom(custom) => custom.validate(value),
         }
     }
 }
@@ -361,13 +338,41 @@ impl FromConfigValue for Value {
 
 impl FromConfigValue for ConfigNode {
     fn from_config_value(value: &Value) -> ConfigResult<Self> {
-        Ok(ConfigNode {
-            value: Arc::new(value.clone()),
-            metadata: Arc::new(ConfigMetadata {
-                path: String::new(),
-                schema: None,
-                description: None,
-            }),
-        })
+        Ok(ConfigNode::new(value.clone(), String::new()))
+    }
+}
+
+// 設定を探すためのヘルパーメソッド
+impl Config {
+    fn find_matching_paths(&self, _pattern: &str) -> Vec<String> {
+        let mut paths = Vec::new();
+        self.collect_paths(&self.root.value, "root", &mut paths);
+        paths
+    }
+
+    fn collect_paths(&self, value: &Value, current_path: &str, paths: &mut Vec<String>) {
+        paths.push(current_path.to_string());
+
+        match value {
+            Value::Mapping(map) => {
+                for (key, value) in map {
+                    if let Value::String(key_str) = key {
+                        let new_path = if current_path == "root" {
+                            key_str.clone()
+                        } else {
+                            format!("{}.{}", current_path, key_str)
+                        };
+                        self.collect_paths(value, &new_path, paths);
+                    }
+                }
+            }
+            Value::Sequence(seq) => {
+                for (i, value) in seq.iter().enumerate() {
+                    let new_path = format!("{}.{}", current_path, i);
+                    self.collect_paths(value, &new_path, paths);
+                }
+            }
+            _ => {}
+        }
     }
 } 
\ No newline at end of file
diff --git a/src/config/tests.rs b/src/config/tests.rs
index 19af9bf..bfc66f1 100644
--- a/src/config/tests.rs
+++ b/src/config/tests.rs
@@ -25,7 +25,7 @@ mod tests {
     fn test_basic_config_access() {
         let config = create_test_config();
         
-        // 元の記法での設定値の取得
+        // 基本的な設定値の取得
         let solution: String = config.get("system.source_file.solution").unwrap();
         assert_eq!(solution, "main.rs");
 
@@ -36,9 +36,8 @@ mod tests {
         assert!(auto_yes);
 
         // ConfigNodeを介した設定値の取得
-        let solution = config.get_node("system.source_file.solution")
-            .and_then(|node| node.as_typed::<String>())
-            .unwrap();
+        let solution_node = config.get_node("system.source_file.solution").unwrap();
+        let solution: String = solution_node.as_typed().unwrap();
         assert_eq!(solution, "main.rs");
     }
 
@@ -58,67 +57,84 @@ mod tests {
                     }
                 }
                 Err(ConfigError::ValidationError {
-                    message: "タイムアウトは1から10秒の間である必要があります".to_string(),
+                    message: "Timeout must be between 1 and 10 seconds".to_string(),
                 })
             }
 
             fn describe(&self) -> String {
-                "タイムアウト値の検証".to_string()
+                "Timeout value validation".to_string()
             }
         }
 
-        // 有効な値でのテスト
-        let node = config.get("system.docker.timeout_seconds").unwrap();
-        let schema = ConfigSchema::Custom(Arc::new(TimeoutSchema));
-        assert!(node.with_value(Value::Number(2.into())).is_ok());
-
-        // 無効な値でのテスト
-        assert!(node.with_value(Value::Number(11.into())).is_err());
+        // スキーマを持つ新しいノードの作成
+        let node = ConfigNode::new(Value::Number(2.into()), "timeout".to_string())
+            .with_schema(ConfigSchema::Custom(Arc::new(TimeoutSchema)));
+
+        // スキーマによる検証
+        assert!(ConfigSchema::Custom(Arc::new(TimeoutSchema))
+            .validate(&Value::Number(2.into()))
+            .is_ok());
+        assert!(ConfigSchema::Custom(Arc::new(TimeoutSchema))
+            .validate(&Value::Number(11.into()))
+            .is_err());
     }
 
     #[test]
-    fn test_config_change_notification() {
-        use std::sync::atomic::{AtomicBool, Ordering};
-        use std::sync::Arc;
+    fn test_type_conversion() {
+        let config = create_test_config();
 
-        struct TestListener {
-            called: Arc<AtomicBool>,
-        }
+        // 文字列型への変換
+        let solution: String = config.get("system.source_file.solution").unwrap();
+        assert_eq!(solution, "main.rs");
 
-        impl ConfigListener for TestListener {
-            fn on_change(&self, _old: &ConfigNode, _new: &ConfigNode) {
-                self.called.store(true, Ordering::SeqCst);
-            }
-        }
+        // 数値型への変換
+        let timeout: i64 = config.get("system.docker.timeout_seconds").unwrap();
+        assert_eq!(timeout, 2);
 
-        let called = Arc::new(AtomicBool::new(false));
-        let config = create_test_config()
-            .with_listener(TestListener { called: called.clone() });
+        // 真偽値への変換
+        let auto_yes: bool = config.get("system.submit.auto_yes").unwrap();
+        assert!(auto_yes);
 
-        // 設定値の変更
-        if let Ok(node) = config.get("system.docker.timeout_seconds") {
-            let _new_node = node.with_value(Value::Number(3.into())).unwrap();
-            assert!(called.load(Ordering::SeqCst));
-        }
+        // 型変換エラーのテスト
+        let result: ConfigResult<bool> = config.get("system.source_file.solution");
+        assert!(result.is_err());
     }
 
     #[test]
-    fn test_type_conversion() {
+    fn test_path_resolution() {
         let config = create_test_config();
 
-        // 文字列への変換テスト
-        let node = config.get("system.docker.timeout_seconds").unwrap();
-        let str_val: String = node.as_typed().unwrap();
-        assert_eq!(str_val, "2");
+        // 存在するパスの解決
+        assert!(config.exists("system.docker.timeout_seconds"));
+        assert!(config.exists("languages.rust.aliases"));
+
+        // 存在しないパスの解決
+        assert!(!config.exists("nonexistent.path"));
+        assert!(!config.exists("system.invalid"));
+    }
+
+    #[test]
+    fn test_metadata() {
+        // メタデータを持つノードの作成
+        let node = ConfigNode::new(Value::String("test".to_string()), "test".to_string())
+            .with_description("Test configuration value".to_string())
+            .with_schema(ConfigSchema::Primitive(PrimitiveType::String));
+
+        // メタデータの検証
+        assert!(node.metadata.description.is_some());
+        assert!(node.metadata.schema.is_some());
+    }
+
+    #[test]
+    fn test_pattern_matching() {
+        let config = create_test_config();
 
-        // 真偽値への変換テスト
-        let node = config.get("system.submit.auto_yes").unwrap();
-        let bool_val: bool = node.as_typed().unwrap();
-        assert!(bool_val);
+        // system.docker.*のパターンマッチング
+        let docker_settings = config.get_all("system\\.docker\\..*").unwrap();
+        assert_eq!(docker_settings.len(), 2); // timeout_seconds と memory_limit_mb
 
-        // 数値への変換テスト
-        let node = config.get("system.docker.timeout_seconds").unwrap();
-        let num_val: i64 = node.as_typed().unwrap();
-        assert_eq!(num_val, 2);
+        // 存在しないパターンのマッチング
+        let empty_result = config.get_all("nonexistent\\..*").unwrap();
+        assert!(empty_result.is_empty());
     }
 } 
\ No newline at end of file
diff --git a/src/contest/parse.rs b/src/contest/parse.rs
index f57832f..862fcc3 100644
--- a/src/contest/parse.rs
+++ b/src/contest/parse.rs
@@ -172,6 +172,20 @@ impl NameResolver {
 
         Ok((command_type, args))
     }
+
+    pub fn resolve(&self, input: &str) -> Result<ResolvedCommand, ParseError> {
+        if input.is_empty() {
+            return Err(ParseError::EmptyCommand);
+        }
+
+        let tokens: Vec<&str> = input.split_whitespace().collect();
+        let (command_type, args) = self.parse_command(&tokens)?;
+
+        Ok(ResolvedCommand {
+            commands: vec![command_type.name],
+            args,
+        })
+    }
 }
 
 #[cfg(test)]
