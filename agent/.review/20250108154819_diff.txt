diff --git a/src/bin/cph.rs b/src/bin/cph.rs
index d36e5a9..1c3e1eb 100644
--- a/src/bin/cph.rs
+++ b/src/bin/cph.rs
@@ -1,5 +1,5 @@
 use std::env;
-use anyhow::{Context, Result};
+use anyhow::Result;
 use cph::config::Config;
 
 fn main() -> Result<()> {
@@ -8,7 +8,6 @@ fn main() -> Result<()> {
         return Ok(());
     }
 
-    let _config = Config::load_from_file("src/config/config.yaml")
-        .with_context(|| "src/config/config.yamlの読み込みに失敗しました")?;
+    let _config = Config::load()?;
     Ok(())
 }
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 9285a7d..437158c 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -7,686 +7,146 @@
 // - カスタムスキーマによるバリデーション
 // - 柔軟な型変換システム
 
-use std::sync::Arc;
-use std::collections::HashMap;
-use serde_yaml::Value;
-use regex::Regex;
 use std::path::Path;
 use std::fs;
-use anyhow::{Error, Result, Context as _, anyhow};
+use std::collections::HashMap;
+use anyhow::{Result, Context};
+use serde::{Deserialize, Serialize};
 
-// 基本的な設定ノード
-#[derive(Clone, PartialEq, Eq, Debug)]
-pub struct Node {
-    value: Value,
-    metadata: Metadata,
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct Config {
+    pub system: SystemConfig,
+    pub languages: LanguagesConfig,
 }
 
-#[derive(Clone, PartialEq, Eq, Debug)]
-pub struct Metadata {
-    path: String,
-    description: Option<String>,
-    schema: Option<Schema>,
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct SystemConfig {
+    pub browser: String,
+    pub editors: Vec<String>,
+    pub docker: DockerConfig,
 }
 
-#[derive(Clone, PartialEq, Eq)]
-pub struct SchemaMetadata {
-    description: Option<String>,
-    required: bool,
-    children: HashMap<String, SchemaMetadata>,
-    schema_type: SchemaType,
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct DockerConfig {
+    pub timeout_seconds: u32,
+    pub memory_limit_mb: u32,
+    pub mount_point: String,
 }
 
-#[derive(Clone, PartialEq, Eq)]
-pub enum SchemaType {
-    String,
-    Number,
-    Boolean,
-    Object(HashMap<String, Schema>),
-    Array(Box<Schema>),
-    Custom(String),
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct LanguagesConfig {
+    pub default: String,
+    #[serde(rename = "_base")]
+    pub base: LanguageBaseConfig,
 }
 
-pub trait SchemaValidator: Send + Sync + std::fmt::Debug {
-    /// 値を検証します
-    /// 
-    /// # Errors
-    /// - 値が無効な場合
-    /// - スキーマの制約に違反している場合
-    fn validate(&self, value: &Value) -> Result<()>;
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct LanguageBaseConfig {
+    pub compile: Vec<String>,
+    pub run: Vec<String>,
+    pub runner: RunnerConfig,
+    pub templates: TemplatesConfig,
+    pub contest_dir: ContestDirConfig,
+    pub active_contest_yaml: String,
+    pub test: TestConfig,
 }
 
-pub trait Access {
-    /// 指定されたパスの設定値を取得します。
-    /// 
-    /// # Errors
-    /// - パスが存在しない場合にエラーを返します。
-    /// - パスの形式が無効な場合にエラーを返します。
-    fn get(&self, path: &str) -> Result<Arc<Node>>;
-
-    /// 指定されたパターンに一致する全ての設定値を取得します。
-    /// 
-    /// # Errors
-    /// - パターンが無効な正規表現の場合にエラーを返します。
-    /// - パスの形式が無効な場合にエラーを返します。
-    fn get_all(&self, pattern: &str) -> Result<Vec<Arc<Node>>>;
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct RunnerConfig {
+    pub compile_dir: String,
+    pub require_files: Vec<String>,
+    pub env_vars: Vec<String>,
+    pub docker: DockerConfig,
+}
 
-    /// 指定されたパスの設定値が存在するかどうかを確認します。
-    ///
-    /// # Returns
-    /// * `bool` - 設定値が存在する場合はtrue
-    fn exists(&self, path: &str) -> bool;
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct TemplatesConfig {
+    pub patterns: HashMap<String, String>,
+    pub directory: String,
 }
 
-// スキーマ定義
-#[derive(Clone, Debug, PartialEq, Eq)]
-pub enum Schema {
-    Primitive(PrimitiveType),
-    Array(Box<Schema>),
-    Object(HashMap<String, Schema>),
-    Union(Vec<Schema>),
-    Custom(Arc<dyn CustomSchema>),
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct ContestDirConfig {
+    pub active: String,
+    pub storage: String,
+    pub template: String,
 }
 
-#[derive(Clone, Debug, PartialEq, Eq)]
-pub enum PrimitiveType {
-    String,
-    Number,
-    Boolean,
-    Null,
+#[allow(clippy::module_name_repetitions)]
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct TestConfig {
+    pub dir: String,
 }
 
-// カスタムスキーマのトレイト
-pub trait CustomSchema: Send + Sync + std::fmt::Debug {
-    /// カスタムスキーマの検証を行います。
+impl Config {
+    /// 設定ファイルから設定を読み込みます
     /// 
     /// # Errors
     /// 
-    /// 値がスキーマに適合しない場合にエラーを返します。
-    fn validate(&self, value: &Value) -> Result<()>;
-    
-    fn describe(&self) -> String;
-    fn eq(&self, other: &dyn CustomSchema) -> bool;
-}
-
-impl PartialEq for dyn CustomSchema {
-    fn eq(&self, other: &Self) -> bool {
-        self.eq(other)
-    }
-}
-
-impl Eq for dyn CustomSchema {}
-
-// インの設定構造体
-#[derive(Clone, PartialEq, Eq, Debug)]
-pub struct Config {
-    root: Arc<Node>,
-}
-
-// ConfigNodeの実装
-#[allow(dead_code)]
-impl Node {
-    /// 新しい設定ノードを作成します
-    #[must_use]
-    pub const fn new(value: Value, path: String) -> Self {
-        Self {
-            value,
-            metadata: Metadata {
-                path,
-                description: None,
-                schema: None,
-            },
-        }
+    /// - 設定ファイルが存在しない場合
+    /// - 設定ファイルの形式が不正な場合
+    pub fn load() -> Result<Self> {
+        let config_path = Path::new("src/config/config.yaml");
+        let config_str = fs::read_to_string(config_path)
+            .with_context(|| format!("設定ファイルの読み込みに失敗: {}", config_path.display()))?;
+        let config: Self = serde_yaml::from_str(&config_str)
+            .with_context(|| "設定ファイルのパースに失敗")?;
+        Ok(config)
     }
 
-    /// スキーマを設定します
+    /// ブラウザの設定を取得します
     #[must_use]
-    pub fn with_schema(self, schema: Schema) -> Self {
-        Self {
-            value: self.value,
-            metadata: Metadata {
-                path: self.metadata.path,
-                schema: Some(schema),
-                description: self.metadata.description,
-            },
-        }
+    pub fn browser(&self) -> &str {
+        &self.system.browser
     }
 
-    /// 説明を設定します
+    /// エディタの設定を取得します
     #[must_use]
-    pub fn with_description(self, description: String) -> Self {
-        Self {
-            value: self.value,
-            metadata: Metadata {
-                path: self.metadata.path,
-                schema: self.metadata.schema,
-                description: Some(description),
-            },
-        }
-    }
-
-    /// 設定値を型付きの値として取得します。
-    /// 
-    /// # Errors
-    /// - 値の型が要求された型と一致しない場合にエラーを返します。
-    /// - 値の変換に失敗した場合にエラーを返します。
-    pub fn as_typed<T: FromConfigValue>(&self) -> Result<T> {
-        T::from_config_value(&self.value)
+    pub fn editors(&self) -> &[String] {
+        &self.system.editors
     }
 
+    /// Dockerの設定を取得します
     #[must_use]
-    pub fn as_str(&self) -> Option<&str> {
-        match &self.value {
-            Value::String(s) => Some(s),
-            _ => None,
-        }
+    pub const fn docker(&self) -> &DockerConfig {
+        &self.system.docker
     }
 
+    /// デフォルトの言語を取得します
     #[must_use]
-    pub fn as_i64(&self) -> Option<i64> {
-        match &self.value {
-            Value::Number(n) => n.as_i64(),
-            _ => None,
-        }
+    pub fn default_language(&self) -> &str {
+        &self.languages.default
     }
 
+    /// テストディレクトリを取得します
     #[must_use]
-    pub const fn as_bool(&self) -> Option<bool> {
-        match &self.value {
-            Value::Bool(b) => Some(*b),
-            _ => None,
-        }
+    pub fn test_dir(&self) -> String {
+        self.languages.base.test.dir.clone()
     }
 
+    /// アクティブなコンテストのディレクトリを取得します
     #[must_use]
-    pub const fn as_mapping(&self) -> Option<&serde_yaml::Mapping> {
-        match &self.value {
-            Value::Mapping(m) => Some(m),
-            _ => None,
-        }
+    pub fn active_contest_dir(&self) -> String {
+        self.languages.base.contest_dir.active.clone()
     }
 
+    /// コンテストのテンプレートディレクトリを取得します
     #[must_use]
-    pub const fn as_sequence(&self) -> Option<&Vec<Value>> {
-        match &self.value {
-            Value::Sequence(s) => Some(s),
-            _ => None,
-        }
-    }
-
-    /// キーを文字列として取得します。
-    /// 
-    /// # Errors
-    /// - キーが存在しない場合にエラーを返します。
-    pub fn key(&self) -> Result<String> {
-        Ok(self.metadata.path.clone())
-    }
-
-    fn get_from_map(&self, parts: &[String]) -> Result<Arc<Self>> {
-        match &self.value {
-            Value::Mapping(map) => {
-                let part = parts.first().ok_or_else(|| anyhow!("無効なパス"))?;
-                let value = map.get(Value::String(part.to_string()))
-                    .ok_or_else(|| anyhow!("パスが見つかりません"))?;
-                if parts.len() == 1 {
-                    Ok(Arc::new(Self::new(value.clone(), part.clone())))
-                } else {
-                    let node = Self::new(value.clone(), part.clone());
-                    node.get_from_map(&parts[1..])
-                }
-            }
-            _ => Err(anyhow!("無効なパス")),
-        }
+    pub fn contest_template_dir(&self) -> String {
+        self.languages.base.contest_dir.template.clone()
     }
 
-    fn get_all_from_map(&self, pattern: &Regex, path: &str) -> Result<Vec<Arc<Self>>> {
-        match &self.value {
-            Value::Mapping(map) => {
-                let mut result = Vec::new();
-                for (key, value) in map {
-                    if let Value::String(key_str) = key {
-                        if pattern.is_match(key_str) {
-                            result.push(Arc::new(Self::new(value.clone(), key_str.clone())));
-                        }
-                        if let Value::Mapping(_) = value {
-                            let node = Self::new(value.clone(), key_str.clone());
-                            let mut sub_result = node.get_all_from_map(pattern, &format!("{path}.{key_str}"))?;
-                            result.append(&mut sub_result);
-                        }
-                    }
-                }
-                Ok(result)
-            }
-            _ => Ok(Vec::new()),
-        }
-    }
-}
-
-// Configの実装
-impl Config {
+    /// コンテストのストレージディレクトリを取得します
     #[must_use]
-    pub fn new(root_value: Value) -> Self {
-        Self {
-            root: Arc::new(Node::new(root_value, String::from("root"))),
-        }
-    }
-
-    /// ファイルから設定を読み込みます。
-    /// 
-    /// # Errors
-    /// - ファイルが存在しない場合にエラーを返します。
-    /// - ファイルの形式が無効な場合にエラーを返します。
-    /// - ファイルの読み込みに失敗した場合にエラーを返します。
-    /// 
-    /// # Panics
-    /// - パスが親ディレクトリを持っていない場合にパニックします。
-    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
-        let contents = fs::read_to_string(&path)
-            .with_context(|| format!("設定ファイルの読み込みに失敗: {}", path.as_ref().display()))?;
-        
-        // メイン設定を読み込む
-        let mut value = serde_yaml::from_str(&contents)
-            .with_context(|| "YAMLのパースに失敗しました")?;
-
-        // commands.yamlを読み込む
-        let commands_path = path.as_ref().parent()
-            .expect("パスは親ディレクトリを持っている必要があります")
-            .join("commands.yaml");
-        if commands_path.exists() {
-            let commands_contents = fs::read_to_string(&commands_path)
-                .with_context(|| format!("コマンド設定ファイルの読み込みに失敗: {}", commands_path.display()))?;
-            let commands_value: Value = serde_yaml::from_str(&commands_contents)
-                .with_context(|| "コマンド設定のパースに失敗しました")?;
-
-            // メイン設定にコマンド設定をマージ
-            if let Value::Mapping(ref mut map) = value {
-                if let Value::Mapping(commands_map) = commands_value {
-                    map.extend(commands_map);
-                }
-            }
-        }
-
-        Ok(Self::new(value))
-    }
-
-    /// 指定されたパスの設定値を型付きで取得します。
-    /// 
-    /// # Errors
-    /// - パスが存在しない場合にエラーを返します。
-    /// - 値の型が要求された型と一致しない場合にエラーを返します。
-    pub fn get<T: FromConfigValue>(&self, path: &str) -> Result<T> {
-        self.get_node(path).and_then(|node| node.as_typed())
-    }
-
-    /// 指定されたパスの設定ノードを取得します。
-    /// 
-    /// # Errors
-    /// - パスが存在しない場合にエラーを返します。
-    pub fn get_node(&self, path: &str) -> Result<Arc<Node>> {
-        if path.is_empty() {
-            return Ok(self.root.clone());
-        }
-
-        let parts: Vec<&str> = path.split('.').collect();
-        let mut current = self.root.clone();
-
-        for part in parts {
-            match current.as_mapping() {
-                Some(map) => {
-                    let value = map.get(Value::String(part.to_string()))
-                        .ok_or_else(|| anyhow!("設定項目が見つかりません: {}", path))?;
-                    current = value.as_node()
-                        .ok_or_else(|| anyhow!("無効な設定値です: {}", path))?;
-                }
-                None => return Err(anyhow!("無効な設定値です: {}", path)),
-            }
-        }
-        Ok(current)
-    }
-
-    fn resolve_path(&self, path: &str) -> Result<Value> {
-        if path == "root" {
-            return Ok(self.root.value.clone());
-        }
-
-        let parts: Vec<&str> = path.split('.').collect();
-        let mut current = &self.root.value;
-
-        for part in parts {
-            match current {
-                Value::Mapping(map) => {
-                    current = map.get(Value::String(part.to_string()))
-                        .with_context(|| format!("パス '{path}'が見つかりません"))?;
-                }
-                Value::Sequence(seq) => {
-                    let index = part.parse::<usize>()
-                        .with_context(|| format!("無効なインデックス '{part}' (パス: {path})"))?;
-                    current = seq.get(index)
-                        .with_context(|| format!("インデックス {index} が範囲外です (パス: {path})"))?;
-                }
-                _ => return Err(Error::msg(format!("無効なパス: {path}"))),
-            }
-        }
-
-        Ok(current.clone())
-    }
-
-    /// 指定されたパスの設定値を型付きで取得します。
-    /// 
-    /// # Errors
-    /// - パスが存在しない場合にエラーを返します。
-    /// - 値のシリアライズに失敗した場合にエラーを返します。
-    pub fn get_typed<T: serde::de::DeserializeOwned>(&self, path: &str) -> Result<T> {
-        let value = self.resolve_path(path)?;
-        serde_yaml::from_value(value).map_err(|e| anyhow::anyhow!("型変換に失敗しました: {}", e))
-    }
-
-    /// 指定されたパターンに一致する全ての設定値を取得します。
-    /// 
-    /// # Errors
-    /// - パターンが無効な正規表現の場合にエラーを返します。
-    pub fn get_all(&self, pattern: &str) -> Result<Vec<Arc<Node>>> {
-        let regex = Regex::new(pattern)
-            .with_context(|| format!("無効な正規表現パターン: {pattern}"))?;
-
-        Ok(self.find_matching_paths(pattern)
-            .into_iter()
-            .filter_map(|path| {
-                if regex.is_match(&path) {
-                    self.get_node(&path).ok()
-                } else {
-                    None
-                }
-            })
-            .collect())
-    }
-}
-
-// ConfigAccessの実装
-impl Access for Config {
-    /// 指定されたパスの設定値を取得します。
-    /// 
-    /// # Errors
-    /// - パスが存在しない場合にエラーを返します。
-    /// - パスの形式が無効な場合にエラーを返します。
-    fn get(&self, path: &str) -> Result<Arc<Node>> {
-        self.get_node(path)
-    }
-
-    /// 指定されたパターンに一致する全ての設定値を取得します。
-    /// 
-    /// # Errors
-    /// - パターンが無効な正規表現の場合にエラーを返します。
-    /// - パスの形式が無効な場合にエラーを返します。
-    fn get_all(&self, pattern: &str) -> Result<Vec<Arc<Node>>> {
-        let regex = Regex::new(pattern)
-            .with_context(|| format!("無効な正規表現パターン: {pattern}"))?;
-
-        Ok(self.find_matching_paths(pattern)
-            .into_iter()
-            .filter_map(|path| {
-                if regex.is_match(&path) {
-                    self.get_node(&path).ok()
-                } else {
-                    None
-                }
-            })
-            .collect())
-    }
-
-    fn exists(&self, path: &str) -> bool {
-        self.get_node(path).is_ok()
-    }
-}
-
-// 型変換のトレイト
-pub trait FromConfigValue: Sized {
-    /// 設定値から型を生成します。
-    /// 
-    /// # Errors
-    /// - 値の型が要求された型と一致しない場合にエラーを返します。
-    /// - 値の変換に失敗した場合にエラーを返します。
-    fn from_config_value(value: &Value) -> Result<Self>;
-}
-
-impl FromConfigValue for String {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        match value {
-            Value::String(s) => Ok(s.clone()),
-            _ => Err(anyhow!("文字列型を期待しましたが、{}型が見つかりました", value.type_str())),
-        }
-    }
-}
-
-impl FromConfigValue for i64 {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        match value {
-            Value::Number(n) => n.as_i64()
-                .ok_or_else(|| anyhow!("整数型を期待しましたが、浮動小数点数が見つかりました")),
-            _ => Err(anyhow!("数値型を期待しましたが、{}型が見つかりました", value.type_str())),
-        }
-    }
-}
-
-impl FromConfigValue for bool {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        match value {
-            Value::Bool(b) => Ok(*b),
-            _ => Err(anyhow!("真偽値値型を期待しましたが、{}型が見つかりました", value.type_str())),
-        }
-    }
-}
-
-impl<S: ::std::hash::BuildHasher + Default> FromConfigValue for HashMap<String, String, S> {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        match value {
-            Value::Mapping(map) => {
-                let mut result = Self::default();
-                for (key, value) in map {
-                    let key = match key {
-                        Value::String(s) => s.clone(),
-                        _ => return Err(anyhow!("マップのキーは文字列である必要があります")),
-                    };
-                    let value = match value {
-                        Value::String(s) => s.clone(),
-                        _ => return Err(anyhow!("マップの値は文字列である必要があります")),
-                    };
-                    result.insert(key, value);
-                }
-                Ok(result)
-            }
-            _ => Err(anyhow!("マップ型を期待しましたが、{}型が見つかりました", value.type_str())),
-        }
-    }
-}
-
-impl FromConfigValue for Value {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        Ok(value.clone())
-    }
-}
-
-impl FromConfigValue for Node {
-    fn from_config_value(value: &Value) -> Result<Self> {
-        Ok(Self::new(value.clone(), String::new()))
-    }
-}
-
-// ヘルパートレイト
-pub trait ValueExt {
-    fn type_str(&self) -> &'static str;
-    fn as_node(&self) -> Option<Arc<Node>>;
-}
-
-impl std::fmt::Display for PrimitiveType {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::String => write!(f, "string"),
-            Self::Number => write!(f, "number"),
-            Self::Boolean => write!(f, "boolean"),
-            Self::Null => write!(f, "null"),
-        }
-    }
-}
-
-impl Schema {
-    /// 値を検証します
-    /// 
-    /// # Arguments
-    /// * `value` - 検証する値
-    ///
-    /// # Returns
-    /// * `Result<()>` - 検証結果
-    ///
-    /// # Errors
-    /// - 値の型が一致しない場合
-    /// - 値が無効な場合
-    /// - スキーマの制約に違反している場合
-    pub fn validate(&self, value: &Value) -> Result<()> {
-        match self {
-            Self::Primitive(primitive_type) => match (primitive_type, value) {
-                (PrimitiveType::String, Value::String(_)) |
-                (PrimitiveType::Number, Value::Number(_)) |
-                (PrimitiveType::Boolean, Value::Bool(_)) |
-                (PrimitiveType::Null, Value::Null) => Ok(()),
-                _ => Err(anyhow!("値の型が一致しません")),
-            },
-            Self::Array(item_schema) => {
-                if let Value::Sequence(items) = value {
-                    for item in items {
-                        item_schema.validate(item)?;
-                    }
-                    Ok(())
-                } else {
-                    Err(Error::msg(format!(
-                        "型エラー: array型を期待しましたが、{}型が見つかりました",
-                        value.type_str()
-                    )))
-                }
-            }
-            Self::Object(properties) => {
-                if let Value::Mapping(map) = value {
-                    for (key, schema) in properties {
-                        if let Some(value) = map.get(Value::String(key.clone())) {
-                            schema.validate(value)?;
-                        }
-                    }
-                    Ok(())
-                } else {
-                    Err(Error::msg(format!(
-                        "型エラー: object型を期待しましたが、{}型が見つかりました",
-                        value.type_str()
-                    )))
-                }
-            }
-            Self::Union(schemas) => {
-                for schema in schemas {
-                    if schema.validate(value).is_ok() {
-                        return Ok(());
-                    }
-                }
-                Err(Error::msg("値がユニオン型のいずれにも一致しません"))
-            }
-            Self::Custom(custom) => custom.validate(value),
-        }
-    }
-}
-
-impl ValueExt for Value {
-    fn type_str(&self) -> &'static str {
-        match self {
-            Self::Null => "null",
-            Self::Bool(_) => "boolean",
-            Self::Number(_) => "number",
-            Self::String(_) => "string",
-            Self::Sequence(_) => "array",
-            Self::Mapping(_) => "object",
-            Self::Tagged(_) => "tagged",
-        }
-    }
-
-    fn as_node(&self) -> Option<Arc<Node>> {
-        if let Self::Mapping(m) = self {
-            if let Some(Self::String(node_type)) = m.get(Self::String("type".to_string())) {
-                if node_type == "node" {
-                    return Some(Arc::new(Node::new(self.clone(), String::new())));
-                }
-            }
-        }
-        None
-    }
-}
-
-impl ValueExt for PrimitiveType {
-    fn type_str(&self) -> &'static str {
-        match self {
-            Self::String => "string",
-            Self::Number => "number",
-            Self::Boolean => "boolean",
-            Self::Null => "null",
-        }
-    }
-
-    fn as_node(&self) -> Option<Arc<Node>> {
-        None
-    }
-}
-
-// 設定を探すためのヘルパーメソッド
-impl Config {
-    fn find_matching_paths(&self, _pattern: &str) -> Vec<String> {
-        self.collect_paths(&self.root.value)
-    }
-
-    #[allow(clippy::only_used_in_recursion)]
-    fn collect_paths(&self, value: &Value) -> Vec<String> {
-        match value {
-            Value::Mapping(map) => {
-                map.iter()
-                    .flat_map(|(key, val)| {
-                        let key_str = match key {
-                            Value::String(s) => s.clone(),
-                            Value::Number(n) => n.to_string(),
-                            Value::Bool(b) => b.to_string(),
-                            Value::Null => "null".to_string(),
-                            Value::Sequence(_) => "[array]".to_string(),
-                            Value::Mapping(_) => "{object}".to_string(),
-                            Value::Tagged(_) => "[tagged]".to_string(),
-                        };
-                        let key_for_sub = key_str.clone();
-                        let sub_paths = self.collect_paths(val)
-                            .into_iter()
-                            .map(move |sub_path| {
-                                if sub_path.is_empty() {
-                                    key_for_sub.clone()
-                                } else {
-                                    format!("{key_for_sub}.{sub_path}")
-                                }
-                            });
-                        std::iter::once(key_str).chain(sub_paths).collect::<Vec<_>>()
-                    })
-                    .collect()
-            },
-            Value::Sequence(seq) => {
-                seq.iter()
-                    .enumerate()
-                    .flat_map(|(idx, val)| {
-                        let idx_str = idx.to_string();
-                        let idx_for_sub = idx_str.clone();
-                        let sub_paths = self.collect_paths(val)
-                            .into_iter()
-                            .map(move |sub_path| {
-                                if sub_path.is_empty() {
-                                    idx_for_sub.clone()
-                                } else {
-                                    format!("{idx_for_sub}.{sub_path}")
-                                }
-                            });
-                        std::iter::once(idx_str).chain(sub_paths).collect::<Vec<_>>()
-                    })
-                    .collect()
-            },
-            _ => vec![String::new()],
-        }
+    pub fn contest_storage_dir(&self) -> String {
+        self.languages.base.contest_dir.storage.clone()
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/command.rs b/src/contest/service/command.rs
index 2f6fac3..86d40b4 100644
--- a/src/contest/service/command.rs
+++ b/src/contest/service/command.rs
@@ -1,20 +1,28 @@
 use crate::contest::model::{Command, CommandContext, Contest};
 use crate::contest::service::{ContestHandler, TestRunner};
+use crate::config::Config;
 use anyhow::Result;
 use crate::message::contest;
 
 pub struct Service {
     contest_service: ContestHandler,
     test_service: TestRunner,
+    config: Config,
 }
 
 impl Service {
-    #[must_use = "この関数は新しいCommandServiceインスタンスを返します"]
-    pub const fn new(contest_service: ContestHandler, test_service: TestRunner) -> Self {
-        Self {
+    /// `CommandService`の新しいインスタンスを作成します
+    /// 
+    /// # Errors
+    /// 
+    /// - 設定ファイルの読み込みに失敗した場合
+    pub fn new(contest_service: ContestHandler, test_service: TestRunner) -> Result<Self> {
+        let config = Config::load()?;
+        Ok(Self {
             contest_service,
             test_service,
-        }
+            config,
+        })
     }
 
     /// コマンドを実行します。
@@ -25,15 +33,27 @@ impl Service {
     pub fn execute(&self, context: CommandContext) -> Result<()> {
         match context.command {
             Command::Login => {
-                // TODO: ログイン処理の実装
                 println!("ログイン処理を実行します");
+                // TODO: ログイン処理の実装
                 Ok(())
             }
             Command::Config { site, contest_id, problem_id, language: _ } => {
                 println!("問題を開きます: site={site:?}, contest={contest_id:?}, problem={problem_id:?}");
                 site.map_or_else(
                     || Err(anyhow::anyhow!(contest::error("invalid_command", "サイトが指定されていません"))),
-                    |site_str| self.contest_service.open(&site_str, &contest_id, &problem_id)
+                    |site_str| {
+                        // 設定からテンプレートディレクトリを取得
+                        let template_dir = self.config.contest_template_dir();
+                        let active_dir = self.config.active_contest_dir();
+                        
+                        self.contest_service.open_with_config(
+                            &site_str,
+                            &contest_id,
+                            &problem_id,
+                            &template_dir,
+                            &active_dir,
+                        )
+                    }
                 )
             }
             Command::Open => {
@@ -45,7 +65,9 @@ impl Service {
                     || Err(anyhow::anyhow!(contest::error("invalid_command", "コンテストが選択されていません"))),
                     |contest| {
                         println!("テストを実行します: test_number={test_number:?}");
-                        let result = self.test_service.run_test(&contest, test_number)?;
+                        // 設定からテストディレクトリを取得
+                        let test_dir = self.config.test_dir();
+                        let result = self.test_service.run_test_with_config(&contest, test_number, &test_dir)?;
                         println!("{}", result.summary());
                         Ok(())
                     }
diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index 7cbed56..fbcf158 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -278,4 +278,32 @@ impl Service {
         println!("{}", contest::hint("optimize_code", format!("提出を行います: contest={contest:?}")));
         Ok(())
     }
+
+    /// 設定を使用して問�を開きます
+    /// 
+    /// # Arguments
+    /// 
+    /// * `site` - サイト名
+    /// * `contest_id` - コンテストID
+    /// * `problem_id` - 問題ID
+    /// * `template_dir` - テンプレートディレクトリ
+    /// * `active_dir` - アクティブディレクトリ
+    /// 
+    /// # Errors
+    /// 
+    /// - 問題の取得に失敗した場合
+    /// - ディレクトリの作成に失敗した場合
+    pub fn open_with_config(
+        &self,
+        _site: &str,
+        _contest_id: &Option<String>,
+        _problem_id: &Option<String>,
+        template_dir: &str,
+        active_dir: &str,
+    ) -> Result<()> {
+        // TODO: 実装
+        println!("テンプレートディレクトリ: {template_dir}");
+        println!("アクティブディレクトリ: {active_dir}");
+        Ok(())
+    }
 } 
\ No newline at end of file
diff --git a/src/contest/service/test.rs b/src/contest/service/test.rs
index e536d65..762046f 100644
--- a/src/contest/service/test.rs
+++ b/src/contest/service/test.rs
@@ -244,4 +244,33 @@ impl Service {
             actual,
         })
     }
+
+    /// 設定を使用してテストを実行します
+    /// 
+    /// # Arguments
+    /// 
+    /// * `contest` - コンテスト情報
+    /// * `test_number` - テスト番号（Noneの場合は全てのテストを実行）
+    /// * `test_dir` - テストディレクトリ
+    /// 
+    /// # Errors
+    /// 
+    /// - テストの実行に失敗した場合
+    pub fn run_test_with_config(
+        &self,
+        _contest: &Contest,
+        _test_number: Option<usize>,
+        test_dir: &str,
+    ) -> AnyhowResult<TestResults> {
+        // TODO: 実装
+        println!("テストディレクトリ: {test_dir}");
+        Ok(TestResults {
+            total_cases: 0,
+            successful_cases: 0,
+            failed_cases: 0,
+            error_cases: 0,
+            total_time: std::time::Duration::from_secs(0),
+            case_results: Vec::new(),
+        })
+    }
 } 
\ No newline at end of file
