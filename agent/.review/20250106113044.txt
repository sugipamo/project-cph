diff --git a/src/docker/error.rs b/src/docker/error.rs
index 8643e1e..a05f24d 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,37 +1,35 @@
 use thiserror::Error;
+use tokio::time::error::Elapsed;
 use crate::docker::state::StateError;
 
-#[derive(Error, Debug)]
+#[derive(Debug, Error)]
 pub enum DockerError {
-    #[error("Container error: {0}")]
-    Container(String),
-    #[error("IO error: {0}")]
-    IO(String),
-    #[error("Compilation error: {0}")]
-    Compilation(String),
-    #[error("Command error: {0}")]
+    #[error("コマンドの実行に失敗しました: {0}")]
     Command(String),
-    #[error("State error: {0}")]
+
+    #[error("コンテナの状態エラー: {0}")]
     State(#[from] StateError),
-}
 
-pub type DockerResult<T> = Result<T, DockerError>;
+    #[error("タイムアウトエラー")]
+    Timeout(#[from] Elapsed),
 
-impl From<std::io::Error> for DockerError {
-    fn from(err: std::io::Error) -> Self {
-        DockerError::IO(err.to_string())
+    #[error("ファイルシステムエラー: {0}")]
+    Filesystem(String),
+
+    #[error("システムエラー: {0}")]
+    System(String),
+}
+
+impl From<nix::errno::Errno> for DockerError {
+    fn from(err: nix::errno::Errno) -> Self {
+        DockerError::System(err.to_string())
     }
 }
 
-impl From<tokio::time::error::Elapsed> for DockerError {
-    fn from(err: tokio::time::error::Elapsed) -> Self {
-        DockerError::Command(format!("操作がタイムアウトしました: {}", err))
+impl From<std::io::Error> for DockerError {
+    fn from(err: std::io::Error) -> Self {
+        DockerError::Filesystem(err.to_string())
     }
 }
 
-#[derive(Debug)]
-pub struct ErrorContext {
-    pub operation: String,
-    pub container_id: Option<String>,
-    pub command: Option<String>,
-} 
\ No newline at end of file
+pub type DockerResult<T> = Result<T, DockerError>; 
\ No newline at end of file
diff --git a/src/docker/executor/mod.rs b/src/docker/executor/mod.rs
deleted file mode 100644
index 3c610f1..0000000
--- a/src/docker/executor/mod.rs
+++ /dev/null
@@ -1,123 +0,0 @@
-use async_trait::async_trait;
-use std::process::Command;
-use std::collections::HashMap;
-use crate::docker::error::{DockerError, DockerResult};
-
-#[derive(Debug, Clone)]
-pub struct DockerCommand {
-    pub command: String,
-    pub args: Vec<String>,
-    pub env: Option<HashMap<String, String>>,
-}
-
-impl DockerCommand {
-    pub fn new(command: impl Into<String>) -> Self {
-        Self {
-            command: command.into(),
-            args: Vec::new(),
-            env: None,
-        }
-    }
-
-    pub fn arg(mut self, arg: impl Into<String>) -> Self {
-        self.args.push(arg.into());
-        self
-    }
-
-    pub fn args(mut self, args: impl IntoIterator<Item = impl Into<String>>) -> Self {
-        self.args.extend(args.into_iter().map(Into::into));
-        self
-    }
-
-    pub fn env(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
-        let env = self.env.get_or_insert_with(HashMap::new);
-        env.insert(key.into(), value.into());
-        self
-    }
-}
-
-#[derive(Debug, Clone)]
-pub struct CommandOutput {
-    pub success: bool,
-    pub stdout: String,
-    pub stderr: String,
-}
-
-#[async_trait]
-pub trait DockerCommandExecutor: Send + Sync {
-    async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput>;
-}
-
-pub struct DefaultDockerExecutor;
-
-impl DefaultDockerExecutor {
-    pub fn new() -> Self {
-        Self
-    }
-}
-
-#[async_trait]
-impl DockerCommandExecutor for DefaultDockerExecutor {
-    async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput> {
-        let mut cmd = Command::new("docker");
-        
-        // コマンドと引数を設定
-        cmd.arg(&command.command);
-        cmd.args(&command.args);
-
-        // 環境変数を設定
-        if let Some(env) = command.env {
-            for (key, value) in env {
-                cmd.env(key, value);
-            }
-        }
-
-        let output = cmd
-            .output()
-            .map_err(|e| DockerError::Command(format!("コマンドの実行に失敗しました: {}", e)))?;
-
-        Ok(CommandOutput {
-            success: output.status.success(),
-            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
-            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
-        })
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use mockall::mock;
-
-    mock! {
-        pub DockerExecutor {}
-        #[async_trait]
-        impl DockerCommandExecutor for DockerExecutor {
-            async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput>;
-        }
-    }
-
-    #[tokio::test]
-    async fn test_docker_command_builder() {
-        let command = DockerCommand::new("run")
-            .arg("-d")
-            .args(vec!["--name", "test-container"])
-            .env("MEMORY_LIMIT", "512m");
-
-        assert_eq!(command.command, "run");
-        assert_eq!(command.args, vec!["-d", "--name", "test-container"]);
-        assert_eq!(
-            command.env.unwrap().get("MEMORY_LIMIT").unwrap(),
-            "512m"
-        );
-    }
-
-    #[tokio::test]
-    async fn test_docker_executor() {
-        let executor = DefaultDockerExecutor::new();
-        let command = DockerCommand::new("version");
-
-        let result = executor.execute(command).await;
-        assert!(result.is_ok());
-    }
-} 
\ No newline at end of file
diff --git a/src/docker/mod.rs b/src/docker/mod.rs
index adcfab6..1adc6e2 100644
--- a/src/docker/mod.rs
+++ b/src/docker/mod.rs
@@ -1,10 +1,9 @@
+pub mod config;
 pub mod error;
+pub mod fs;
+pub mod runner;
 pub mod state;
 pub mod traits;
-pub mod runner;
-pub mod executor;
-pub mod config;
 
-pub use runner::DockerRunner;
-pub use executor::DockerCommandExecutor;
-pub use config::ContainerConfig; 
\ No newline at end of file
+pub use runner::{DockerRunner, DockerRunnerManager, DockerCommand, DockerCommandExecutor, CommandOutput, DefaultDockerExecutor};
+pub use state::container::{ContainerState as RunnerState, ContainerStateManager, StateError}; 
\ No newline at end of file
diff --git a/src/docker/runner/compiler.rs b/src/docker/runner/compiler.rs
index b18bdee..9e673ca 100644
--- a/src/docker/runner/compiler.rs
+++ b/src/docker/runner/compiler.rs
@@ -1,22 +1,20 @@
 use std::sync::Arc;
 use tokio::sync::Mutex;
-use bollard::Docker;
-use bollard::container::{Config as DockerConfig, CreateContainerOptions, HostConfig};
-use bollard::exec::{CreateExecOptions, StartExecOptions};
 use thiserror::Error;
 use crate::docker::state::RunnerState;
+use crate::docker::traits::ContainerManager;
 use crate::config::Config;
 
 // New error type
 #[derive(Error, Debug)]
 pub enum CompilerError {
-    #[error("Failed to resolve language: {0}")]
+    #[error("言語の解決に失敗しました: {0}")]
     LanguageResolution(String),
-    #[error("Container creation failed: {0}")]
+    #[error("コンテナの作成に失敗しました: {0}")]
     ContainerCreation(String),
-    #[error("Container startup failed: {0}")]
+    #[error("コンテナの起動に失敗しました: {0}")]
     ContainerStartup(String),
-    #[error("Configuration error: {0}")]
+    #[error("設定エラー: {0}")]
     Config(String),
 }
 
@@ -26,15 +24,8 @@ pub trait CompilationManager {
     async fn cleanup(&mut self) -> Result<(), CompilerError>;
 }
 
-// New trait for container operations
-pub trait ContainerManager {
-    async fn create_container(&mut self, config: DockerConfig) -> Result<String, CompilerError>;
-    async fn start_container(&mut self, container_id: &str) -> Result<(), CompilerError>;
-}
-
 pub(super) struct DockerCompiler {
-    docker: Docker,
-    container_id: String,
+    container_manager: Arc<Mutex<dyn ContainerManager>>,
     config: Arc<Config>,
     state: Arc<Mutex<RunnerState>>,
     stdout_buffer: Arc<Mutex<Vec<String>>>,
@@ -43,15 +34,14 @@ pub(super) struct DockerCompiler {
 
 impl DockerCompiler {
     pub(super) fn new(
-        docker: Docker,
+        container_manager: Arc<Mutex<dyn ContainerManager>>,
         config: Config,
         state: Arc<Mutex<RunnerState>>,
         stdout_buffer: Arc<Mutex<Vec<String>>>,
         stderr_buffer: Arc<Mutex<Vec<String>>>,
     ) -> Self {
         Self {
-            docker,
-            container_id: String::new(),
+            container_manager,
             config: Arc::new(config),
             state,
             stdout_buffer,
@@ -62,30 +52,29 @@ impl DockerCompiler {
 
 impl CompilationManager for DockerCompiler {
     async fn compile(&mut self, language: &str) -> Result<(), CompilerError> {
-        let resolved_lang = self.config
-            .get_with_alias::<String>(&format!("{}.name", language))
+        // 言語の設定を取得
+        let lang_config = self.config.get_with_alias::<String>(&format!("{}.name", language))
             .map_err(|e| CompilerError::LanguageResolution(e.to_string()))?;
 
-        // ... rest of compilation logic, now using proper error types ...
-        Ok(())
-    }
+        // コンテナを作成
+        let mut manager = self.container_manager.lock().await;
+        manager.create_container(&lang_config, vec![], "/workspace")
+            .await
+            .map_err(|e| CompilerError::ContainerCreation(e.to_string()))?;
 
-    async fn cleanup(&mut self) -> Result<(), CompilerError> {
-        // Add cleanup implementation
-        Ok(())
-    }
-}
+        // コンテナを起動
+        manager.start_container()
+            .await
+            .map_err(|e| CompilerError::ContainerStartup(e.to_string()))?;
 
-impl ContainerManager for DockerCompiler {
-    async fn create_container(&mut self, config: DockerConfig) -> Result<String, CompilerError> {
-        // Implementation moved from compile method
-        Ok(String::new())
+        Ok(())
     }
 
-    async fn start_container(&mut self, container_id: &str) -> Result<(), CompilerError> {
-        // Implementation moved from compile method
+    async fn cleanup(&mut self) -> Result<(), CompilerError> {
+        let mut manager = self.container_manager.lock().await;
+        manager.stop_container()
+            .await
+            .map_err(|e| CompilerError::ContainerStartup(e.to_string()))?;
         Ok(())
     }
-}
-
-// ... rest of existing implementation ...
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index a5c62aa..5067662 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -6,9 +6,14 @@ use tokio::time::timeout;
 use crate::docker::error::{DockerError, DockerResult};
 use crate::docker::state::container::{ContainerState, ContainerStateManager};
 use crate::docker::config::ContainerConfig;
-use crate::docker::executor::{DockerCommand, DockerCommandExecutor};
 use crate::docker::traits::ContainerManager;
 
+mod manager;
+mod executor;
+
+pub use manager::DockerRunnerManager;
+pub use executor::{DockerCommand, DockerCommandExecutor, CommandOutput, DefaultDockerExecutor};
+
 pub struct DockerRunner {
     container_manager: Arc<Mutex<dyn ContainerManager>>,
     state_manager: Arc<ContainerStateManager>,
diff --git a/src/docker/runners/mod.rs b/src/docker/runners/mod.rs
deleted file mode 100644
index 33fa3ec..0000000
--- a/src/docker/runners/mod.rs
+++ /dev/null
@@ -1,95 +0,0 @@
-use tokio::sync::Mutex;
-use std::sync::Arc;
-use bollard::Docker;
-use std::time::{Duration, Instant};
-use tokio::time::sleep;
-use tokio::time::timeout;
-use futures::future::join_all;
-
-use crate::docker::{DockerRunner, RunnerState, RunnerStatus};
-use crate::config::Config;
-
-const MAX_BUFFER_SIZE: usize = 1024 * 1024;  // 1MB
-const OPERATION_TIMEOUT: Duration = Duration::from_secs(15);
-const STOP_TIMEOUT: Duration = Duration::from_secs(10);
-
-pub struct DockerRunners {
-    docker: Docker,
-    config: Arc<Config>,
-    runners: Arc<Mutex<Vec<Arc<Mutex<DockerRunner>>>>>,
-    connections: Arc<Mutex<Vec<Vec<usize>>>>,
-    state: Arc<Mutex<RunnerState>>,
-}
-
-impl DockerRunners {
-    pub fn new(docker: Docker, config: Config) -> Self {
-        Self {
-            docker,
-            config: Arc::new(config),
-            runners: Arc::new(Mutex::new(Vec::new())),
-            connections: Arc::new(Mutex::new(Vec::new())),
-            state: Arc::new(Mutex::new(RunnerState::new())),
-        }
-    }
-
-    pub async fn add_runner(&self, language: String) -> Result<usize, String> {
-        let mut runners = self.runners.lock().await;
-        let mut connections = self.connections.lock().await;
-        let mut state = self.state.lock().await;
-        let id = runners.len();
-
-        // 言語の存在確認
-        let _resolved_lang = self.config.get_with_alias::<String>(&format!("{}.name", language))
-            .map_err(|e| format!("言語名の解決に失敗しました: {}", e))?;
-
-        let runner = DockerRunner::new(self.docker.clone(), self.config.clone(), language);
-        runners.push(Arc::new(Mutex::new(runner)));
-        connections.push(Vec::new());
-        state.update_runner(id, RunnerStatus::Ready)?;
-
-        Ok(id)
-    }
-
-    pub async fn run(&self) -> Result<(), String> {
-        println!("Starting runner execution");
-        {
-            let mut state = self.state.lock().await;
-            if state.get_status() != &RunnerStatus::Ready {
-                return Err("実行準備ができていません".to_string());
-            }
-            state.start();
-        }
-
-        // タイムアウト設定の取得
-        let timeout_seconds = self.config.get::<u64>("system.docker.timeout_seconds")
-            .map_err(|e| format!("タイムアウト設定の読み込みに失敗しました: {}", e))?;
-        let timeout_duration = Duration::from_secs(timeout_seconds);
-
-        tokio::select! {
-            _ = tokio::time::sleep(timeout_duration) => {
-                println!("Execution timeout reached after {:?}", timeout_duration);
-                let mut state = self.state.lock().await;
-                state.error(format!("実行がタイムアウトしました: {:?}", timeout_duration));
-                Err(format!("実行がタイムアウトしました: {:?}", timeout_duration))
-            }
-            result = self.run_internal() => result,
-        }
-    }
-
-    async fn run_internal(&self) -> Result<(), String> {
-        loop {
-            if !self.check_runners(None).await {
-                println!("Runner error detected");
-                let mut state = self.state.lock().await;
-                state.error("ランナーでエラーが発生しました".to_string());
-                return Err("ランナーでエラーが発生しました".to_string());
-            }
-
-            // 他のチェックロジック...
-
-            tokio::time::sleep(Duration::from_millis(100)).await;
-        }
-    }
-
-    // 他のメソッドは必要に応じて更新...
-} 
\ No newline at end of file

# レビュー結果

1. 重要な機能の削除: なし
- executor モジュールは runner モジュールに統合
- エラー処理の改善と日本語化

2. コンパイルチェック: OK
- 警告はあるが重大なエラーなし

3. 機能の重複: なし
- 削除されたコードは適切に統合

4. 実装の効率性: 改善
- エラー処理の整理
- モジュール構造の改善
- コードの品質向上
