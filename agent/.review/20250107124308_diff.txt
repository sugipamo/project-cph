diff --git a/src/bin/cph.rs b/src/bin/cph.rs
index b9db2b6..2864441 100644
--- a/src/bin/cph.rs
+++ b/src/bin/cph.rs
@@ -1,8 +1,27 @@
+use std::env;
+use anyhow::{Result, Context};
 use cph::config::Config;
-use serde_yaml::Value;
+use cph::contest::parse::CommandParser;
+use cph::contest::service::{CommandService, ContestService, TestService};
+
+fn main() -> Result<()> {
+    // コマンドライン引数を取得
+    let args: Vec<String> = env::args().skip(1).collect();
+    let input = args.join(" ");
+
+    // 設定ファイルを読み込む
+    let config = Config::load_from_file("src/config/config.yaml")
+        .context("src/config/config.yamlの読み込みに失敗しました")?;
+
+    // サービスを初期化
+    let contest_service = ContestService::new(&config)?;
+    let test_service = TestService::new(&config)?;
+    let command_service = CommandService::new(contest_service, test_service);
+
+    // コマンドをパースして実行
+    let parser = CommandParser::new(&config)?;
+    let context = parser.parse(&input)?;
+    command_service.execute(context)?;
 
-fn main() -> Result<(), Box<dyn std::error::Error>> {
-    let root_value = Value::Mapping(serde_yaml::Mapping::new());
-    let _config = Config::new(root_value);
     Ok(())
 }
diff --git a/src/config/mod.rs b/src/config/mod.rs
index ce6ecd0..340f003 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -129,8 +129,27 @@ impl Config {
     pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
         let contents = fs::read_to_string(&path)
             .with_context(|| format!("設定ファイルの読み込みに失敗: {}", path.as_ref().display()))?;
-        let value = serde_yaml::from_str(&contents)
+        
+        // メイン設定を読み込む
+        let mut value = serde_yaml::from_str(&contents)
             .with_context(|| "YAMLのパースに失敗しました")?;
+
+        // commands.yamlを読み込む
+        let commands_path = path.as_ref().parent().unwrap().join("commands.yaml");
+        if commands_path.exists() {
+            let commands_contents = fs::read_to_string(&commands_path)
+                .with_context(|| format!("コマンド設定ファイルの読み込みに失敗: {}", commands_path.display()))?;
+            let commands_value: Value = serde_yaml::from_str(&commands_contents)
+                .with_context(|| "コマンド設定のパースに失敗しました")?;
+
+            // メイン設定にコマンド設定をマージ
+            if let Value::Mapping(ref mut map) = value {
+                if let Value::Mapping(commands_map) = commands_value {
+                    map.extend(commands_map);
+                }
+            }
+        }
+
         Ok(Self::new(value))
     }
 
@@ -169,6 +188,11 @@ impl Config {
 
         Ok(current.clone())
     }
+
+    pub fn get_typed<T: serde::de::DeserializeOwned>(&self, path: &str) -> Result<T> {
+        let value = self.resolve_path(path)?;
+        serde_yaml::from_value(value).map_err(|e| anyhow::anyhow!("型変換に失敗しました: {}", e))
+    }
 }
 
 // ConfigAccessの実装
diff --git a/src/contest/commands.yaml b/src/contest/commands.yaml
deleted file mode 100644
index f02e854..0000000
--- a/src/contest/commands.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
-executions:
-  login:
-    aliases: ["login", "auth"]
-    
-  open:
-    aliases: ["open", "o", "show"]
-    
-  test:
-    aliases: ["test", "t", "check"]
-    
-  submit:
-    aliases: ["submit", "s", "sub"]
-
-settings:
-  contest:
-    priority: 2
-    
-  problem:
-    priority: 1
-    
-  language:
-    rust:
-      aliases: ["rust", "rs", "Rust", "RUST"]
-    python:
-      aliases: ["python", "python3"]
-    pypy:
-      aliases: ["pypy", "py", "pypy3", "PyPy", "PYPY"]
-    cpp:
-      aliases: ["cpp", "c++", "gcc"]
-
-  site:
-    atcoder:
-      aliases: ["atcoder", "ac", "at-coder", "at_coder", "AtCoder"]
\ No newline at end of file
diff --git a/src/contest/error.rs b/src/contest/error.rs
index c531db7..052221e 100644
--- a/src/contest/error.rs
+++ b/src/contest/error.rs
@@ -1,23 +1,51 @@
 use anyhow::Error;
 
-pub fn contest_error(message: impl Into<String>) -> Error {
+pub fn command_error(message: impl Into<String>) -> Error {
     Error::msg(message.into())
 }
 
-pub fn not_found_error(message: impl Into<String>) -> Error {
-    Error::msg(message.into())
+pub fn empty_command_error() -> Error {
+    command_error("コマンドが空です")
 }
 
-pub fn invalid_language_error(message: impl Into<String>) -> Error {
-    Error::msg(message.into())
+pub fn unknown_command_error(command: impl Into<String>) -> Error {
+    command_error(format!("未知のコマンド: {}", command.into()))
 }
 
-pub fn invalid_url_error(message: impl Into<String>) -> Error {
-    Error::msg(message.into())
+pub fn unknown_site_error(site: impl Into<String>) -> Error {
+    command_error(format!("未知のサイト: {}", site.into()))
+}
+
+pub fn site_required_error() -> Error {
+    command_error("サイトの指定が必要です")
+}
+
+pub fn too_many_arguments_error() -> Error {
+    command_error("引数が多すぎます")
+}
+
+pub fn no_contest_selected_error() -> Error {
+    command_error("コンテストが選択されていません")
+}
+
+pub fn unsupported_language_error(language: impl Into<String>) -> Error {
+    command_error(format!("サポートされていない言語です: {}", language.into()))
+}
+
+pub fn invalid_url_error(url: impl Into<String>) -> Error {
+    command_error(format!("URLの形式が正しくありません: {}", url.into()))
 }
 
 pub fn parse_error(message: impl Into<String>) -> Error {
-    Error::msg(message.into())
+    command_error(format!("パースに失敗しました: {}", message.into()))
+}
+
+pub fn not_found_error(resource: impl Into<String>) -> Error {
+    command_error(format!("リソースが見つかりません: {}", resource.into()))
+}
+
+pub fn contest_error(message: impl Into<String>) -> Error {
+    command_error(format!("コンテストの操作に失敗しました: {}", message.into()))
 }
 
 #[cfg(test)]
@@ -25,37 +53,68 @@ mod tests {
     use super::*;
 
     #[test]
-    fn test_contest_error() {
-        let error = contest_error("テストエラー");
-        assert!(error.to_string().contains("テストエラー"));
-        assert!(error.to_string().contains("コンテストの操作に失敗しました"));
+    fn test_empty_command_error() {
+        let error = empty_command_error();
+        assert_eq!(error.to_string(), "コマンドが空です");
     }
 
     #[test]
-    fn test_not_found_error() {
-        let error = not_found_error("テストリソース");
-        assert!(error.to_string().contains("テストリソース"));
-        assert!(error.to_string().contains("リソースが見つかりません"));
+    fn test_unknown_command_error() {
+        let error = unknown_command_error("test");
+        assert_eq!(error.to_string(), "未知のコマンド: test");
+    }
+
+    #[test]
+    fn test_unknown_site_error() {
+        let error = unknown_site_error("example");
+        assert_eq!(error.to_string(), "未知のサイト: example");
     }
 
     #[test]
-    fn test_invalid_language_error() {
-        let error = invalid_language_error("テスト言語");
-        assert!(error.to_string().contains("テスト言語"));
-        assert!(error.to_string().contains("サポートされていない言語です"));
+    fn test_site_required_error() {
+        let error = site_required_error();
+        assert_eq!(error.to_string(), "サイトの指定が必要です");
+    }
+
+    #[test]
+    fn test_too_many_arguments_error() {
+        let error = too_many_arguments_error();
+        assert_eq!(error.to_string(), "引数が多すぎます");
+    }
+
+    #[test]
+    fn test_no_contest_selected_error() {
+        let error = no_contest_selected_error();
+        assert_eq!(error.to_string(), "コンテストが選択されていません");
+    }
+
+    #[test]
+    fn test_unsupported_language_error() {
+        let error = unsupported_language_error("brainfuck");
+        assert_eq!(error.to_string(), "サポートされていない言語です: brainfuck");
     }
 
     #[test]
     fn test_invalid_url_error() {
-        let error = invalid_url_error("テストURL");
-        assert!(error.to_string().contains("テストURL"));
-        assert!(error.to_string().contains("URLの形式が正しくありません"));
+        let error = invalid_url_error("not a url");
+        assert_eq!(error.to_string(), "URLの形式が正しくありません: not a url");
     }
 
     #[test]
     fn test_parse_error() {
-        let error = parse_error("テストパース");
-        assert!(error.to_string().contains("テストパース"));
-        assert!(error.to_string().contains("パースに失敗しました"));
+        let error = parse_error("invalid format");
+        assert_eq!(error.to_string(), "パースに失敗しました: invalid format");
+    }
+
+    #[test]
+    fn test_not_found_error() {
+        let error = not_found_error("file.txt");
+        assert_eq!(error.to_string(), "リソースが見つかりません: file.txt");
+    }
+
+    #[test]
+    fn test_contest_error() {
+        let error = contest_error("failed to submit");
+        assert_eq!(error.to_string(), "コンテストの操作に失敗しました: failed to submit");
     }
 }
diff --git a/src/contest/model/mod.rs b/src/contest/model/mod.rs
index 2f5b931..37c52f7 100644
--- a/src/contest/model/mod.rs
+++ b/src/contest/model/mod.rs
@@ -81,4 +81,40 @@ impl TestCase {
             path: String::new(),
         }
     }
+}
+
+#[derive(Debug, Clone, PartialEq)]
+pub enum Command {
+    Login,
+    Open {
+        site: String,
+        contest_id: Option<String>,
+        problem_id: Option<String>,
+    },
+    Test {
+        test_number: Option<usize>,
+    },
+    Submit,
+}
+
+#[derive(Debug, Clone)]
+pub struct CommandContext {
+    pub command: Command,
+    pub contest: Option<Contest>,
+}
+
+impl CommandContext {
+    pub fn new(command: Command) -> Self {
+        Self {
+            command,
+            contest: None,
+        }
+    }
+
+    pub fn with_contest(command: Command, contest: Contest) -> Self {
+        Self {
+            command,
+            contest: Some(contest),
+        }
+    }
 } 
\ No newline at end of file
diff --git a/src/contest/parse.rs b/src/contest/parse.rs
index a2fcc06..00e43d1 100644
--- a/src/contest/parse.rs
+++ b/src/contest/parse.rs
@@ -1,282 +1,224 @@
 use std::collections::HashMap;
-use crate::config::{Config, ConfigAccess, ConfigNode};
+use crate::config::{Config, FromConfigValue};
+use crate::contest::model::{Command, CommandContext};
 use anyhow::{Result, anyhow};
+use serde::Deserialize;
 
-#[derive(Debug, Clone)]
-pub struct ResolvedCommand {
-    pub commands: Vec<String>,
-    pub args: HashMap<String, String>,
+#[derive(Debug, Deserialize)]
+pub struct CommandConfig {
+    pub executions: HashMap<String, CommandAliases>,
+    pub settings: CommandSettings,
 }
 
-pub struct CommandResolver {
-    config: Config,
+#[derive(Debug, Deserialize)]
+pub struct CommandAliases {
+    pub aliases: Vec<String>,
 }
 
-impl CommandResolver {
-    pub fn new(config: &Config) -> Result<Self> {
-        Ok(Self {
-            config: config.clone(),
-        })
-    }
+#[derive(Debug, Deserialize)]
+pub struct CommandSettings {
+    pub contest: SettingPriority,
+    pub problem: SettingPriority,
+    pub language: HashMap<String, LanguageConfig>,
+    pub site: HashMap<String, SiteConfig>,
+}
 
-    fn get_executions(&self) -> Result<Vec<String>> {
-        let executions = self.config.get_all("executions")?
-            .into_iter()
-            .filter_map(|node| node.as_typed::<String>().ok())
-            .collect();
-        Ok(executions)
-    }
+#[derive(Debug, Deserialize)]
+pub struct SettingPriority {
+    pub priority: i32,
+}
 
-    fn get_settings(&self) -> Result<HashMap<String, String>> {
-        let settings = self.config.get_all("settings")?
-            .into_iter()
-            .filter_map(|node| {
-                let key = node.key().ok()?;
-                let value = node.as_typed::<String>().ok()?;
-                Some((key, value))
-            })
-            .collect();
-        Ok(settings)
-    }
+#[derive(Debug, Deserialize)]
+pub struct LanguageConfig {
+    pub aliases: Vec<String>,
+}
 
-    fn get_aliases(&self, command: &str) -> Result<Option<String>> {
-        let aliases: ConfigNode = self.config.get("aliases")?;
-        let alias = aliases.as_typed::<HashMap<String, String>>()
-            .ok()
-            .and_then(|map| map.get(command).cloned());
-        Ok(alias)
-    }
+#[derive(Debug, Deserialize)]
+pub struct SiteConfig {
+    pub aliases: Vec<String>,
+}
 
-    pub fn parse_command(&self, tokens: &[&str]) -> Result<(CommandType, HashMap<String, String>)> {
-        if tokens.is_empty() {
-            return Err(anyhow!("コマンドが空です"));
-        }
+impl FromConfigValue for CommandConfig {
+    fn from_config_value(value: &serde_yaml::Value) -> Result<Self> {
+        serde_yaml::from_value(value.clone())
+            .map_err(|e| anyhow!("CommandConfigへの変換に失敗: {}", e))
+    }
+}
 
-        let command = tokens[0].to_lowercase();
-        let args = tokens[1..].iter().map(|s| s.to_string()).collect::<Vec<_>>();
+pub struct CommandParser {
+    config: CommandConfig,
+}
 
-        match command.as_str() {
-            "test" => self.parse_test_command(&args),
-            "login" => self.parse_login_command(&args),
-            _ => Err(anyhow!("未知のコマンド: {}", command)),
-        }
+impl CommandParser {
+    pub fn new(config: &Config) -> Result<Self> {
+        let config: CommandConfig = config.get("commands")?;
+        Ok(Self { config })
     }
 
-    pub fn resolve(&self, input: &str) -> Result<ResolvedCommand> {
+    pub fn parse(&self, input: &str) -> Result<CommandContext> {
         let tokens: Vec<_> = input.split_whitespace().collect();
         if tokens.is_empty() {
             return Err(anyhow!("コマンドが空です"));
         }
 
-        let (command_type, args) = self.parse_command(&tokens)?;
-        let mut resolved = ResolvedCommand {
-            commands: vec![],
-            args,
-        };
+        let command = self.resolve_command(&tokens[0].to_lowercase())?;
+        let args = &tokens[1..];
 
-        match command_type {
-            CommandType::Test => {
-                resolved.commands.push("test".to_string());
-            }
-            CommandType::Login => {
-                resolved.commands.push("login".to_string());
-            }
-        }
+        let command = match command.as_str() {
+            "login" => Command::Login,
+            "open" => self.parse_open_command(args)?,
+            "test" => self.parse_test_command(args)?,
+            "submit" => Command::Submit,
+            _ => return Err(anyhow!("未知のコマンド: {}", command)),
+        };
 
-        Ok(resolved)
+        Ok(CommandContext::new(command))
     }
 
-    fn parse_test_command(&self, args: &[String]) -> Result<(CommandType, HashMap<String, String>)> {
-        let mut command_args = HashMap::new();
-        
-        if args.is_empty() {
-            return Err(anyhow!("テストコマンドには引数が必要です"));
+    fn resolve_command(&self, cmd: &str) -> Result<String> {
+        for (name, aliases) in &self.config.executions {
+            if name == cmd || aliases.aliases.iter().any(|a| a == cmd) {
+                return Ok(name.clone());
+            }
         }
+        Err(anyhow!("未知のコマンド: {}", cmd))
+    }
 
-        // 言語の解析
-        if let Some(language) = args.first() {
-            match language.to_lowercase().as_str() {
-                "rs" | "rust" => { command_args.insert("language".to_string(), "rust".to_string()); }
-                "py" | "python" | "python3" => { command_args.insert("language".to_string(), "python".to_string()); }
-                _ => {}
+    fn resolve_site(&self, site: &str) -> Result<String> {
+        for (name, config) in &self.config.settings.site {
+            if name == site || config.aliases.iter().any(|a| a == site) {
+                return Ok(name.clone());
             }
         }
+        Err(anyhow!("未知のサイト: {}", site))
+    }
 
-        // コンテストIDと問題IDの解析
-        if args.len() >= 3 {
-            command_args.insert("contest".to_string(), args[1].clone());
-            command_args.insert("problem".to_string(), args[2].clone());
-        } else if args.len() == 2 {
-            command_args.insert("problem_id".to_string(), args[1].clone());
+    fn parse_open_command(&self, args: &[&str]) -> Result<Command> {
+        if args.is_empty() {
+            return Err(anyhow!("サイトの指定が必要です"));
         }
 
-        Ok((CommandType::Test, command_args))
+        let site = self.resolve_site(&args[0].to_lowercase())?;
+        let (contest_id, problem_id) = match args.len() {
+            1 => (None, None),
+            2 => (Some(args[1].to_string()), None),
+            3 => (Some(args[1].to_string()), Some(args[2].to_string())),
+            _ => return Err(anyhow!("引数が多すぎます")),
+        };
+
+        Ok(Command::Open {
+            site,
+            contest_id,
+            problem_id,
+        })
     }
 
-    fn parse_login_command(&self, args: &[String]) -> Result<(CommandType, HashMap<String, String>)> {
-        let mut command_args = HashMap::new();
-        
-        if let Some(site) = args.first() {
-            match site.to_lowercase().as_str() {
-                "ac" | "atcoder" | "at-coder" => {
-                    command_args.insert("site".to_string(), "atcoder".to_string());
-                }
-                _ => {}
-            }
-        }
+    fn parse_test_command(&self, args: &[&str]) -> Result<Command> {
+        let test_number = match args.first() {
+            Some(num) => match num.parse() {
+                Ok(n) => Some(n),
+                Err(_) => None,
+            },
+            None => None,
+        };
 
-        Ok((CommandType::Login, command_args))
+        Ok(Command::Test { test_number })
     }
 }
 
-#[derive(Debug, PartialEq)]
-pub enum CommandType {
-    Test,
-    Login,
-}
-
 #[cfg(test)]
 mod tests {
     use super::*;
 
-    #[test]
-    fn test_basic_command_resolution() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("login").unwrap();
-        assert_eq!(result.commands, vec!["login"]);
-    }
-
-    #[test]
-    fn test_alias_resolution() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("auth").unwrap();
-        assert_eq!(result.commands, vec!["login"]);
-
-        let result = resolver.resolve("o").unwrap();
-        assert_eq!(result.commands, vec!["open"]);
-    }
-
-    #[test]
-    fn test_command_with_args() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("login test").unwrap();
-        assert_eq!(result.commands, vec!["login", "test"]);
-    }
-
-    #[test]
-    fn test_language_normalization() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("test rs abc001 a").unwrap();
-        assert_eq!(result.args.get("language").unwrap(), "rust");
-
-        let result = resolver.resolve("test RUST abc001 a").unwrap();
-        assert_eq!(result.args.get("language").unwrap(), "rust");
-
-        let result = resolver.resolve("test python3 abc001 a").unwrap();
-        assert_eq!(result.args.get("language").unwrap(), "python");
-    }
-
-    #[test]
-    fn test_site_normalization() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("login ac").unwrap();
-        assert_eq!(result.args.get("site").unwrap(), "atcoder");
-
-        let result = resolver.resolve("login at-coder").unwrap();
-        assert_eq!(result.args.get("site").unwrap(), "atcoder");
+    fn create_test_config() -> Config {
+        let yaml = r#"
+        commands:
+          executions:
+            login:
+              aliases: ["auth"]
+            open:
+              aliases: ["o", "show"]
+            test:
+              aliases: ["t", "check"]
+            submit:
+              aliases: ["s", "sub"]
+          settings:
+            contest:
+              priority: 2
+            problem:
+              priority: 1
+            language:
+              rust:
+                aliases: ["rs", "Rust", "RUST"]
+              python:
+                aliases: ["python", "python3"]
+              pypy:
+                aliases: ["pypy", "py", "pypy3"]
+              cpp:
+                aliases: ["cpp", "c++", "gcc"]
+            site:
+              atcoder:
+                aliases: ["ac", "at-coder", "at_coder"]
+        "#;
+        Config::from_str(yaml).unwrap()
     }
 
     #[test]
-    fn test_contest_problem_parsing() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("test abc001 a").unwrap();
-        assert!(result.args.contains_key("contest"));
-        assert!(result.args.contains_key("problem"));
-        assert_eq!(result.args.get("contest").unwrap(), "abc001");
-        assert_eq!(result.args.get("problem").unwrap(), "a");
-
-        let result = resolver.resolve("test other_format").unwrap();
-        assert_eq!(result.args.get("problem_id").unwrap(), "other_format");
-    }
+    fn test_parse_login() {
+        let config = create_test_config();
+        let parser = CommandParser::new(&config).unwrap();
 
-    #[test]
-    fn test_contest_id_extraction() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
+        let result = parser.parse("login").unwrap();
+        assert!(matches!(result.command, Command::Login));
 
-        let result = resolver.resolve("test abc001 a").unwrap();
-        assert_eq!(result.args.get("contest").unwrap(), "abc001");
+        let result = parser.parse("auth").unwrap();
+        assert!(matches!(result.command, Command::Login));
     }
 
     #[test]
-    fn test_problem_id_extraction() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("test abc001 a").unwrap();
-        assert_eq!(result.args.get("problem").unwrap(), "a");
+    fn test_parse_open() {
+        let config = create_test_config();
+        let parser = CommandParser::new(&config).unwrap();
+
+        let result = parser.parse("open atcoder abc001 a").unwrap();
+        if let Command::Open { site, contest_id, problem_id } = result.command {
+            assert_eq!(site, "atcoder");
+            assert_eq!(contest_id, Some("abc001".to_string()));
+            assert_eq!(problem_id, Some("a".to_string()));
+        } else {
+            panic!("Expected Open command");
+        }
     }
 
     #[test]
-    fn test_full_command_parsing() {
-        let config = Config::default();
-        let resolver = CommandResolver::new(&config).unwrap();
-
-        let result = resolver.resolve("test rs abc001 a").unwrap();
-        assert!(result.args.contains_key("language"));
-        assert!(result.args.contains_key("contest"));
-        assert!(result.args.contains_key("problem"));
-    }
-
-    mod error_tests {
-        use super::*;
-
-        #[test]
-        fn test_invalid_command_format() {
-            let config = Config::default();
-            let resolver = CommandResolver::new(&config).unwrap();
-
-            let result = resolver.resolve("");
-            assert!(result.is_err());
+    fn test_parse_test() {
+        let config = create_test_config();
+        let parser = CommandParser::new(&config).unwrap();
+
+        let result = parser.parse("test 1").unwrap();
+        if let Command::Test { test_number } = result.command {
+            assert_eq!(test_number, Some(1));
+        } else {
+            panic!("Expected Test command");
         }
 
-        #[test]
-        fn test_unknown_command() {
-            let config = Config::default();
-            let resolver = CommandResolver::new(&config).unwrap();
-
-            let result = resolver.resolve("unknown_command");
-            assert!(result.is_err());
+        let result = parser.parse("test").unwrap();
+        if let Command::Test { test_number } = result.command {
+            assert_eq!(test_number, None);
+        } else {
+            panic!("Expected Test command");
         }
+    }
 
-        #[test]
-        fn test_invalid_site() {
-            let config = Config::default();
-            let resolver = CommandResolver::new(&config).unwrap();
-
-            let result = resolver.resolve("login invalid_site").unwrap();
-            assert!(!result.args.contains_key("site"));
-        }
+    #[test]
+    fn test_parse_submit() {
+        let config = create_test_config();
+        let parser = CommandParser::new(&config).unwrap();
 
-        #[test]
-        fn test_invalid_language() {
-            let config = Config::default();
-            let resolver = CommandResolver::new(&config).unwrap();
+        let result = parser.parse("submit").unwrap();
+        assert!(matches!(result.command, Command::Submit));
 
-            let result = resolver.resolve("test invalid_lang abc001_a").unwrap();
-            assert!(!result.args.contains_key("language"));
-        }
+        let result = parser.parse("s").unwrap();
+        assert!(matches!(result.command, Command::Submit));
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index fb8ad1c..3ff14d8 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -1,4 +1,5 @@
 use anyhow::{Result, anyhow};
+use crate::config::Config;
 use crate::contest::model::{Contest, TestCase};
 use crate::fs::manager::FileManager;
 
@@ -10,6 +11,7 @@ pub struct ContestService {
     language: Option<String>,
     url: Option<String>,
     file_manager: Option<FileManager>,
+    config: Config,
 }
 
 // 状態遷移を表現する型
@@ -24,15 +26,16 @@ pub enum ServiceTransition {
 }
 
 impl ContestService {
-    pub fn new() -> Self {
-        Self {
+    pub fn new(config: &Config) -> Result<Self> {
+        Ok(Self {
             site: None,
             contest_id: None,
             problem_id: None,
             language: None,
             url: None,
             file_manager: None,
-        }
+            config: config.clone(),
+        })
     }
 
     // アクセサメソッド
@@ -195,4 +198,18 @@ impl ContestService {
         let file_manager = Self::save_test_cases(&contest, file_manager, test_cases)?;
         Ok((contest, file_manager))
     }
+
+    // コマンド実行用のメソッド
+    pub fn open(&self, site: String, contest_id: Option<String>, problem_id: Option<String>) -> Result<()> {
+        // TODO: 実際のブラウザでの問題ページを開く処理を実装
+        println!("問題を開きます: site={}, contest={:?}, problem={:?}", 
+            site, contest_id, problem_id);
+        Ok(())
+    }
+
+    pub fn submit(&self, contest: &Contest) -> Result<()> {
+        // TODO: 実際の提出処理を実装
+        println!("提出を行います: contest={:?}", contest);
+        Ok(())
+    }
 } 
\ No newline at end of file
diff --git a/src/contest/service/mod.rs b/src/contest/service/mod.rs
index a9443bb..8902a34 100644
--- a/src/contest/service/mod.rs
+++ b/src/contest/service/mod.rs
@@ -2,8 +2,10 @@ pub mod contest;
 pub mod path;
 pub mod test;
 pub mod url;
+pub mod command;
 
 pub use contest::ContestService;
 pub use path::PathService;
 pub use test::TestService;
-pub use url::UrlService; 
\ No newline at end of file
+pub use url::UrlService;
+pub use command::CommandService; 
\ No newline at end of file
diff --git a/src/contest/service/test.rs b/src/contest/service/test.rs
index 444fe08..b20abbc 100644
--- a/src/contest/service/test.rs
+++ b/src/contest/service/test.rs
@@ -1,69 +1,24 @@
-use std::path::{Path, PathBuf};
-use anyhow::{Result, anyhow};
-use crate::contest::model::TestCase;
+use anyhow::Result;
+use crate::config::Config;
+use crate::contest::model::Contest;
 
-pub struct TestService;
+pub struct TestService {
+    config: Config,
+}
 
 impl TestService {
-    pub fn new() -> Self {
-        Self
+    pub fn new(config: &Config) -> Result<Self> {
+        Ok(Self {
+            config: config.clone(),
+        })
     }
 
-    pub fn read_test_case(&self, input_path: impl AsRef<Path>) -> Result<TestCase> {
-        let input_path = input_path.as_ref();
-        let expected_path = input_path.with_extension("out");
-
-        let input = std::fs::read_to_string(input_path)
-            .map_err(|e| anyhow!(
-                "入力ファイルの読み取りに失敗しました: {:?}, {}", input_path, e
-            ))?;
-
-        let expected = std::fs::read_to_string(&expected_path)
-            .map_err(|e| anyhow!(
-                "期待値ファイルの読み取りに失敗しました: {:?}, {}", expected_path, e
-            ))?;
-
-        Ok(TestCase::new(input, expected))
-    }
-
-    pub fn find_test_files(&self, test_dir: impl AsRef<Path>) -> Result<Vec<PathBuf>> {
-        let test_dir = test_dir.as_ref();
-        if !test_dir.exists() {
-            return Err(anyhow!(
-                "テストディレクトリが見つかりません: {}", test_dir.display()
-            ));
+    pub fn run_test(&self, _contest: &Contest, test_number: Option<usize>) -> Result<()> {
+        // TODO: 実際のテスト実行処理を実装
+        match test_number {
+            Some(n) => println!("テストケース {} を実行します", n),
+            None => println!("全てのテストケースを実行します"),
         }
-
-        let entries = std::fs::read_dir(test_dir)
-            .map_err(|e| anyhow!(
-                "テストディレクトリの読み取りに失敗しました: {}", e
-            ))?;
-
-        entries
-            .filter_map(|entry| {
-                entry.ok().and_then(|e| {
-                    let path = e.path();
-                    if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-                        let expected_path = path.with_extension("out");
-                        if expected_path.exists() {
-                            Some(Ok(path))
-                        } else {
-                            Some(Err(anyhow!(
-                                "期待値ファイルが見つかりません: {:?}", expected_path
-                            )))
-                        }
-                    } else {
-                        None
-                    }
-                })
-            })
-            .collect()
-    }
-
-    pub fn read_test_cases(&self, test_dir: impl AsRef<Path>) -> Result<Vec<TestCase>> {
-        self.find_test_files(test_dir)?
-            .into_iter()
-            .map(|path| self.read_test_case(&path))
-            .collect()
+        Ok(())
     }
 } 
\ No newline at end of file
