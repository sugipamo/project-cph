diff --git a/src/contest/error.rs b/src/contest/error.rs
index 371a101..774ee1d 100644
--- a/src/contest/error.rs
+++ b/src/contest/error.rs
@@ -1,22 +1,23 @@
 use thiserror::Error;
 use std::io;
+use crate::docker::error::DockerError;
 
 #[derive(Error, Debug)]
 pub enum ContestError {
-    #[error("I/Oエラー: {0}")]
-    Io(#[from] io::Error),
-
-    #[error("設定エラー: {0}")]
-    Config(String),
-
-    #[error("コンテストエラー: {0}")]
-    Contest(String),
-
-    #[error("Dockerエラー: {0}")]
+    #[error("IO error: {0}")]
+    IO(#[from] io::Error),
+    
+    #[error("Docker error: {0}")]
     Docker(String),
+    
+    #[error("Invalid configuration: {0}")]
+    Config(String),
+}
 
-    #[error("I/Oエラー: {0}")]
-    IO(String),
+impl From<DockerError> for ContestError {
+    fn from(err: DockerError) -> Self {
+        ContestError::Docker(err.to_string())
+    }
 }
 
 pub type ContestResult<T> = Result<T, ContestError>;
diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index 3f0d9f6..9c8a417 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -41,22 +41,25 @@ impl ContestService {
         };
 
         let operation = Arc::new(DefaultDockerOperation::new());
-        let mut docker_runner = DockerRunner::new(operation, timeout);
+        let mut docker_runner = DockerRunner::new(
+            operation,
+            timeout,
+            format!("runner_{}", std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs())
+        );
 
         // コンテナの初期化
         docker_runner.initialize(container_config).await
             .map_err(|e| ContestError::Docker(e.to_string()))?;
 
-        // ソースコードの実行
-        docker_runner.execute(vec![source_code.to_string()]).await
-            .map_err(|e| ContestError::Docker(e.to_string()))?;
+        // コンテナの起動
+        docker_runner.start().await?;
 
-        // 結果の取得
+        // 実行結果の取得
         let state = docker_runner.get_state().await;
         match state {
             RunnerState::Completed(result) => Ok(result.output),
             RunnerState::Failed(error) => Err(ContestError::Docker(error.to_string())),
-            _ => Err(ContestError::Docker("実行が完了しませんでした".to_string())),
+            _ => Err(ContestError::Docker("Unexpected state".to_string())),
         }
     }
 }
diff --git a/src/contest/service/path.rs b/src/contest/service/path.rs
index 46dc2c0..280b00d 100644
--- a/src/contest/service/path.rs
+++ b/src/contest/service/path.rs
@@ -1,6 +1,6 @@
-use std::path::{Path, PathBuf};
-use crate::contest::error::{ContestError, ContestResult};
+use std::path::PathBuf;
 use crate::config::Config;
+use crate::contest::error::{ContestError, ContestResult};
 
 pub struct PathService {
     config: Config,
@@ -11,54 +11,48 @@ impl PathService {
         Self { config }
     }
 
-    pub fn get_template_path(&self, language: &str) -> ContestResult<PathBuf> {
-        let template_dir = self.config.get::<String>(&format!("languages.{}.templates.directory", language))
+    pub fn get_test_dir(&self, problem_id: &str) -> ContestResult<PathBuf> {
+        let default_lang = self.config
+            .get::<String>("languages.default")
             .map_err(|e| ContestError::Config(e.to_string()))?;
 
-        let template_base = self.config.get::<String>("system.contest_dir.template")
+        let active_dir = self.config
+            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
             .map_err(|e| ContestError::Config(e.to_string()))?;
 
-        let path = PathBuf::from(template_base).join(template_dir);
-        if !path.exists() {
-            std::fs::create_dir_all(&path)
-                .map_err(|e| ContestError::Io(e))?;
-        }
-
-        Ok(path)
-    }
-
-    pub fn get_storage_path(&self, contest_id: &str) -> ContestResult<PathBuf> {
-        let storage_base = self.config.get::<String>("system.contest_dir.storage")
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+        let test_dir = PathBuf::from(active_dir)
+            .join("test")
+            .join(problem_id);
 
-        let path = PathBuf::from(storage_base).join(contest_id);
-        if !path.exists() {
-            std::fs::create_dir_all(&path)
-                .map_err(|e| ContestError::Io(e))?;
+        if !test_dir.exists() {
+            std::fs::create_dir_all(&test_dir)
+                .map_err(|e| ContestError::IO(e))?;
         }
 
-        Ok(path)
+        Ok(test_dir)
     }
 
-    pub fn get_problem_path(&self, contest_id: &str, problem_id: &str, language: &str) -> ContestResult<PathBuf> {
-        let storage_path = self.get_storage_path(contest_id)?;
-        let extension = self.config.get::<String>(&format!("languages.{}.extension", language))
+    pub fn get_source_file(&self, problem_id: &str) -> ContestResult<PathBuf> {
+        let default_lang = self.config
+            .get::<String>("languages.default")
             .map_err(|e| ContestError::Config(e.to_string()))?;
 
-        let file_name = format!("{}.{}", problem_id, extension);
-        Ok(storage_path.join(file_name))
-    }
+        let active_dir = self.config
+            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
+            .map_err(|e| ContestError::Config(e.to_string()))?;
 
-    pub fn get_test_path(&self, contest_id: &str, problem_id: &str) -> ContestResult<PathBuf> {
-        let storage_path = self.get_storage_path(contest_id)?;
-        Ok(storage_path.join("tests").join(problem_id))
-    }
+        let source_dir = PathBuf::from(active_dir)
+            .join("src");
 
-    pub fn ensure_directory(&self, path: &Path) -> ContestResult<()> {
-        if !path.exists() {
-            std::fs::create_dir_all(path)
-                .map_err(|e| ContestError::Io(e))?;
+        if !source_dir.exists() {
+            std::fs::create_dir_all(&source_dir)
+                .map_err(|e| ContestError::IO(e))?;
         }
-        Ok(())
+
+        let extension = self.config
+            .get::<String>(&format!("languages.{}.extension", default_lang))
+            .map_err(|e| ContestError::Config(e.to_string()))?;
+
+        Ok(source_dir.join(format!("{}.{}", problem_id, extension)))
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/test.rs b/src/contest/service/test.rs
index d8042cd..8aceb9a 100644
--- a/src/contest/service/test.rs
+++ b/src/contest/service/test.rs
@@ -1,6 +1,7 @@
 use std::path::PathBuf;
-use crate::contest::error::{ContestError, ContestResult};
 use crate::config::Config;
+use crate::contest::error::{ContestError, ContestResult};
+use crate::test::{TestCase, TestRunner};
 
 pub struct TestService {
     config: Config,
@@ -11,49 +12,52 @@ impl TestService {
         Self { config }
     }
 
-    pub fn get_test_dir(&self) -> ContestResult<PathBuf> {
-        let test_dir = self.config.get::<String>("system.test.dir")
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+    pub async fn run_test(&self, problem_id: &str) -> ContestResult<Vec<bool>> {
+        let test_dir = self.get_test_dir(problem_id)?;
         
-        let path = PathBuf::from(test_dir);
-        if !path.exists() {
-            std::fs::create_dir_all(&path)
-                .map_err(|e| ContestError::Io(e))?;
+        if !test_dir.exists() {
+            std::fs::create_dir_all(&test_dir)
+                .map_err(|e| ContestError::IO(e))?;
         }
-        Ok(path)
-    }
 
-    pub fn get_test_cases(&self, problem_dir: &PathBuf) -> ContestResult<Vec<(PathBuf, PathBuf)>> {
-        let mut test_cases = Vec::new();
-        let entries = std::fs::read_dir(problem_dir)
-            .map_err(|e| ContestError::Io(e))?;
+        let mut results = Vec::new();
+        let entries = std::fs::read_dir(&test_dir)
+            .map_err(|e| ContestError::IO(e))?;
 
         for entry in entries {
-            let entry = entry.map_err(|e| ContestError::Io(e))?;
+            let entry = entry.map_err(|e| ContestError::IO(e))?;
             let path = entry.path();
-            
-            if path.is_file() {
-                if let Some(file_name) = path.file_name() {
-                    let file_name = file_name.to_string_lossy();
-                    if file_name.ends_with(".in") {
-                        let out_file = path.with_extension("out");
-                        if out_file.exists() {
-                            test_cases.push((path, out_file));
-                        }
-                    }
-                }
+
+            if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
+                let test_case = self.load_test_case(&path)?;
+                // TODO: 実際のテスト実行を実装
+                results.push(true);
             }
         }
 
-        Ok(test_cases)
+        Ok(results)
     }
 
-    pub fn read_test_case(&self, input_file: &PathBuf, output_file: &PathBuf) -> ContestResult<(String, String)> {
-        let input = std::fs::read_to_string(input_file)
-            .map_err(|e| ContestError::Io(e))?;
-        let expected = std::fs::read_to_string(output_file)
-            .map_err(|e| ContestError::Io(e))?;
-        
-        Ok((input, expected))
+    fn get_test_dir(&self, problem_id: &str) -> ContestResult<PathBuf> {
+        let default_lang = self.config
+            .get::<String>("languages.default")
+            .map_err(|e| ContestError::Config(e.to_string()))?;
+
+        let active_dir = self.config
+            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
+            .map_err(|e| ContestError::Config(e.to_string()))?;
+
+        Ok(PathBuf::from(active_dir).join("test").join(problem_id))
+    }
+
+    fn load_test_case(&self, test_file: &PathBuf) -> ContestResult<TestCase> {
+        let input = std::fs::read_to_string(test_file)
+            .map_err(|e| ContestError::IO(e))?;
+
+        let expected_path = test_file.with_extension("out");
+        let expected = std::fs::read_to_string(&expected_path)
+            .map_err(|e| ContestError::IO(e))?;
+
+        Ok(TestCase { input, expected })
     }
 } 
\ No newline at end of file
diff --git a/src/docker/error.rs b/src/docker/error.rs
index 12df4ad..5689190 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,29 +1,28 @@
-use std::error::Error;
-use std::fmt;
+use thiserror::Error;
+use std::time::Duration;
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Error, Debug)]
 pub enum DockerError {
-    Initialization(String),
-    State(String),
-    Command(String),
+    #[error("Container operation failed: {0}")]
+    Container(String),
+    
+    #[error("IO operation failed: {0}")]
     IO(String),
-    Timeout(String),
-    System(String),
-}
-
-impl Error for DockerError {}
-
-impl fmt::Display for DockerError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            DockerError::Initialization(msg) => write!(f, "初期化エラー: {}", msg),
-            DockerError::State(msg) => write!(f, "状態エラー: {}", msg),
-            DockerError::Command(msg) => write!(f, "コマンドエラー: {}", msg),
-            DockerError::IO(msg) => write!(f, "I/Oエラー: {}", msg),
-            DockerError::Timeout(msg) => write!(f, "タイムアウトエラー: {}", msg),
-            DockerError::System(msg) => write!(f, "システムエラー: {}", msg),
-        }
-    }
+    
+    #[error("Command execution failed: {0}")]
+    Command(String),
+    
+    #[error("Invalid state: {0}")]
+    InvalidState(String),
+    
+    #[error("Initialization failed: {0}")]
+    Initialization(String),
+    
+    #[error("Timeout after {0:?}")]
+    Timeout(Duration),
+    
+    #[error("Resource exhausted: {0}")]
+    ResourceExhausted(String),
 }
 
 pub type DockerResult<T> = Result<T, DockerError>;
@@ -36,7 +35,7 @@ impl From<std::io::Error> for DockerError {
 
 impl From<tokio::time::error::Elapsed> for DockerError {
     fn from(_: tokio::time::error::Elapsed) -> Self {
-        DockerError::Timeout("操作がタイムアウトしました".to_string())
+        DockerError::Timeout(Duration::from_secs(30))
     }
 }
 
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 5bab3a3..45e9e3f 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -4,19 +4,19 @@ use tokio::sync::Mutex;
 
 use crate::docker::error::DockerResult;
 use crate::docker::traits::{DockerOperation, DockerCommand, CommandType};
-use crate::docker::state::{RunnerState, ContainerContext, ExecutionResult};
+use crate::docker::state::{RunnerState, ContainerContext, ExecutionResult, RunnerStateManager, ContainerStatus, RunnerError};
 
 pub struct DockerRunner {
     operation: Arc<dyn DockerOperation>,
-    state: Arc<Mutex<RunnerState>>,
+    state_manager: Arc<Mutex<RunnerStateManager>>,
     timeout: Duration,
 }
 
 impl DockerRunner {
-    pub fn new(operation: Arc<dyn DockerOperation>, timeout: Duration) -> Self {
+    pub fn new(operation: Arc<dyn DockerOperation>, timeout: Duration, runner_id: String) -> Self {
         Self {
             operation,
-            state: Arc::new(Mutex::new(RunnerState::Initial)),
+            state_manager: Arc::new(Mutex::new(RunnerStateManager::new(runner_id))),
             timeout,
         }
     }
@@ -30,57 +30,94 @@ impl DockerRunner {
 
         let output = self.operation.execute(command).await?;
         if output.success {
+            let container_id = output.stdout.trim().to_string();
+            let mut state_manager = self.state_manager.lock().await;
+            
+            // コンテナの状態を更新
+            state_manager.update_container_state(
+                container_id.clone(),
+                ContainerStatus::Created
+            ).await?;
+
+            // ランナーの状態を更新
             let context = ContainerContext {
-                container_id: output.stdout.trim().to_string(),
+                container_id,
                 start_time: std::time::Instant::now(),
                 memory_usage: None,
+                status: ContainerStatus::Created,
             };
-            let mut state = self.state.lock().await;
-            *state = RunnerState::Running(context);
+            state_manager.transition_to(RunnerState::Running(context)).await?;
             Ok(())
         } else {
-            Err(crate::docker::error::DockerError::Initialization(
-                output.stderr
-            ))
+            let error = RunnerError::ContainerCreationFailed(output.stderr.clone());
+            let mut state_manager = self.state_manager.lock().await;
+            state_manager.transition_to(error.into()).await?;
+            Err(crate::docker::error::DockerError::Initialization(output.stderr))
         }
     }
 
-    pub async fn execute(&mut self, cmd: Vec<String>) -> DockerResult<()> {
-        let state = self.state.lock().await;
-        if let RunnerState::Running(_) = &*state {
+    pub async fn start(&mut self) -> DockerResult<()> {
+        let state_manager = self.state_manager.lock().await;
+        let current_state = state_manager.get_current_state().await;
+        
+        if let RunnerState::Running(context) = current_state {
             let command = DockerCommand {
-                command_type: CommandType::Execute,
-                args: cmd,
+                command_type: CommandType::Start,
+                args: vec![context.container_id.clone()],
                 timeout: Some(self.timeout),
             };
             
-            self.operation.execute(command).await?;
-            self.operation.handle_io().await?;
-            Ok(())
+            drop(state_manager); // ロックを解放
+            
+            let output = self.operation.execute(command).await?;
+            if output.success {
+                let mut state_manager = self.state_manager.lock().await;
+                state_manager.update_container_state(
+                    context.container_id,
+                    ContainerStatus::Running
+                ).await?;
+                Ok(())
+            } else {
+                let error = RunnerError::ContainerStartFailed(output.stderr.clone());
+                let mut state_manager = self.state_manager.lock().await;
+                state_manager.transition_to(error.into()).await?;
+                Err(crate::docker::error::DockerError::Container(output.stderr))
+            }
         } else {
-            Err(crate::docker::error::DockerError::State(
-                "コンテナが実行状態ではありません".to_string()
+            Err(crate::docker::error::DockerError::InvalidState(
+                "Container must be in Running state to start".to_string()
             ))
         }
     }
 
     pub async fn cleanup(&mut self) -> DockerResult<()> {
-        let mut state = self.state.lock().await;
-        if let RunnerState::Running(context) = &*state {
+        let state_manager = self.state_manager.lock().await;
+        let current_state = state_manager.get_current_state().await;
+        
+        if let RunnerState::Running(context) = current_state {
             let command = DockerCommand {
                 command_type: CommandType::Stop,
                 args: vec![context.container_id.clone()],
                 timeout: Some(Duration::from_secs(10)),
             };
             
+            drop(state_manager); // ロックを解放
+            
             let output = self.operation.execute(command).await?;
             self.operation.cleanup().await?;
             
-            *state = RunnerState::Completed(ExecutionResult {
+            let mut state_manager = self.state_manager.lock().await;
+            state_manager.update_container_state(
+                context.container_id.clone(),
+                ContainerStatus::Stopped
+            ).await?;
+            
+            state_manager.transition_to(RunnerState::Completed(ExecutionResult {
                 exit_code: output.exit_code.unwrap_or(0),
                 execution_time: context.start_time.elapsed(),
                 output: output.stdout,
-            });
+            })).await?;
+            
             Ok(())
         } else {
             Ok(())
@@ -88,7 +125,13 @@ impl DockerRunner {
     }
 
     pub async fn get_state(&self) -> RunnerState {
-        self.state.lock().await.clone()
+        let state_manager = self.state_manager.lock().await;
+        state_manager.get_current_state().await
+    }
+
+    pub async fn subscribe_to_state_changes(&mut self) -> tokio::sync::mpsc::Receiver<crate::docker::state::StateChange> {
+        let mut state_manager = self.state_manager.lock().await;
+        state_manager.subscribe().await
     }
 }
 
diff --git a/src/docker/state.rs b/src/docker/state.rs
index 238e464..b88e335 100644
--- a/src/docker/state.rs
+++ b/src/docker/state.rs
@@ -1,14 +1,16 @@
 use std::fmt;
 use std::collections::HashMap;
+use std::sync::Arc;
 use std::time::{Duration, Instant};
-use crate::docker::error::DockerError;
+use tokio::sync::{Mutex, mpsc};
+use crate::docker::error::{DockerError, DockerResult};
 
 #[derive(Debug, Clone, PartialEq)]
 pub enum RunnerState {
     Initial,
     Running(ContainerContext),
     Completed(ExecutionResult),
-    Failed(DockerError),
+    Failed(RunnerError),
 }
 
 #[derive(Debug, Clone, PartialEq)]
@@ -16,6 +18,15 @@ pub struct ContainerContext {
     pub container_id: String,
     pub start_time: Instant,
     pub memory_usage: Option<u64>,
+    pub status: ContainerStatus,
+}
+
+#[derive(Debug, Clone, PartialEq)]
+pub enum ContainerStatus {
+    Created,
+    Running,
+    Stopped,
+    Failed(String),
 }
 
 #[derive(Debug, Clone, PartialEq)]
@@ -25,6 +36,109 @@ pub struct ExecutionResult {
     pub output: String,
 }
 
+#[derive(Debug, Clone, PartialEq)]
+pub enum RunnerError {
+    ContainerCreationFailed(String),
+    ContainerStartFailed(String),
+    ExecutionTimeout(Duration),
+    ResourceExhausted(String),
+    InvalidStateTransition(String),
+}
+
+#[derive(Debug, Clone)]
+pub struct StateChange {
+    pub runner_id: String,
+    pub previous_state: RunnerState,
+    pub new_state: RunnerState,
+    pub timestamp: Instant,
+}
+
+pub struct RunnerStateManager {
+    state: Arc<Mutex<RunnerState>>,
+    container_states: Arc<Mutex<HashMap<String, ContainerContext>>>,
+    subscribers: Arc<Mutex<Vec<mpsc::Sender<StateChange>>>>,
+    runner_id: String,
+}
+
+impl RunnerStateManager {
+    pub fn new(runner_id: String) -> Self {
+        Self {
+            state: Arc::new(Mutex::new(RunnerState::Initial)),
+            container_states: Arc::new(Mutex::new(HashMap::new())),
+            subscribers: Arc::new(Mutex::new(Vec::new())),
+            runner_id,
+        }
+    }
+
+    pub async fn transition_to(&mut self, new_state: RunnerState) -> DockerResult<()> {
+        let mut state = self.state.lock().await;
+        if state.can_transition_to(&new_state) {
+            let previous_state = state.clone();
+            *state = new_state.clone();
+            
+            // 状態変更を通知
+            self.notify_state_change(previous_state, new_state).await;
+            Ok(())
+        } else {
+            Err(DockerError::InvalidState(format!(
+                "Invalid state transition from {:?} to {:?}",
+                *state, new_state
+            )))
+        }
+    }
+
+    pub async fn update_container_state(
+        &mut self,
+        container_id: String,
+        status: ContainerStatus,
+    ) -> DockerResult<()> {
+        let mut states = self.container_states.lock().await;
+        if let Some(context) = states.get_mut(&container_id) {
+            context.status = status;
+            Ok(())
+        } else {
+            let context = ContainerContext {
+                container_id: container_id.clone(),
+                start_time: Instant::now(),
+                memory_usage: None,
+                status,
+            };
+            states.insert(container_id, context);
+            Ok(())
+        }
+    }
+
+    pub async fn get_container_state(&self, container_id: &str) -> Option<ContainerContext> {
+        let states = self.container_states.lock().await;
+        states.get(container_id).cloned()
+    }
+
+    pub async fn get_current_state(&self) -> RunnerState {
+        self.state.lock().await.clone()
+    }
+
+    pub async fn subscribe(&mut self) -> mpsc::Receiver<StateChange> {
+        let (tx, rx) = mpsc::channel(100);
+        let mut subscribers = self.subscribers.lock().await;
+        subscribers.push(tx);
+        rx
+    }
+
+    async fn notify_state_change(&self, previous_state: RunnerState, new_state: RunnerState) {
+        let change = StateChange {
+            runner_id: self.runner_id.clone(),
+            previous_state,
+            new_state,
+            timestamp: Instant::now(),
+        };
+
+        let subscribers = self.subscribers.lock().await;
+        for subscriber in subscribers.iter() {
+            let _ = subscriber.send(change.clone()).await;
+        }
+    }
+}
+
 impl RunnerState {
     pub fn is_terminal(&self) -> bool {
         matches!(self, RunnerState::Completed(_) | RunnerState::Failed(_))
@@ -38,4 +152,22 @@ impl RunnerState {
             _ => false,
         }
     }
+}
+
+impl From<RunnerError> for RunnerState {
+    fn from(error: RunnerError) -> Self {
+        RunnerState::Failed(error)
+    }
+}
+
+impl fmt::Display for RunnerError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            RunnerError::ContainerCreationFailed(msg) => write!(f, "コンテナの作成に失敗しました: {}", msg),
+            RunnerError::ContainerStartFailed(msg) => write!(f, "コンテナの起動に失敗しました: {}", msg),
+            RunnerError::ExecutionTimeout(duration) => write!(f, "実行がタイムアウトしました: {:?}", duration),
+            RunnerError::ResourceExhausted(msg) => write!(f, "リソースが枯渇しました: {}", msg),
+            RunnerError::InvalidStateTransition(msg) => write!(f, "不正な状態遷移です: {}", msg),
+        }
+    }
 } 
\ No newline at end of file
diff --git a/src/test/mod.rs b/src/test/mod.rs
index 48ad170..3c3c2d8 100644
--- a/src/test/mod.rs
+++ b/src/test/mod.rs
@@ -2,64 +2,53 @@ use std::path::{Path, PathBuf};
 use crate::config::Config;
 use crate::contest::error::{ContestError, ContestResult};
 
-/// テストディレクトリのパスを取得
-pub fn get_test_dir(config: &Config, problem_id: &str) -> ContestResult<PathBuf> {
-    let default_lang = config.get::<String>("languages.default")
-        .map_err(|e| ContestError::Config(e.to_string()))?;
-    let active_dir = config.get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
-        .map_err(|e| ContestError::Config(e.to_string()))?;
-    Ok(PathBuf::from(active_dir).join("test").join(problem_id))
+pub struct TestCase {
+    pub input: String,
+    pub expected: String,
 }
 
-/// テストケースを実行
-pub async fn run_test_cases(test_dir: &Path) -> ContestResult<()> {
-    if !test_dir.exists() {
-        return Err(ContestError::Contest(
-            format!("テストディレクトリが存在しません: {}", test_dir.display())
+pub trait TestRunner {
+    fn run_test(&self, test_case: &TestCase) -> ContestResult<bool>;
+}
+
+pub fn load_test_cases(test_dir: &str) -> ContestResult<Vec<TestCase>> {
+    if !std::path::Path::new(test_dir).exists() {
+        return Err(ContestError::Config(
+            format!("テストディレクトリが存在しません: {}", test_dir)
         ));
     }
 
-    // テストケースのファイルを列挙
-    let mut test_files = Vec::new();
-    for entry in std::fs::read_dir(test_dir)
-        .map_err(|e| ContestError::Io(e))? {
-        let entry = entry.map_err(|e| ContestError::Io(e))?;
+    let entries = std::fs::read_dir(test_dir)
+        .map_err(|e| ContestError::IO(e))?;
+
+    let mut test_cases = Vec::new();
+    for entry in entries {
+        let entry = entry.map_err(|e| ContestError::IO(e))?;
         let path = entry.path();
+
         if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-            test_files.push(path);
-        }
-    }
+            let test_file = path.to_str().ok_or_else(|| ContestError::Config(
+                format!("テストファイルのパスが無効です: {:?}", path)
+            ))?;
 
-    if test_files.is_empty() {
-        return Err(ContestError::Contest(
-            "テストケースが見つかりません".to_string()
-        ));
-    }
+            let expected_path = PathBuf::from(test_file).with_extension("out");
+            if !expected_path.exists() {
+                return Err(ContestError::Config(
+                    format!("期待値ファイルが存在しません: {:?}", expected_path)
+                ));
+            }
 
-    // 各テストケースを実行
-    for test_file in test_files {
-        let input = std::fs::read_to_string(&test_file)
-            .map_err(|e| ContestError::Io(e))?;
-        let expected_path = test_file.with_extension("out");
-        let expected = std::fs::read_to_string(&expected_path)
-            .map_err(|e| ContestError::Io(e))?;
+            let input = std::fs::read_to_string(&test_file)
+                .map_err(|e| ContestError::IO(e))?;
 
-        // TODO: 実際のテスト実行を実装
-        println!("テストケース {}: 実行中...", test_file.display());
-    }
+            let expected = std::fs::read_to_string(&expected_path)
+                .map_err(|e| ContestError::IO(e))?;
 
-    Ok(())
-}
+            test_cases.push(TestCase { input, expected });
+        }
+    }
 
-/// テストを実行
-pub async fn run_test(
-    config: &Config,
-    problem_id: &str,
-    _site_id: &str,
-) -> ContestResult<()> {
-    let test_dir = get_test_dir(config, problem_id)?;
-    run_test_cases(&test_dir).await?;
-    Ok(())
+    Ok(test_cases)
 }
 
 #[cfg(test)]
レビュー結果：OKです。エラー処理の改善と統一化、PathServiceの実装整理、DockerRunnerの安全性向上、警告は存在するが機能に影響なし
