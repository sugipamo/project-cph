diff --git a/src/docker/state/manager.rs b/src/docker/state/manager.rs
index d576e5f..44ba322 100644
--- a/src/docker/state/manager.rs
+++ b/src/docker/state/manager.rs
@@ -1,6 +1,5 @@
 use std::sync::Arc;
 use std::time::{SystemTime, Duration};
-use tokio::sync::RwLock;
 use crate::error::Result;
 use super::ContainerState;
 use crate::docker::error::state_err;
@@ -33,65 +32,107 @@ pub enum StateTransition {
 
 #[derive(Debug, Clone)]
 pub struct ContainerStateManager {
-    state: Arc<RwLock<ContainerState>>,
-    history: Arc<RwLock<Vec<StateTransitionInfo>>>,
+    state: Arc<ContainerState>,
+    history: Arc<Vec<StateTransitionInfo>>,
 }
 
 impl ContainerStateManager {
     pub fn new() -> Self {
         Self {
-            state: Arc::new(RwLock::new(ContainerState::new())),
-            history: Arc::new(RwLock::new(Vec::new())),
+            state: Arc::new(ContainerState::new()),
+            history: Arc::new(Vec::new()),
         }
     }
 
-    pub async fn get_current_state(&self) -> ContainerState {
-        self.state.read().await.clone()
+    pub fn get_current_state(&self) -> ContainerState {
+        (*self.state).clone()
     }
 
-    pub async fn get_transition_history(&self) -> Vec<StateTransitionInfo> {
-        self.history.read().await.clone()
+    pub fn get_transition_history(&self) -> Vec<StateTransitionInfo> {
+        (*self.history).clone()
     }
 
-    async fn record_transition(&self, transition: StateTransition, result: TransitionResult, duration: Duration) {
-        let info = StateTransitionInfo {
-            timestamp: SystemTime::now(),
-            transition,
-            result,
-            duration,
-        };
-        self.history.write().await.push(info);
+    fn create_new_manager(&self, new_state: ContainerState, transition_info: StateTransitionInfo) -> Self {
+        let mut new_history = (*self.history).clone();
+        new_history.push(transition_info);
+        
+        Self {
+            state: Arc::new(new_state),
+            history: Arc::new(new_history),
+        }
     }
 
-    async fn validate_transition(&self, transition: &StateTransition, current_state: &ContainerState) -> Result<()> {
-        match (current_state, transition) {
-            (ContainerState::Initial, StateTransition::Create(_)) => Ok(()),
-            (ContainerState::Created { .. }, StateTransition::Start) => Ok(()),
-            (ContainerState::Running { .. }, StateTransition::Execute(_)) => Ok(()),
-            (ContainerState::Running { .. } | ContainerState::Executing { .. }, StateTransition::Stop) => Ok(()),
-            (_, StateTransition::Fail(_)) => Ok(()),
-            (ContainerState::Failed { .. }, StateTransition::Regenerate) => Ok(()),
-            (ContainerState::Created { .. }, StateTransition::Restore(_)) => Ok(()),
-            _ => Err(state_err(
-                "状態遷移の検証",
-                format!("無効な状態遷移: {} -> {:?}", current_state, transition)
-            )),
-        }
+    async fn validate_transition(&self, transition: &StateTransition) -> Result<()> {
+        match transition {
+            StateTransition::Create(_) => {
+                if !matches!(*self.state, ContainerState::Initial) {
+                    return Err(state_err(
+                        "状態遷移",
+                        "コンテナの作成は初期状態からのみ可能です"
+                    ));
+                }
+            }
+            StateTransition::Start => {
+                if !matches!(*self.state, ContainerState::Created { .. }) {
+                    return Err(state_err(
+                        "状態遷移",
+                        "コンテナの開始は作成済み状態からのみ可能です"
+                    ));
+                }
+            }
+            StateTransition::Execute(_) => {
+                if !matches!(*self.state, ContainerState::Running { .. }) {
+                    return Err(state_err(
+                        "状態遷移",
+                        "コマンドの実行は実行中状態からのみ可能です"
+                    ));
+                }
+            }
+            StateTransition::Stop => {
+                if !matches!(*self.state, ContainerState::Running { .. } | ContainerState::Executing { .. }) {
+                    return Err(state_err(
+                        "状態遷移",
+                        "コンテナの停止は実行中または実行中（コマンド）状態からのみ可能です"
+                    ));
+                }
+            }
+            StateTransition::Fail(_) => {
+                if matches!(*self.state, ContainerState::Failed { .. } | ContainerState::Stopped { .. }) {
+                    return Err(state_err(
+                        "状態遷移",
+                        "既に失敗または停止状態のコンテナは失敗状態に遷移できません"
+                    ));
+                }
+            }
+            StateTransition::Regenerate => {
+                if !self.state.can_regenerate() {
+                    return Err(state_err(
+                        "状態遷移",
+                        "現在の状態からは再生成できません"
+                    ));
+                }
+            }
+            StateTransition::Restore(_) => {
+                // リストア操作は任意の状態から可能
+                Ok(())
+            }
+        }?;
+        Ok(())
     }
 
-    async fn apply_transition(&self, transition: StateTransition) -> Result<()> {
+    pub async fn apply_transition(&self, transition: StateTransition) -> Result<Self> {
         let start_time = SystemTime::now();
-        let current_state = self.get_current_state().await;
 
         // 状態遷移の検証
-        if let Err(e) = self.validate_transition(&transition, &current_state).await {
+        if let Err(e) = self.validate_transition(&transition).await {
             let duration = start_time.elapsed().unwrap_or(Duration::from_secs(0));
-            self.record_transition(
-                transition,
-                TransitionResult::Failure(e.to_string()),
-                duration
-            ).await;
-            return Err(e);
+            let transition_info = StateTransitionInfo {
+                timestamp: start_time,
+                transition: transition.clone(),
+                result: TransitionResult::Failure(e.to_string()),
+                duration,
+            };
+            return Ok(self.create_new_manager((*self.state).clone(), transition_info));
         }
 
         let new_state = match transition.clone() {
@@ -99,38 +140,38 @@ impl ContainerStateManager {
                 ContainerState::create(container_id)
             },
             StateTransition::Start => {
-                current_state.start()
+                self.state.start()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("開始遷移の失敗: {}", current_state)
+                        format!("開始遷移の失敗: {}", self.state)
                     ))?
             },
             StateTransition::Execute(command) => {
-                current_state.execute(command)
+                self.state.execute(command)
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("コマンド実行遷移の失敗: {}", current_state)
+                        format!("コマンド実行遷移の失敗: {}", self.state)
                     ))?
             },
             StateTransition::Stop => {
-                current_state.stop()
+                self.state.stop()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("停止遷移の失敗: {}", current_state)
+                        format!("停止遷移の失敗: {}", self.state)
                     ))?
             },
             StateTransition::Fail(error) => {
-                current_state.fail(error)
+                self.state.fail(error)
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("失敗遷移の失敗: {}", current_state)
+                        format!("失敗遷移の失敗: {}", self.state)
                     ))?
             },
             StateTransition::Regenerate => {
-                current_state.regenerate()
+                self.state.regenerate()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("再生成遷移の失敗: {}", current_state)
+                        format!("再生成遷移の失敗: {}", self.state)
                     ))?
             },
             StateTransition::Restore(state_info) => {
@@ -159,57 +200,51 @@ impl ContainerStateManager {
         };
 
         let duration = start_time.elapsed().unwrap_or(Duration::from_secs(0));
-        *self.state.write().await = new_state.clone();
-        self.record_transition(
+        let transition_info = StateTransitionInfo {
+            timestamp: start_time,
             transition,
-            TransitionResult::Success(new_state),
-            duration
-        ).await;
-        Ok(())
+            result: TransitionResult::Success(new_state.clone()),
+            duration,
+        };
+
+        Ok(self.create_new_manager(new_state, transition_info))
     }
 
     // 公開APIメソッド
-    pub async fn create_container(&self, container_id: String) -> Result<()> {
+    pub async fn create_container(&self, container_id: String) -> Result<Self> {
         self.apply_transition(StateTransition::Create(container_id)).await
     }
 
-    pub async fn start_container(&self) -> Result<()> {
+    pub async fn start_container(&self) -> Result<Self> {
         self.apply_transition(StateTransition::Start).await
     }
 
-    pub async fn execute_command(&self, command: String) -> Result<()> {
+    pub async fn execute_command(&self, command: String) -> Result<Self> {
         self.apply_transition(StateTransition::Execute(command)).await
     }
 
-    pub async fn stop_container(&self) -> Result<()> {
+    pub async fn stop_container(&self) -> Result<Self> {
         self.apply_transition(StateTransition::Stop).await
     }
 
-    pub async fn fail_container(&self, error: String) -> Result<()> {
+    pub async fn fail_container(&self, error: String) -> Result<Self> {
         self.apply_transition(StateTransition::Fail(error)).await
     }
 
-    pub async fn regenerate_container(&self) -> Result<()> {
+    pub async fn regenerate_container(&self) -> Result<Self> {
         self.apply_transition(StateTransition::Regenerate).await
     }
 
-    pub async fn restore_state(&self, state_info: StateInfo) -> Result<()> {
+    pub async fn restore_container(&self, state_info: StateInfo) -> Result<Self> {
         self.apply_transition(StateTransition::Restore(state_info)).await
     }
 
-    pub async fn get_container_id(&self) -> Result<String> {
-        let state = self.get_current_state().await;
-        state.container_id()
-            .map(String::from)
-            .ok_or_else(|| state_err("状態管理", "コンテナIDが見つかりません"))
-    }
-
-    pub async fn get_last_transition(&self) -> Option<StateTransitionInfo> {
-        self.history.read().await.last().cloned()
+    pub fn get_last_transition(&self) -> Option<StateTransitionInfo> {
+        self.history.last().cloned()
     }
 
-    pub async fn get_transitions_since(&self, since: SystemTime) -> Vec<StateTransitionInfo> {
-        self.history.read().await
+    pub fn get_transitions_since(&self, since: SystemTime) -> Vec<StateTransitionInfo> {
+        self.history
             .iter()
             .filter(|info| info.timestamp >= since)
             .cloned()
