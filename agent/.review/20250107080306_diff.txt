diff --git a/src/bin/cph.rs b/src/bin/cph.rs
index 1f8db69..b9db2b6 100644
--- a/src/bin/cph.rs
+++ b/src/bin/cph.rs
@@ -1,6 +1,8 @@
 use cph::config::Config;
+use serde_yaml::Value;
 
 fn main() -> Result<(), Box<dyn std::error::Error>> {
-    let _config = Config::new()?;
+    let root_value = Value::Mapping(serde_yaml::Mapping::new());
+    let _config = Config::new(root_value);
     Ok(())
 }
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 4b0a839..198aaa4 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -1,296 +1,373 @@
 // Configuration Module
 //
-// # 型変換機能
-// このモジュールは、YAML設定から様々な型への変換をサポートしています：
-//
-// ## 基本的な型変換
-// ```rust
-// // 文字列として取得
-// let value: String = config.get("system.source_file.solution")?;
-// 
-// // 数値として取得
-// let timeout: i64 = config.get("system.docker.timeout_seconds")?;
-// let memory: f64 = config.get("system.docker.memory_limit_mb")?;
-// 
-// // 真偽値として取得（"yes", "true", "on", "1" は true として扱われます）
-// let auto_yes: bool = config.get("system.submit.auto_yes")?;
-// 
-// // 文字列配列として取得
-// let aliases: Vec<String> = config.get("languages.rust.aliases")?;
-// ```
-//
-// ## エイリアス解決付きの型変換
-// ```rust
-// // エイリアスを解決して値を取得
-// // 例: "rs.extension" -> "languages.rust.extension"
-// let ext: String = config.get_with_alias("rs.extension")?;
-// ```
-//
-// ## 型変換エラー処理
-// ```rust
-// // エラーハンドリングの例
-// match config.get::<bool>("some.string.value") {
-//     Ok(value) => println!("値: {}", value),
-//     Err(ConfigError::TypeError { path, value, .. }) => {
-//         println!("型変換エラー - パス: {}, 値: {}", path, value);
-//     }
-//     Err(e) => println!("その他のエラー: {}", e),
-// }
-// ```
-//
-// ## カスタム型の実装
-// 新しい型のサポートを追加するには、`TypedValue` トレイトを実装します：
-// ```rust
-// impl TypedValue for MyType {
-//     const TYPE: ConfigType = ConfigType::String;  // 適切な型を指定
-//
-//     fn from_yaml(value: &Value) -> Result<Self, ConfigError> {
-//         // 値の変換ロジックを実装
-//     }
-// }
-// ```
+// このモジュールは、イミュータブルで型安全な設定管理を提供します。
+// 主な機能：
+// - 型安全な設定アクセス
+// - イミュータブルな設定値
+// - カスタムスキーマによるバリデーション
+// - 柔軟な型変換システム
+// - 設定変更の追跡
 
-use std::fs;
 use std::sync::Arc;
+use std::collections::HashMap;
 use std::time::SystemTime;
-use serde::{Deserialize, Serialize};
-use serde_yaml::{self, Value};
-use thiserror::Error;
-
-#[derive(Error, Debug)]
-pub enum ConfigError {
-    #[error("設定ファイルが見つかりません: {0}")]
-    NotFound(String),
-
-    #[error("設定ファイルの読み込みに失敗しました: {0}")]
-    Read(String),
-
-    #[error("設定ファイルの解析に失敗しました: {0}")]
-    Parse(String),
-
-    #[error("設定値の型が不正です: {expected:?} が必要ですが {actual:?} が指定されています")]
-    TypeError {
-        expected: ConfigType,
-        actual: ConfigType,
-    },
+use serde_yaml::Value;
+use regex::Regex;
+
+// 基本的な設定ノード
+#[derive(Clone, Debug)]
+pub struct ConfigNode {
+    value: Arc<Value>,
+    metadata: Arc<ConfigMetadata>,
+}
 
-    #[error("設定の検証に失敗しました: {0}")]
-    Validation(String),
+#[derive(Clone, Debug)]
+pub struct ConfigMetadata {
+    path: String,
+    schema: Option<Arc<ConfigSchema>>,
+    description: Option<String>,
+}
 
-    #[error("{0}")]
-    Config(String),
+// スキーマ定義
+#[derive(Clone, Debug)]
+pub enum ConfigSchema {
+    Primitive(PrimitiveType),
+    Array(Box<ConfigSchema>),
+    Object(HashMap<String, ConfigSchema>),
+    Union(Vec<ConfigSchema>),
+    Custom(Arc<dyn CustomSchema>),
 }
 
-#[derive(Debug, Clone)]
-pub enum ConfigType {
+#[derive(Clone, Debug)]
+pub enum PrimitiveType {
     String,
-    StringArray,
-    Object,
-    Boolean,
     Number,
+    Boolean,
     Null,
-    Tagged,
 }
 
-#[derive(Debug, Clone)]
-pub struct ConfigAccess {
-    path: String,
-    timestamp: SystemTime,
-    value_type: ConfigType,
+// カスタムスキーマのトレイト
+pub trait CustomSchema: Send + Sync + std::fmt::Debug {
+    fn validate(&self, value: &Value) -> ConfigResult<()>;
+    fn describe(&self) -> String;
 }
 
-pub type ConfigResult<T> = Result<T, ConfigError>;
+// 設定アクセスのトレイト
+pub trait ConfigAccess {
+    fn get(&self, path: &str) -> ConfigResult<ConfigNode>;
+    fn get_all(&self, pattern: &str) -> ConfigResult<Vec<ConfigNode>>;
+    fn exists(&self, path: &str) -> bool;
+}
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct ConfigValue {
-    system: Value,
-    languages: Value,
+// 型変換のトレイト
+pub trait FromConfigValue: Sized {
+    fn from_config_value(value: &Value) -> ConfigResult<Self>;
 }
 
+// メインの設定構造体
 #[derive(Clone)]
 pub struct Config {
-    value: Arc<ConfigValue>,
-    access_history: Arc<Vec<ConfigAccess>>,
-    validation_rules: Arc<Vec<Arc<dyn Fn(&ConfigValue) -> ConfigResult<()> + Send + Sync>>>,
+    root: Arc<ConfigNode>,
+    listeners: Arc<Vec<Arc<dyn ConfigListener>>>,
+    history: Arc<Vec<ConfigChange>>,
 }
 
-impl std::fmt::Debug for Config {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("Config")
-            .field("value", &self.value)
-            .field("access_history", &self.access_history)
-            .field("validation_rules", &format!("<{} rules>", self.validation_rules.len()))
-            .finish()
-    }
+#[derive(Clone, Debug)]
+pub struct ConfigChange {
+    timestamp: SystemTime,
+    path: String,
+    old_value: Option<Arc<Value>>,
+    new_value: Arc<Value>,
 }
 
-impl Config {
-    pub fn new() -> ConfigResult<Self> {
-        let config_str = fs::read_to_string("config.yml")
-            .map_err(|e| ConfigError::Config(format!("設定ファイルの読み込みに失敗しました: {}", e)))?;
+// 設定変更通知のトレイト
+pub trait ConfigListener: Send + Sync {
+    fn on_change(&self, old: &ConfigNode, new: &ConfigNode);
+}
+
+// エラー型
+#[derive(Debug)]
+pub enum ConfigError {
+    PathNotFound(String),
+    TypeError { expected: &'static str, found: String },
+    ValidationError { message: String },
+    ValueError { message: String },
+}
 
-        let value: ConfigValue = serde_yaml::from_str(&config_str)
-            .map_err(|e| ConfigError::Config(format!("設定ファイルのパースに失敗しました: {}", e)))?;
+pub type ConfigResult<T> = Result<T, ConfigError>;
 
-        let config = Self {
+// ConfigNodeの実装
+impl ConfigNode {
+    pub fn new(value: Value, path: String) -> Self {
+        Self {
             value: Arc::new(value),
-            access_history: Arc::new(Vec::new()),
-            validation_rules: Arc::new(Vec::new()),
-        };
+            metadata: Arc::new(ConfigMetadata {
+                path,
+                schema: None,
+                description: None,
+            }),
+        }
+    }
 
-        config.validate()?;
-        Ok(config)
+    pub fn as_typed<T: FromConfigValue>(&self) -> ConfigResult<T> {
+        T::from_config_value(&self.value)
     }
 
-    fn with_access(&self, path: String, value_type: ConfigType) -> Self {
-        let mut history = (*self.access_history).clone();
-        history.push(ConfigAccess {
-            path,
-            timestamp: SystemTime::now(),
-            value_type,
-        });
-        Self {
-            value: self.value.clone(),
-            access_history: Arc::new(history),
-            validation_rules: self.validation_rules.clone(),
+    pub fn with_value(&self, value: Value) -> ConfigResult<Self> {
+        if let Some(schema) = &self.metadata.schema {
+            schema.validate(&value)?;
         }
+        Ok(Self {
+            value: Arc::new(value),
+            metadata: self.metadata.clone(),
+        })
     }
+}
 
-    pub fn with_validation_rule<F>(self, rule: F) -> Self
-    where
-        F: Fn(&ConfigValue) -> ConfigResult<()> + Send + Sync + 'static,
-    {
-        let mut rules = (*self.validation_rules).clone();
-        rules.push(Arc::new(rule));
+// Configの実装
+impl Config {
+    pub fn new(root_value: Value) -> Self {
         Self {
-            value: self.value,
-            access_history: self.access_history,
-            validation_rules: Arc::new(rules),
+            root: Arc::new(ConfigNode::new(root_value, String::from("root"))),
+            listeners: Arc::new(Vec::new()),
+            history: Arc::new(Vec::new()),
         }
     }
 
-    pub fn validate(&self) -> ConfigResult<()> {
-        for rule in self.validation_rules.iter() {
-            rule(&self.value)?;
+    pub fn with_listener<L: ConfigListener + 'static>(self, listener: L) -> Self {
+        let mut listeners = (*self.listeners).clone();
+        listeners.push(Arc::new(listener));
+        Self {
+            listeners: Arc::new(listeners),
+            ..self
         }
-        Ok(())
     }
 
-    pub fn get<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<(T, Self)> {
-        let parts: Vec<&str> = path.split('.').collect();
-        let mut current = match parts[0] {
-            "system" => serde_yaml::to_value(&self.value.system)
-                .map_err(|e| ConfigError::Config(e.to_string()))?,
-            "languages" => serde_yaml::to_value(&self.value.languages)
-                .map_err(|e| ConfigError::Config(e.to_string()))?,
-            _ => return Err(ConfigError::Config(format!("無効な設定パス: {}", path))),
-        };
-
-        for &part in &parts[1..] {
-            current = current.get(part)
-                .ok_or_else(|| ConfigError::Config(format!("設定パス{}が見つかりません", path)))?
-                .clone();
+    fn notify_listeners(&self, old: &ConfigNode, new: &ConfigNode) {
+        for listener in self.listeners.iter() {
+            listener.on_change(old, new);
         }
-
-        let value_type = match current {
-            Value::String(_) => ConfigType::String,
-            Value::Sequence(_) => ConfigType::StringArray,
-            Value::Mapping(_) => ConfigType::Object,
-            Value::Bool(_) => ConfigType::Boolean,
-            Value::Number(_) => ConfigType::Number,
-            Value::Null => ConfigType::Null,
-            Value::Tagged(_) => ConfigType::Tagged,
-        };
-
-        let new_config = self.with_access(path.to_string(), value_type);
-        let value = serde_yaml::from_value(current)
-            .map_err(|e| ConfigError::Config(format!("値の変換に失敗しました: {}", e)))?;
-
-        Ok((value, new_config))
     }
 
-    pub fn get_with_alias<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<(T, Self)> {
-        match self.get::<T>(path) {
-            Ok(result) => Ok(result),
-            Err(_) => {
-                let parts: Vec<&str> = path.split('.').collect();
-                if parts.len() >= 2 && parts[0] == "languages" {
-                    let alias_path = format!("languages.{}.alias", parts[1]);
-                    let (alias, config) = self.get::<String>(&alias_path)?;
-                    let new_path = format!("languages.{}.{}", alias, parts[2..].join("."));
-                    config.get::<T>(&new_path)
-                } else {
-                    Err(ConfigError::Config(format!("設定パスが見つかりません: {}", path)))
-                }
-            }
-        }
+    pub fn get<T: FromConfigValue>(&self, path: &str) -> ConfigResult<T> {
+        self.get_node(path).and_then(|node| node.as_typed())
     }
 
-    pub fn get_raw_value(&self, key: &str) -> ConfigResult<(&Value, Self)> {
-        let value = self.value.system.get(key)
-            .ok_or_else(|| ConfigError::Config(format!("設定キーが見つかりません: {}", key)))?;
-
-        let value_type = match value {
-            Value::String(_) => ConfigType::String,
-            Value::Sequence(_) => ConfigType::StringArray,
-            Value::Mapping(_) => ConfigType::Object,
-            Value::Bool(_) => ConfigType::Boolean,
-            Value::Number(_) => ConfigType::Number,
-            Value::Null => ConfigType::Null,
-            Value::Tagged(_) => ConfigType::Tagged,
-        };
-
-        let new_config = self.with_access(key.to_string(), value_type);
-        Ok((value, new_config))
+    fn get_node(&self, path: &str) -> ConfigResult<ConfigNode> {
+        self.resolve_path(path)
+            .map(|value| ConfigNode::new(value, path.to_string()))
     }
+}
 
-    pub fn access_history(&self) -> &[ConfigAccess] {
-        &self.access_history
+// ConfigAccessの実装
+impl ConfigAccess for Config {
+    fn get(&self, path: &str) -> ConfigResult<ConfigNode> {
+        self.get_node(path)
     }
 
-    pub fn get_accesses_since(&self, since: SystemTime) -> Vec<ConfigAccess> {
-        self.access_history
-            .iter()
-            .filter(|access| access.timestamp >= since)
-            .cloned()
+    fn get_all(&self, pattern: &str) -> ConfigResult<Vec<ConfigNode>> {
+        self.find_matching_paths(pattern)
+            .into_iter()
+            .map(|path| self.get(&path))
             .collect()
     }
 
-    pub fn merge(&self, other: &Config) -> ConfigResult<Self> {
-        let merged_value = self.merge_values(&self.value, &other.value)?;
-        let mut merged_rules = (*self.validation_rules).clone();
-        merged_rules.extend((*other.validation_rules).clone());
+    fn exists(&self, path: &str) -> bool {
+        self.resolve_path(path).is_ok()
+    }
+}
+
+// 基本型のFromConfigValue実装
+impl FromConfigValue for String {
+    fn from_config_value(value: &Value) -> ConfigResult<Self> {
+        match value {
+            Value::String(s) => Ok(s.clone()),
+            Value::Number(n) => Ok(n.to_string()),
+            Value::Bool(b) => Ok(b.to_string()),
+            _ => Err(ConfigError::TypeError {
+                expected: "string-convertible",
+                found: value.type_str().to_string(),
+            }),
+        }
+    }
+}
 
-        let config = Self {
-            value: Arc::new(merged_value),
-            access_history: Arc::new(Vec::new()),
-            validation_rules: Arc::new(merged_rules),
-        };
+impl FromConfigValue for bool {
+    fn from_config_value(value: &Value) -> ConfigResult<Self> {
+        match value {
+            Value::Bool(b) => Ok(*b),
+            Value::String(s) => match s.to_lowercase().as_str() {
+                "true" | "yes" | "on" | "1" => Ok(true),
+                "false" | "no" | "off" | "0" => Ok(false),
+                _ => Err(ConfigError::ValueError {
+                    message: format!("無効な真偽値: {}", s),
+                }),
+            },
+            _ => Err(ConfigError::TypeError {
+                expected: "boolean",
+                found: value.type_str().to_string(),
+            }),
+        }
+    }
+}
 
-        config.validate()?;
-        Ok(config)
+impl FromConfigValue for i64 {
+    fn from_config_value(value: &Value) -> ConfigResult<Self> {
+        match value {
+            Value::Number(n) => n.as_i64().ok_or_else(|| ConfigError::ValueError {
+                message: "数値が範囲外です".to_string(),
+            }),
+            Value::String(s) => s.parse().map_err(|_| ConfigError::ValueError {
+                message: format!("無効な数値: {}", s),
+            }),
+            _ => Err(ConfigError::TypeError {
+                expected: "number",
+                found: value.type_str().to_string(),
+            }),
+        }
     }
+}
 
-    fn merge_values(&self, base: &ConfigValue, other: &ConfigValue) -> ConfigResult<ConfigValue> {
-        let merged_system = self.merge_yaml(&base.system, &other.system)?;
-        let merged_languages = self.merge_yaml(&base.languages, &other.languages)?;
+// ヘルパーメソッド
+impl Config {
+    fn resolve_path(&self, path: &str) -> ConfigResult<Value> {
+        let parts: Vec<&str> = path.split('.').collect();
+        let mut current = self.root.value.clone();
+        
+        for part in parts {
+            match &*current {
+                Value::Mapping(map) => {
+                    current = Arc::new(map.get(part).ok_or_else(|| ConfigError::PathNotFound(
+                        path.to_string(),
+                    ))?.clone());
+                }
+                _ => return Err(ConfigError::PathNotFound(path.to_string())),
+            }
+        }
+        
+        Ok((*current).clone())
+    }
 
-        Ok(ConfigValue {
-            system: merged_system,
-            languages: merged_languages,
-        })
+    fn find_matching_paths(&self, _pattern: &str) -> Vec<String> {
+        // TODO: 実装
+        vec![]
     }
+}
 
-    fn merge_yaml(&self, base: &Value, other: &Value) -> ConfigResult<Value> {
-        match (base, other) {
-            (Value::Mapping(base_map), Value::Mapping(other_map)) => {
-                let mut merged = base_map.clone();
-                for (key, value) in other_map {
-                    merged.insert(key.clone(), value.clone());
+pub trait ValueExt {
+    fn type_str(&self) -> &'static str;
+}
+
+impl std::fmt::Display for ConfigError {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        match self {
+            ConfigError::PathNotFound(path) => write!(f, "パスが見つかりません: {}", path),
+            ConfigError::TypeError { expected, found } => 
+                write!(f, "型エラー: 期待される型 {}, 実際の型 {}", expected, found),
+            ConfigError::ValidationError { message } => 
+                write!(f, "バリデーションエラー: {}", message),
+            ConfigError::ValueError { message } => 
+                write!(f, "値エラー: {}", message),
+        }
+    }
+}
+
+impl ValueExt for Value {
+    fn type_str(&self) -> &'static str {
+        match self {
+            Value::Null => "null",
+            Value::Bool(_) => "boolean",
+            Value::Number(_) => "number",
+            Value::String(_) => "string",
+            Value::Sequence(_) => "array",
+            Value::Mapping(_) => "object",
+            Value::Tagged(_) => "tagged",
+        }
+    }
+}
+
+impl ConfigSchema {
+    pub fn validate(&self, value: &Value) -> ConfigResult<()> {
+        match self {
+            ConfigSchema::Primitive(ptype) => match (ptype, value) {
+                (PrimitiveType::String, Value::String(_)) => Ok(()),
+                (PrimitiveType::Number, Value::Number(_)) => Ok(()),
+                (PrimitiveType::Boolean, Value::Bool(_)) => Ok(()),
+                (PrimitiveType::Null, Value::Null) => Ok(()),
+                _ => Err(ConfigError::TypeError {
+                    expected: ptype.type_str(),
+                    found: value.type_str().to_string(),
+                }),
+            },
+            ConfigSchema::Array(item_schema) => {
+                if let Value::Sequence(items) = value {
+                    for item in items {
+                        item_schema.validate(item)?;
+                    }
+                    Ok(())
+                } else {
+                    Err(ConfigError::TypeError {
+                        expected: "array",
+                        found: value.type_str().to_string(),
+                    })
+                }
+            },
+            ConfigSchema::Object(fields) => {
+                if let Value::Mapping(map) = value {
+                    for (key, schema) in fields {
+                        if let Some(field_value) = map.get(key) {
+                            schema.validate(field_value)?;
+                        }
+                    }
+                    Ok(())
+                } else {
+                    Err(ConfigError::TypeError {
+                        expected: "object",
+                        found: value.type_str().to_string(),
+                    })
+                }
+            },
+            ConfigSchema::Union(schemas) => {
+                for schema in schemas {
+                    if schema.validate(value).is_ok() {
+                        return Ok(());
+                    }
                 }
-                Ok(Value::Mapping(merged))
+                Err(ConfigError::ValidationError {
+                    message: "値がユニオン型のいずれにも一致しません".to_string(),
+                })
             },
-            (_, other) => Ok(other.clone()),
+            ConfigSchema::Custom(schema) => schema.validate(value),
         }
     }
+}
+
+impl PrimitiveType {
+    fn type_str(&self) -> &'static str {
+        match self {
+            PrimitiveType::String => "string",
+            PrimitiveType::Number => "number",
+            PrimitiveType::Boolean => "boolean",
+            PrimitiveType::Null => "null",
+        }
+    }
+}
+
+impl FromConfigValue for Value {
+    fn from_config_value(value: &Value) -> ConfigResult<Self> {
+        Ok(value.clone())
+    }
+}
+
+impl FromConfigValue for ConfigNode {
+    fn from_config_value(value: &Value) -> ConfigResult<Self> {
+        Ok(ConfigNode {
+            value: Arc::new(value.clone()),
+            metadata: Arc::new(ConfigMetadata {
+                path: String::new(),
+                schema: None,
+                description: None,
+            }),
+        })
+    }
 } 
\ No newline at end of file
diff --git a/src/contest/parse.rs b/src/contest/parse.rs
index 062b07d..f57832f 100644
--- a/src/contest/parse.rs
+++ b/src/contest/parse.rs
@@ -1,7 +1,7 @@
 use std::error::Error;
 use std::collections::HashMap;
 use serde_yaml::Value;
-use crate::config::{Config, ConfigError, ConfigType};
+use crate::config::{Config, ConfigError, ValueExt};
 
 #[derive(Debug, Clone, PartialEq)]
 pub struct CommandType {
@@ -52,9 +52,8 @@ pub struct NameResolver {
 impl NameResolver {
     pub fn new(config: &Config) -> Result<Self, ParseError> {
         let mut command_aliases = HashMap::new();
-        let executions = config.get_raw_value("executions")
+        let executions: Value = config.get("executions")
             .map_err(|_| ParseError::MissingSection("executions".to_string()))?;
-        let executions = executions.0;
 
         if let Value::Mapping(executions_map) = executions {
             for (cmd_name, cmd_config) in executions_map {
@@ -79,9 +78,8 @@ impl NameResolver {
             }
         }
 
-        let settings = config.get_raw_value("settings")
+        let settings: Value = config.get("settings")
             .map_err(|_| ParseError::MissingSection("settings".to_string()))?;
-        let settings = settings.0;
 
         if let Value::Mapping(settings_map) = settings {
             Ok(Self {
@@ -92,8 +90,8 @@ impl NameResolver {
             })
         } else {
             Err(ParseError::ConfigError(ConfigError::TypeError {
-                expected: ConfigType::StringArray,
-                actual: ConfigType::Null,
+                expected: "object",
+                found: settings.type_str().to_string(),
             }))
         }
     }
