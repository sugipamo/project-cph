diff --git a/src/config/commands.yaml b/src/config/commands.yaml
index 5077df9..b01695f 100644
--- a/src/config/commands.yaml
+++ b/src/config/commands.yaml
@@ -10,9 +10,9 @@ commands:
       aliases: ["s", "sub"]
   settings:
     contest:
-      priority: 2
-    problem:
       priority: 1
+    problem:
+      priority: 2
     language:
       rust:
         aliases: ["rs", "Rust", "RUST"]
diff --git a/src/contest/parse/config.rs b/src/contest/parse/config.rs
index 854eacd..77debcf 100644
--- a/src/contest/parse/config.rs
+++ b/src/contest/parse/config.rs
@@ -75,15 +75,22 @@ impl Config {
         self.alias_map.clear();
         for (category, subcmds) in &self.commands {
             for (original, value) in subcmds {
-                if let CommandValue::Command { aliases } = value {
-                    for alias in aliases {
-                        self.alias_map.insert(
-                            alias.clone(),
-                            AliasInfo {
-                                original: original.clone(),
-                                category: category.clone(),
-                            },
-                        );
+                match value {
+                    CommandValue::Command { aliases } => {
+                        for alias in aliases {
+                            if !alias.contains(char::is_whitespace) {
+                                self.alias_map.insert(
+                                    alias.clone(),
+                                    AliasInfo {
+                                        original: original.clone(),
+                                        category: category.clone(),
+                                    },
+                                );
+                            }
+                        }
+                    }
+                    CommandValue::Setting { priority: _ } => {
+                        // priorityの設定は無視
                     }
                 }
             }
diff --git a/src/contest/parse/parser.rs b/src/contest/parse/parser.rs
index e99e2f6..551e173 100644
--- a/src/contest/parse/parser.rs
+++ b/src/contest/parse/parser.rs
@@ -39,11 +39,16 @@ impl Parser {
     }
 
     pub fn parse(&self, input: &str) -> Result<CommandContext> {
-        let tokens: Vec<&str> = input.split_whitespace().collect();
-        if tokens.is_empty() {
+        let input = input.trim();
+        if input.is_empty() {
             return Err(anyhow!("入力が空です"));
         }
 
+        let tokens: Vec<&str> = input.split_whitespace().collect();
+        self.parse_tokens(&tokens)
+    }
+
+    fn parse_tokens(&self, tokens: &[&str]) -> Result<CommandContext> {
         let mut interpretations = Vec::new();
         for token in tokens {
             let token_interp = self.interpret_token(token)?;
@@ -66,15 +71,6 @@ impl Parser {
     fn interpret_token(&self, token: &str) -> Result<TokenInterpretation> {
         let mut interpretations = Vec::new();
 
-        // エテゴリ直接マッチを試みる
-        if let Some(token_type) = Self::get_token_type(token) {
-            interpretations.push((token_type, token.to_string()));
-            return Ok(TokenInterpretation {
-                token: token.to_string(),
-                interpretations,
-            });
-        }
-
         // エイリアス解決を試みる
         if let Some((category, original)) = self.config.resolve_alias(token) {
             if let Some(token_type) = Self::get_token_type(&category) {
@@ -86,6 +82,15 @@ impl Parser {
             }
         }
 
+        // カテゴリ直接マッチを試みる
+        if let Some(token_type) = Self::get_token_type(token) {
+            interpretations.push((token_type, token.to_string()));
+            return Ok(TokenInterpretation {
+                token: token.to_string(),
+                interpretations,
+            });
+        }
+
         // 解釈できなかった場合は空の解釈リストを返す
         Ok(TokenInterpretation {
             token: token.to_string(),
@@ -124,22 +129,21 @@ impl Parser {
         let mut problem_id = problem_id;
         
         // エイリアスとして解釈できなかったトークンを収集
-        let mut tokens = interpretations
+        let uninterpreted_tokens: Vec<_> = interpretations
             .iter()
-            .filter(|i| i.interpretations.is_empty());
-
-        // contest_idが未設定の場合、最初の未解釈トークンをcontest_idとして使用
-        if contest_id.is_none() {
-            if let Some(token) = tokens.next() {
-                contest_id = Some(token.token.clone());
+            .filter(|i| i.interpretations.is_empty())
+            .map(|i| i.token.clone())
+            .collect();
+
+        // 未解釈トークンがある場合、priorityの高い順に割り当てる
+        if !uninterpreted_tokens.is_empty() {
+            // priority=2のcontest_idを先に割り当て
+            if contest_id.is_none() && !uninterpreted_tokens.is_empty() {
+                contest_id = Some(uninterpreted_tokens[0].clone());
             }
-        }
-
-        // problem_idが未設定で、まだ未解釈トークンが残っている場合
-        // 次の未解釈トークンをproblem_idとして使用
-        if problem_id.is_none() {
-            if let Some(token) = tokens.next() {
-                problem_id = Some(token.token.clone());
+            // priority=1のproblem_idを次に割り当て
+            if problem_id.is_none() && uninterpreted_tokens.len() > 1 {
+                problem_id = Some(uninterpreted_tokens[1].clone());
             }
         }
 
diff --git a/tests/contest/parse/parser.rs b/tests/contest/parse/parser.rs
index 11c9008..b37f67e 100644
--- a/tests/contest/parse/parser.rs
+++ b/tests/contest/parse/parser.rs
@@ -23,7 +23,7 @@ fn test_basic_parsing() -> Result<()> {
         }
     );
 
-    // サイトとコンテストIDのテスト
+    // サイトとproblem_idのテスト
     let context = parser.parse("atcoder abc123")?;
     assert_eq!(
         context.command,
@@ -81,6 +81,68 @@ fn test_alias_resolution() -> Result<()> {
     Ok(())
 }
 
+#[test]
+fn test_complex_patterns() -> Result<()> {
+    let parser = create_test_parser();
+
+    // 複数の問題ID候補がある場合
+    let context = parser.parse("abc123 a b c")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),  // 最初の値を問題IDとして解釈
+            language: None,
+        }
+    );
+
+    // 順序が異なる場合
+    let context = parser.parse("rs abc123 atcoder a")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: Some("rust".to_string()),
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_edge_cases() -> Result<()> {
+    let parser = create_test_parser();
+
+    // 最小限の入力
+    let context = parser.parse("abc123")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("abc123".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    // サイトのみの入力
+    let context = parser.parse("atcoder")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: None,
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
 #[test]
 fn test_error_cases() -> Result<()> {
     let parser = create_test_parser();
@@ -89,5 +151,214 @@ fn test_error_cases() -> Result<()> {
     assert!(parser.parse("").is_err());
     assert!(parser.parse("   ").is_err());
 
+    // 余分な空白を含む入力
+    let context = parser.parse("  abc123   a  ")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_priority_handling() -> Result<()> {
+    let parser = create_test_parser();
+
+    // イトと1つのトークン
+    let context = parser.parse("atcoder abc123")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_invalid_config() -> Result<()> {
+    // 無効な設定ファイルの読み込み
+    let config = Config::from_file("tests/contest/parse/invalid_commands.yaml")?;
+    
+    // 空白を含むエイリアスが無視されていることを確認
+    assert!(!config.resolve_alias("at test").is_some());
+    assert!(!config.resolve_alias("at coder").is_some());
+    assert!(!config.resolve_alias("cf test").is_some());
+    assert!(!config.resolve_alias("code forces").is_some());
+    assert!(!config.resolve_alias("rust 2021").is_some());
+    assert!(!config.resolve_alias("rs test").is_some());
+
+    // 存在しない設定ファイル
+    let result = Config::from_file("nonexistent.yaml");
+    assert!(result.is_err());
+
+    Ok(())
+}
+
+#[test]
+fn test_special_characters() -> Result<()> {
+    let config = Config::from_file("tests/contest/parse/special_commands.yaml")?;
+    let parser = Parser::with_config(config);
+
+    // ハイフンを含むエイリアス
+    let context = parser.parse("at-test abc123")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder-test".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    // 空白を含むエイリアス
+    let context = parser.parse("at test abc123")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("at".to_string()),
+            problem_id: Some("test".to_string()),
+            language: None,
+        }
+    );
+
+    // Unicode文字
+    let context = parser.parse("ユ abc123")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("ユーコーダー".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_performance() -> Result<()> {
+    let parser = create_test_parser();
+    
+    // 長い入力のテスト
+    let long_input = "atcoder abc123 a rust ".repeat(100);
+    let context = parser.parse(&long_input)?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: Some("rust".to_string()),
+        }
+    );
+
+    // 多数のトークンを含む入力
+    let many_tokens = "abc123 a b c d e f g h i j k l m n o p".to_string();
+    let context = parser.parse(&many_tokens)?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_whitespace_handling() -> Result<()> {
+    let parser = create_test_parser();
+
+    // タブを含む入力
+    let context = parser.parse("atcoder\tabc123\ta\trust")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: Some("rust".to_string()),
+        }
+    );
+
+    // 複数の連続した空白
+    let context = parser.parse("atcoder    abc123  a    rust")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: Some("rust".to_string()),
+        }
+    );
+
+    // 前後の空白
+    let context = parser.parse("   atcoder abc123 a rust   ")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("abc123".to_string()),
+            problem_id: Some("a".to_string()),
+            language: Some("rust".to_string()),
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_problem_id_priority() -> Result<()> {
+    let parser = create_test_parser();
+
+    // 一のトークンはcontest_idとして解釈
+    let context = parser.parse("at a")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: Some("atcoder".to_string()),
+            contest_id: Some("a".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
+    Ok(())
+}
+
+#[test]
+fn test_token_interpretation() -> Result<()> {
+    let parser = create_test_parser();
+
+    // 単一のトークンはcontest_idとして解釈
+    let context = parser.parse("aaa")?;
+    assert_eq!(
+        context.command,
+        Command::Open {
+            site: None,
+            contest_id: Some("aaa".to_string()),
+            problem_id: None,
+            language: None,
+        }
+    );
+
     Ok(())
 } 
\ No newline at end of file
