diff --git a/src/fs/core.rs b/src/fs/core.rs
deleted file mode 100644
index a4cbfff..0000000
--- a/src/fs/core.rs
+++ /dev/null
@@ -1,192 +0,0 @@
-use std::path::{Path, PathBuf};
-use anyhow::Result;
-use crate::fs::error::{not_found_error, permission_error, invalid_path_error, ErrorExt};
-
-/// ディレクトリの存在を確認し、存在しない場合は作成します
-pub fn ensure_directory<P: AsRef<Path>>(path: P) -> Result<PathBuf> {
-    let path = path.as_ref();
-    if !path.exists() {
-        std::fs::create_dir_all(path)
-            .with_context_io(format!("ディレクトリの作成に失敗: {}", path.display()))?;
-    } else if !path.is_dir() {
-        return Err(invalid_path_error(path));
-    }
-    Ok(path.to_path_buf())
-}
-
-/// ファイルの存在を確認し、存在しない場合は作成します
-pub fn ensure_file<P: AsRef<Path>>(path: P) -> Result<PathBuf> {
-    let path = path.as_ref();
-    if !path.exists() {
-        if let Some(parent) = path.parent() {
-            ensure_directory(parent)?;
-        }
-        std::fs::write(path, "")
-            .with_context_io(format!("ファイルの作成に失敗: {}", path.display()))?;
-    } else if !path.is_file() {
-        return Err(invalid_path_error(path));
-    }
-    Ok(path.to_path_buf())
-}
-
-/// ファイルを読み込みます
-pub fn read_file<P: AsRef<Path>>(path: P) -> Result<String> {
-    let path = path.as_ref();
-    if !path.exists() {
-        return Err(not_found_error(path));
-    }
-    if !path.is_file() {
-        return Err(invalid_path_error(path));
-    }
-    std::fs::read_to_string(path)
-        .with_context_io(format!("ファイルの読み込みに失敗: {}", path.display()))
-}
-
-/// ファイルに書き込みます
-pub fn write_file<P: AsRef<Path>>(path: P, content: impl AsRef<[u8]>) -> Result<()> {
-    let path = path.as_ref();
-    if let Some(parent) = path.parent() {
-        ensure_directory(parent)?;
-    }
-    std::fs::write(path, content)
-        .with_context_io(format!("ファイルの書き込みに失敗: {}", path.display()))
-}
-
-/// ファイルを削除します
-pub fn delete_file<P: AsRef<Path>>(path: P) -> Result<()> {
-    let path = path.as_ref();
-    if !path.exists() {
-        return Ok(());
-    }
-    if !path.is_file() {
-        return Err(invalid_path_error(path));
-    }
-    std::fs::remove_file(path)
-        .with_context_io(format!("ファイルの削除に失敗: {}", path.display()))
-}
-
-/// ディレクトリを削除します
-pub fn delete_directory<P: AsRef<Path>>(path: P) -> Result<()> {
-    let path = path.as_ref();
-    if !path.exists() {
-        return Ok(());
-    }
-    if !path.is_dir() {
-        return Err(invalid_path_error(path));
-    }
-    std::fs::remove_dir_all(path)
-        .with_context_io(format!("ディレクトリの削除に失敗: {}", path.display()))
-}
-
-/// パスが存在するかどうかを確認します
-pub fn exists<P: AsRef<Path>>(path: P) -> bool {
-    path.as_ref().exists()
-}
-
-/// パスがファイルかどうかを確認します
-pub fn is_file<P: AsRef<Path>>(path: P) -> bool {
-    path.as_ref().is_file()
-}
-
-/// パスがディレクトリかどうかを確認します
-pub fn is_directory<P: AsRef<Path>>(path: P) -> bool {
-    path.as_ref().is_dir()
-}
-
-/// パスのメタデータを取得します
-pub fn metadata<P: AsRef<Path>>(path: P) -> Result<std::fs::Metadata> {
-    let path = path.as_ref();
-    std::fs::metadata(path)
-        .with_context_io(format!("メタデータの取得に失敗: {}", path.display()))
-}
-
-/// パスの権限を確認します
-pub fn check_permissions<P: AsRef<Path>>(path: P, write_required: bool) -> Result<()> {
-    let path = path.as_ref();
-    let metadata = metadata(path)?;
-    
-    if !metadata.permissions().readonly() && write_required {
-        return Err(permission_error(path));
-    }
-    Ok(())
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::fs::tests::TestDirectory;
-
-    #[test]
-    fn test_ensure_directory() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        let dir_path = test_dir.path().join("test_dir");
-        
-        let result = ensure_directory(&dir_path)?;
-        assert_eq!(result, dir_path);
-        assert!(is_directory(&dir_path));
-
-        Ok(())
-    }
-
-    #[test]
-    fn test_ensure_file() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        let file_path = test_dir.path().join("test.txt");
-        
-        let result = ensure_file(&file_path)?;
-        assert_eq!(result, file_path);
-        assert!(is_file(&file_path));
-
-        Ok(())
-    }
-
-    #[test]
-    fn test_read_write_file() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        let file_path = test_dir.path().join("test.txt");
-        
-        write_file(&file_path, "Hello, World!")?;
-        assert!(is_file(&file_path));
-        
-        let content = read_file(&file_path)?;
-        assert_eq!(content, "Hello, World!");
-
-        Ok(())
-    }
-
-    #[test]
-    fn test_delete_operations() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        let file_path = test_dir.path().join("test.txt");
-        let dir_path = test_dir.path().join("test_dir");
-        
-        write_file(&file_path, "Hello")?;
-        ensure_directory(&dir_path)?;
-        
-        assert!(exists(&file_path));
-        assert!(exists(&dir_path));
-        
-        delete_file(&file_path)?;
-        delete_directory(&dir_path)?;
-        
-        assert!(!exists(&file_path));
-        assert!(!exists(&dir_path));
-
-        Ok(())
-    }
-
-    #[test]
-    fn test_metadata_and_permissions() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        let file_path = test_dir.path().join("test.txt");
-        
-        write_file(&file_path, "Hello")?;
-        
-        let metadata = metadata(&file_path)?;
-        assert!(metadata.is_file());
-        
-        check_permissions(&file_path, false)?;
-
-        Ok(())
-    }
-} 
\ No newline at end of file
diff --git a/src/fs/error/mod.rs b/src/fs/error/mod.rs
deleted file mode 100644
index ca477db..0000000
--- a/src/fs/error/mod.rs
+++ /dev/null
@@ -1,121 +0,0 @@
-use std::path::Path;
-use anyhow::{Result, Context, anyhow};
-
-/// エラーメッセージを生成するマクロ
-#[macro_export]
-macro_rules! fs_error {
-    ($kind:ident, $($arg:tt)*) => {
-        anyhow!("{}: {}", stringify!($kind), format!($($arg)*))
-    };
-}
-
-/// パスに関連するエラーメッセージを生成するマクロ
-#[macro_export]
-macro_rules! fs_path_error {
-    ($kind:ident, $path:expr) => {
-        anyhow!("{}: {}", stringify!($kind), $path.as_ref().display())
-    };
-}
-
-/// ファイルシステム操作に関連するエラーを生成する関数群
-pub fn not_found_error(path: impl AsRef<Path>) -> anyhow::Error {
-    fs_path_error!(NotFound, path)
-}
-
-pub fn io_error(error: std::io::Error, message: impl Into<String>) -> anyhow::Error {
-    fs_error!(IoError, "{}: {}", message.into(), error)
-}
-
-pub fn permission_error(path: impl AsRef<Path>) -> anyhow::Error {
-    fs_path_error!(PermissionDenied, path)
-}
-
-pub fn invalid_path_error(path: impl AsRef<Path>) -> anyhow::Error {
-    fs_path_error!(InvalidPath, path)
-}
-
-pub fn transaction_error(message: impl Into<String>) -> anyhow::Error {
-    fs_error!(TransactionError, "{}", message.into())
-}
-
-pub fn backup_error(message: impl Into<String>) -> anyhow::Error {
-    fs_error!(BackupError, "{}", message.into())
-}
-
-pub fn validation_error(message: impl Into<String>) -> anyhow::Error {
-    fs_error!(ValidationError, "{}", message.into())
-}
-
-/// エラー変換のための拡張トレイト
-pub trait ErrorExt<T> {
-    fn with_context_path(self, path: impl AsRef<Path>) -> Result<T>;
-    fn with_context_io(self, message: impl Into<String>) -> Result<T>;
-}
-
-impl<T, E> ErrorExt<T> for std::result::Result<T, E>
-where
-    E: std::error::Error + Send + Sync + 'static,
-{
-    fn with_context_path(self, path: impl AsRef<Path>) -> Result<T> {
-        self.with_context(|| format!("パス操作エラー: {}", path.as_ref().display()))
-    }
-
-    fn with_context_io(self, message: impl Into<String>) -> Result<T> {
-        self.with_context(|| format!("I/Oエラー: {}", message.into()))
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::path::PathBuf;
-
-    #[test]
-    fn test_error_creation() {
-        let path = PathBuf::from("/test/path");
-        
-        let err = not_found_error(&path);
-        assert!(err.to_string().contains("NotFound"));
-        assert!(err.to_string().contains("/test/path"));
-        
-        let io_err = std::io::Error::new(std::io::ErrorKind::Other, "test error");
-        let err = io_error(io_err, "Test message");
-        assert!(err.to_string().contains("IoError"));
-        assert!(err.to_string().contains("Test message"));
-        
-        let err = permission_error(&path);
-        assert!(err.to_string().contains("PermissionDenied"));
-        assert!(err.to_string().contains("/test/path"));
-        
-        let err = invalid_path_error(&path);
-        assert!(err.to_string().contains("InvalidPath"));
-        assert!(err.to_string().contains("/test/path"));
-        
-        let err = transaction_error("Test transaction error");
-        assert!(err.to_string().contains("TransactionError"));
-        assert!(err.to_string().contains("Test transaction error"));
-        
-        let err = backup_error("Test backup error");
-        assert!(err.to_string().contains("BackupError"));
-        assert!(err.to_string().contains("Test backup error"));
-        
-        let err = validation_error("Test validation error");
-        assert!(err.to_string().contains("ValidationError"));
-        assert!(err.to_string().contains("Test validation error"));
-    }
-
-    #[test]
-    fn test_error_context() {
-        let path = PathBuf::from("/test/path");
-        let result: Result<()> = Err(anyhow!("test error"));
-        
-        let err = result.with_context_path(&path);
-        assert!(err.is_err());
-        assert!(err.unwrap_err().to_string().contains("/test/path"));
-        
-        let result: Result<()> = Err(anyhow!("test error"));
-        let err = result.with_context_io("Test message");
-        assert!(err.is_err());
-        assert!(err.unwrap_err().to_string().contains("Test message"));
-    }
-} 
\ No newline at end of file
diff --git a/src/fs/mod.rs b/src/fs/mod.rs
index f39f38d..b725104 100644
--- a/src/fs/mod.rs
+++ b/src/fs/mod.rs
@@ -1,40 +1,16 @@
-pub mod backup;
-pub mod core;
 pub mod error;
+pub mod operations;
+pub mod utils;
+pub mod types;
+pub mod backup;
 pub mod manager;
-pub mod path;
 pub mod transaction;
-
-#[cfg(test)]
 pub mod tests;
 
-pub use core::{
-    ensure_directory,
-    ensure_file,
-    read_file,
-    write_file,
-    delete_file,
-    delete_directory,
-    exists,
-    is_file,
-    is_directory,
-    metadata,
-    check_permissions,
-};
-
-pub use path::{
-    normalize_path,
-    validate_path,
-    ensure_path_exists,
-};
-
-pub use error::{
-    not_found_error,
-    io_error,
-    permission_error,
-    invalid_path_error,
-    transaction_error,
-    backup_error,
-    validation_error,
-    ErrorExt,
-}; 
\ No newline at end of file
+pub use types::*;
+pub use operations::*;
+pub use utils::*;
+pub use error::*;
+pub use backup::*;
+pub use manager::*;
+pub use transaction::*; 
\ No newline at end of file
diff --git a/src/fs/path.rs b/src/fs/path.rs
deleted file mode 100644
index ba8f197..0000000
--- a/src/fs/path.rs
+++ /dev/null
@@ -1,201 +0,0 @@
-use std::path::{Path, PathBuf};
-use anyhow::Result;
-use crate::fs::error::{invalid_path_error, ErrorExt};
-
-/// パスの検証レベルを定義する列挙型
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum PathValidationLevel {
-    /// 基本的な検証のみ（絶対パスとパストラバーサルのチェック）
-    Basic,
-    /// 厳格な検証（Basic + 特殊文字、非ASCII文字、長さ制限など）
-    Strict,
-}
-
-/// パス操作に関する共通機能を提供するモジュール
-pub struct PathValidator {
-    /// パスの検証レベル
-    validation_level: PathValidationLevel,
-    /// パス長の最大値（バイト単位）
-    max_path_length: usize,
-    /// ファイル名の最大長（バイト単位）
-    max_filename_length: usize,
-}
-
-impl Default for PathValidator {
-    fn default() -> Self {
-        Self {
-            validation_level: PathValidationLevel::Basic,
-            max_path_length: 4096,
-            max_filename_length: 255,
-        }
-    }
-}
-
-impl PathValidator {
-    /// 新しいPathValidatorを作成
-    pub fn new(
-        validation_level: PathValidationLevel,
-        max_path_length: usize,
-        max_filename_length: usize,
-    ) -> Self {
-        Self {
-            validation_level,
-            max_path_length,
-            max_filename_length,
-        }
-    }
-
-    /// パスを検証
-    pub fn validate(&self, path: impl AsRef<Path>) -> Result<()> {
-        let path = path.as_ref();
-
-        // 基本的な検証
-        if path.is_absolute() {
-            return Err(invalid_path_error(path));
-        }
-
-        let path_str = path.to_string_lossy();
-        if path_str.len() > self.max_path_length {
-            return Err(invalid_path_error(format!("パスが長すぎます（最大{}バイト）", self.max_path_length)));
-        }
-
-        // パスコンポーネントの検証
-        for component in path.components() {
-            match component {
-                std::path::Component::ParentDir => {
-                    return Err(invalid_path_error("パストラバーサルは許可されていません"));
-                }
-                std::path::Component::RootDir => {
-                    return Err(invalid_path_error("絶対パスは許可されていません"));
-                }
-                std::path::Component::Normal(name) => {
-                    let name_str = name.to_string_lossy();
-                    if name_str.len() > self.max_filename_length {
-                        return Err(invalid_path_error(
-                            format!("ファイル名が長すぎます（最大{}バイト）", self.max_filename_length)
-                        ));
-                    }
-
-                    if self.validation_level == PathValidationLevel::Strict {
-                        // 特殊文字のチェック
-                        if name_str.contains(|c: char| {
-                            c.is_control() || c == '<' || c == '>' || c == ':' || c == '"' ||
-                            c == '/' || c == '\\' || c == '|' || c == '?' || c == '*'
-                        }) {
-                            return Err(invalid_path_error("ファイル名に無効な文字が含まれています"));
-                        }
-
-                        // 非ASCII文字のチェック（必要に応じて）
-                        if !name_str.chars().all(|c| c.is_ascii()) {
-                            return Err(invalid_path_error("ファイル名に非ASCII文字が含まれています"));
-                        }
-                    }
-                }
-                _ => continue,
-            }
-        }
-
-        Ok(())
-    }
-
-    /// パスを正規化
-    pub fn normalize(&self, root: impl AsRef<Path>, path: impl AsRef<Path>) -> Result<PathBuf> {
-        let path = path.as_ref();
-        
-        // パスの検証
-        self.validate(path)?;
-
-        // パスの正規化
-        let normalized = path.components()
-            .filter(|c| matches!(c, std::path::Component::Normal(_)))
-            .fold(PathBuf::new(), |mut result, component| {
-                result.push(component);
-                result
-            });
-
-        Ok(root.as_ref().join(normalized))
-    }
-}
-
-/// パスの正規化と検証を行う（デフォルトの設定を使用）
-pub fn normalize_path(root: impl AsRef<Path>, path: impl AsRef<Path>) -> Result<PathBuf> {
-    PathValidator::default().normalize(root, path)
-}
-
-/// パスが安全かどうかを検証する（デフォルトの設定を使用）
-pub fn validate_path(path: impl AsRef<Path>) -> Result<()> {
-    PathValidator::default().validate(path)
-}
-
-/// パスの存在を確認する
-pub fn ensure_path_exists(path: impl AsRef<Path>) -> Result<()> {
-    let path = path.as_ref();
-    if !path.exists() {
-        std::fs::create_dir_all(path)
-            .with_context_io(format!("ディレクトリの作成に失敗: {}", path.display()))?;
-    }
-    Ok(())
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use tempfile::tempdir;
-
-    #[test]
-    fn test_path_validation() {
-        let validator = PathValidator::default();
-
-        // 基本的な検証
-        assert!(validator.validate("normal/path").is_ok());
-        assert!(validator.validate("/absolute/path").is_err());
-        assert!(validator.validate("../parent/path").is_err());
-        
-        // パス長の検証
-        let long_path = "a".repeat(5000);
-        assert!(validator.validate(long_path).is_err());
-
-        // 厳格な検証
-        let strict_validator = PathValidator::new(
-            PathValidationLevel::Strict,
-            4096,
-            255,
-        );
-        assert!(strict_validator.validate("normal-path_123.txt").is_ok());
-        assert!(strict_validator.validate("path/with/*/wildcard").is_err());
-        assert!(strict_validator.validate("path/with/<invalid>").is_err());
-        assert!(strict_validator.validate("path/with/日本語").is_err());
-    }
-
-    #[test]
-    fn test_path_normalization() {
-        let validator = PathValidator::default();
-        let temp_dir = tempdir().unwrap();
-
-        // 正常なパスの正規化
-        let normalized = validator.normalize(&temp_dir.path(), "normal/path").unwrap();
-        assert_eq!(
-            normalized,
-            temp_dir.path().join("normal").join("path")
-        );
-
-        // 不正なパスの正規化
-        assert!(validator.normalize(&temp_dir.path(), "/absolute/path").is_err());
-        assert!(validator.normalize(&temp_dir.path(), "../parent/path").is_err());
-    }
-
-    #[test]
-    fn test_ensure_path_exists() {
-        let temp_dir = tempdir().unwrap();
-        let test_path = temp_dir.path().join("test_dir");
-
-        // パスが存在しない場合は作成される
-        assert!(!test_path.exists());
-        ensure_path_exists(&test_path).unwrap();
-        assert!(test_path.exists());
-        assert!(test_path.is_dir());
-
-        // パスが既に存在する場合はエラーにならない
-        ensure_path_exists(&test_path).unwrap();
-    }
-} 
\ No newline at end of file
diff --git a/src/fs/tests/mod.rs b/src/fs/tests/mod.rs
deleted file mode 100644
index 9eba3cc..0000000
--- a/src/fs/tests/mod.rs
+++ /dev/null
@@ -1,87 +0,0 @@
-use std::path::{Path, PathBuf};
-use anyhow::Result;
-use tempfile::{tempdir, TempDir};
-
-/// テスト用のヘルパー関数を提供するモジュール
-
-pub struct TestDirectory {
-    temp_dir: TempDir,
-}
-
-impl TestDirectory {
-    /// 新しいテストディレクトリを作成
-    pub fn new() -> Result<Self> {
-        Ok(Self {
-            temp_dir: tempdir()?,
-        })
-    }
-
-    /// テストディレクトリのパスを取得
-    pub fn path(&self) -> &Path {
-        self.temp_dir.path()
-    }
-
-    /// テストファイルを作成
-    pub fn create_file(&self, name: impl AsRef<Path>, content: impl AsRef<[u8]>) -> Result<PathBuf> {
-        let path = self.temp_dir.path().join(name);
-        if let Some(parent) = path.parent() {
-            std::fs::create_dir_all(parent)?;
-        }
-        std::fs::write(&path, content)?;
-        Ok(path)
-    }
-
-    /// テストディレクトリを作成
-    pub fn create_dir(&self, name: impl AsRef<Path>) -> Result<PathBuf> {
-        let path = self.temp_dir.path().join(name);
-        std::fs::create_dir_all(&path)?;
-        Ok(path)
-    }
-
-    /// ファイルの内容を読み込む
-    pub fn read_file(&self, name: impl AsRef<Path>) -> Result<String> {
-        let path = self.temp_dir.path().join(name);
-        Ok(std::fs::read_to_string(path)?)
-    }
-
-    /// パスが存在するかどうかを確認
-    pub fn exists(&self, name: impl AsRef<Path>) -> bool {
-        self.temp_dir.path().join(name).exists()
-    }
-
-    /// パスがファイルかどうかを確認
-    pub fn is_file(&self, name: impl AsRef<Path>) -> bool {
-        self.temp_dir.path().join(name).is_file()
-    }
-
-    /// パスがディレクトリかどうかを確認
-    pub fn is_dir(&self, name: impl AsRef<Path>) -> bool {
-        self.temp_dir.path().join(name).is_dir()
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_test_directory() -> Result<()> {
-        let test_dir = TestDirectory::new()?;
-        
-        // ファイル作成のテスト
-        let file_path = test_dir.create_file("test.txt", "Hello, World!")?;
-        assert!(test_dir.is_file("test.txt"));
-        assert_eq!(test_dir.read_file("test.txt")?, "Hello, World!");
-        
-        // ディレクトリ作成のテスト
-        let dir_path = test_dir.create_dir("test_dir")?;
-        assert!(test_dir.is_dir("test_dir"));
-        
-        // ネストしたファイル作成のテスト
-        let nested_file = test_dir.create_file("test_dir/nested.txt", "Nested content")?;
-        assert!(test_dir.is_file("test_dir/nested.txt"));
-        assert_eq!(test_dir.read_file("test_dir/nested.txt")?, "Nested content");
-        
-        Ok(())
-    }
-} 
\ No newline at end of file
