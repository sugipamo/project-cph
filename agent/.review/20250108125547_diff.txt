diff --git a/agent/feature.do b/agent/feature.do
index 9dc7c13..9e2644e 100644
--- a/agent/feature.do
+++ b/agent/feature.do
@@ -2,5 +2,4 @@
 date +%Y%m%d%H%M%Sを実行
 tree -I 'agent|target' ./ を実行
 必要なファイルを検索、実装計画をagent/.feature/yyyymmddhhmm.mdに記述する
-cargo checkを行う
 cargo clippyを行う
diff --git a/src/contest/model/mod.rs b/src/contest/model/mod.rs
index d36bdc7..28e7c0a 100644
--- a/src/contest/model/mod.rs
+++ b/src/contest/model/mod.rs
@@ -156,9 +156,10 @@ impl TestCase {
 pub enum Command {
     Login,
     Open {
-        site: String,
+        site: Option<String>,
         contest_id: Option<String>,
         problem_id: Option<String>,
+        language: Option<String>,
     },
     Test {
         test_number: Option<usize>,
diff --git a/src/contest/parse/parser.rs b/src/contest/parse/parser.rs
index a1321ec..5e6ddf9 100644
--- a/src/contest/parse/parser.rs
+++ b/src/contest/parse/parser.rs
@@ -1,7 +1,26 @@
-use anyhow::Result;
-use crate::contest::model::CommandContext;
+use anyhow::{Result, anyhow};
+use crate::contest::model::{Command, CommandContext};
+use crate::message::{contest, common};
+use petgraph::graph::NodeIndex;
+use petgraph::Direction;
 
-pub struct Parser;
+#[derive(Debug, Clone, PartialEq, Eq)]
+enum TokenType {
+    Site,
+    Language,
+    ContestId,
+    ProblemId,
+}
+
+#[derive(Debug, Clone)]
+struct TokenInterpretation {
+    token: String,
+    interpretations: Vec<(TokenType, String)>,
+}
+
+pub struct Parser {
+    config: crate::contest::parse::config::Config,
+}
 
 impl Default for Parser {
     fn default() -> Self {
@@ -11,21 +30,160 @@ impl Default for Parser {
 
 impl Parser {
     #[must_use = "この関数は新しいParserインスタンスを返します"]
-    pub const fn new() -> Self {
-        Self
+    pub fn new() -> Self {
+        Self {
+            config: crate::contest::parse::config::Config::new(),
+        }
     }
 
     /// コマンド文字列をパースします。
     /// 
-    /// # Arguments
-    /// * `input` - パースする文字列
-    /// 
     /// # Errors
-    /// - 入力文字列のパースに失敗した場合
-    /// - 無効なコマンドが指定された場合
-    /// - 必須パラメータが不足している場合
-    pub fn parse(&self, _input: &str) -> Result<CommandContext> {
-        // TODO: 実装
-        unimplemented!()
+    /// 
+    /// 以下の場合にエラーを返します：
+    /// - 入力が空の場合
+    /// - トークンの解釈に失敗した場合
+    pub fn parse(&self, input: &str) -> Result<CommandContext> {
+        let tokens: Vec<&str> = input.split_whitespace().collect();
+        if tokens.is_empty() {
+            return Err(anyhow!(common::error("invalid_input", "入力が空です")));
+        }
+
+        let mut interpretations = Vec::new();
+        for token in tokens {
+            let token_interp = self.interpret_token(token)?;
+            interpretations.push(token_interp);
+        }
+
+        Ok(Self::build_command(&interpretations))
+    }
+
+    fn get_token_type(parent: &str) -> Option<TokenType> {
+        match parent {
+            "site" => Some(TokenType::Site),
+            "language" => Some(TokenType::Language),
+            "contest" => Some(TokenType::ContestId),
+            "problem" => Some(TokenType::ProblemId),
+            _ => None,
+        }
+    }
+
+    fn get_parent_nodes(
+        graph: &petgraph::Graph<String, ()>,
+        node_idx: NodeIndex,
+    ) -> Vec<String> {
+        graph
+            .neighbors_directed(node_idx, Direction::Incoming)
+            .filter_map(|parent| graph.node_weight(parent).cloned())
+            .collect()
+    }
+
+    fn interpret_token(&self, token: &str) -> Result<TokenInterpretation> {
+        let mut interpretations = Vec::new();
+        let (graph, node_indices) = self.config.build_alias_graph();
+        
+        if let Some(&node_idx) = node_indices.get(token) {
+            let parents = Self::get_parent_nodes(&graph, node_idx);
+            let token_types: Vec<_> = parents
+                .iter()
+                .filter_map(|parent| Self::get_token_type(parent))
+                .collect();
+
+            if token_types.len() > 1 {
+                return Err(anyhow!(contest::error(
+                    "parse_error",
+                    format!("トークン '{token}' は複数の方法で解釈できます")
+                )));
+            }
+
+            if let Some(token_type) = token_types.first() {
+                interpretations.push((token_type.clone(), token.to_string()));
+                return Ok(TokenInterpretation {
+                    token: token.to_string(),
+                    interpretations,
+                });
+            }
+        }
+
+        Ok(TokenInterpretation {
+            token: token.to_string(),
+            interpretations,
+        })
+    }
+
+    fn assign_interpreted_tokens(
+        interpretations: &[TokenInterpretation],
+    ) -> (Option<String>, Option<String>, Option<String>, Option<String>) {
+        let mut site = None;
+        let mut language = None;
+        let mut contest_id = None;
+        let mut problem_id = None;
+
+        for interp in interpretations {
+            for (token_type, value) in &interp.interpretations {
+                match token_type {
+                    TokenType::Site => site = Some(value.clone()),
+                    TokenType::Language => language = Some(value.clone()),
+                    TokenType::ContestId => contest_id = Some(value.clone()),
+                    TokenType::ProblemId => problem_id = Some(value.clone()),
+                }
+            }
+        }
+
+        (site, language, contest_id, problem_id)
+    }
+
+    fn assign_uninterpreted_tokens(
+        interpretations: &[TokenInterpretation],
+        contest_id: Option<String>,
+        problem_id: Option<String>,
+    ) -> (Option<String>, Option<String>) {
+        let mut contest_id = contest_id;
+        let mut problem_id = problem_id;
+        
+        // エイリアスとして解釈できなかったトークンを収集
+        let uninterpreted: Vec<_> = interpretations
+            .iter()
+            .filter(|i| i.interpretations.is_empty())
+            .collect();
+
+        // 未解釈トークンがある場合、優先度に基づいて解釈
+        // contest (priority: 2) > problem (priority: 1)
+        let mut tokens = uninterpreted.into_iter();
+        
+        // contest_idが未設定の場合、最初の未解釈トークンをcontest_idとして使用
+        if contest_id.is_none() {
+            if let Some(token) = tokens.next() {
+                contest_id = Some(token.token.clone());
+            }
+        }
+
+        // problem_idが未設定で、まだ未解釈トークンが残っている場合
+        // 次の未解釈トークンをproblem_idとして使用
+        if problem_id.is_none() {
+            if let Some(token) = tokens.next() {
+                problem_id = Some(token.token.clone());
+            }
+        }
+
+        (contest_id, problem_id)
+    }
+
+    fn build_command(interpretations: &[TokenInterpretation]) -> CommandContext {
+        let (site, language, contest_id, problem_id) = Self::assign_interpreted_tokens(interpretations);
+        let (contest_id, problem_id) = Self::assign_uninterpreted_tokens(
+            interpretations,
+            contest_id,
+            problem_id,
+        );
+
+        let command = Command::Open {
+            site,
+            contest_id,
+            problem_id,
+            language,
+        };
+
+        CommandContext::new(command)
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/command.rs b/src/contest/service/command.rs
index bd4193a..34b43ae 100644
--- a/src/contest/service/command.rs
+++ b/src/contest/service/command.rs
@@ -29,9 +29,12 @@ impl Service {
                 println!("ログイン処理を実行します");
                 Ok(())
             }
-            Command::Open { site, contest_id, problem_id } => {
-                println!("問題を開きます: site={site}, contest={contest_id:?}, problem={problem_id:?}");
-                self.contest_service.open(&site, &contest_id, &problem_id)
+            Command::Open { site, contest_id, problem_id, language: _ } => {
+                println!("問題を開きます: site={site:?}, contest={contest_id:?}, problem={problem_id:?}");
+                site.map_or_else(
+                    || Err(anyhow::anyhow!(contest::error("invalid_command", "サイトが指定されていません"))),
+                    |site_str| self.contest_service.open(&site_str, &contest_id, &problem_id)
+                )
             }
             Command::Test { test_number } => {
                 context.contest.map_or_else(
