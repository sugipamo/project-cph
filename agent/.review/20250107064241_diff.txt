diff --git a/src/contest/model/state.rs b/src/contest/model/state.rs
index cacfe4e..2dab735 100644
--- a/src/contest/model/state.rs
+++ b/src/contest/model/state.rs
@@ -39,6 +39,16 @@ pub struct ValidatedState {
     pub(crate) source_path: Arc<PathBuf>,
 }
 
+// 状態遷移の型安全性を向上させるための新しい型
+#[derive(Debug, Clone)]
+pub enum StateTransition {
+    SetSite(String),
+    SetContestId(String),
+    SetProblemId(String),
+    SetLanguage(String),
+    SetSourcePath(PathBuf),
+}
+
 impl ContestState {
     pub fn new() -> Self {
         Self {
@@ -70,29 +80,54 @@ impl ContestState {
         self.source_path.as_ref().map(|p| p.as_ref())
     }
 
-    pub fn validate(&self) -> Result<ValidatedState> {
-        if self.site.is_none() {
-            return Err(contest_error(ContestErrorKind::NotFound, "サイトが指定されていません"));
+    // 型安全な状態遷移メソッドを追加
+    pub fn apply_transition(self, transition: StateTransition) -> Self {
+        match transition {
+            StateTransition::SetSite(site) => self.with_site(site),
+            StateTransition::SetContestId(id) => self.with_contest_id(id),
+            StateTransition::SetProblemId(id) => self.with_problem_id(id),
+            StateTransition::SetLanguage(lang) => self.with_language(lang),
+            StateTransition::SetSourcePath(path) => self.with_source_path(path),
         }
-        if self.contest_id.is_none() {
-            return Err(contest_error(ContestErrorKind::NotFound, "コンテストIDが指定されていません"));
+    }
+
+    // バリデーション機能を強化
+    pub fn validate(&self) -> Result<ValidatedState> {
+        let site = self.site.clone()
+            .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "サイトが指定されていません"))?;
+        
+        let contest_id = self.contest_id.clone()
+            .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "コンテストIDが指定されていません"))?;
+        
+        let problem_id = self.problem_id.clone()
+            .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "問題IDが指定されていません"))?;
+        
+        let language = self.language.clone()
+            .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "言語が指定されていません"))?;
+        
+        let source_path = self.source_path.clone()
+            .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "ソースパスが指定されていません"))?;
+
+        // 追加のバリデーションルール
+        if site.is_empty() {
+            return Err(contest_error(ContestErrorKind::Invalid, "サイトが空です"));
         }
-        if self.problem_id.is_none() {
-            return Err(contest_error(ContestErrorKind::NotFound, "問題IDが指定されていません"));
+        if contest_id.is_empty() {
+            return Err(contest_error(ContestErrorKind::Invalid, "コンテストIDが空です"));
         }
-        if self.language.is_none() {
-            return Err(contest_error(ContestErrorKind::NotFound, "言語が指定されていません"));
+        if problem_id.is_empty() {
+            return Err(contest_error(ContestErrorKind::Invalid, "問題IDが空です"));
         }
-        if self.source_path.is_none() {
-            return Err(contest_error(ContestErrorKind::NotFound, "ソースパスが指定されていません"));
+        if language.is_empty() {
+            return Err(contest_error(ContestErrorKind::Invalid, "言語が空です"));
         }
 
         Ok(ValidatedState {
-            site: Arc::clone(self.site.as_ref().unwrap()),
-            contest_id: Arc::clone(self.contest_id.as_ref().unwrap()),
-            problem_id: Arc::clone(self.problem_id.as_ref().unwrap()),
-            language: Arc::clone(self.language.as_ref().unwrap()),
-            source_path: Arc::clone(self.source_path.as_ref().unwrap()),
+            site,
+            contest_id,
+            problem_id,
+            language,
+            source_path,
         })
     }
 
@@ -142,4 +177,17 @@ impl ValidatedState {
     pub fn source_path(&self) -> &PathBuf {
         &self.source_path
     }
+
+    // 新しいメソッド：状態の変更を試みる（新しいValidatedStateを返す）
+    pub fn try_update(&self, transition: StateTransition) -> Result<ValidatedState> {
+        let mut new_state = ContestState::new()
+            .with_site(self.site.as_ref().clone())
+            .with_contest_id(self.contest_id.as_ref().clone())
+            .with_problem_id(self.problem_id.as_ref().clone())
+            .with_language(self.language.as_ref().clone())
+            .with_source_path(self.source_path.as_ref().clone());
+
+        new_state = new_state.apply_transition(transition);
+        new_state.validate()
+    }
 } 
\ No newline at end of file
diff --git a/src/docker/state/manager.rs b/src/docker/state/manager.rs
index 8e937d9..061ba4a 100644
--- a/src/docker/state/manager.rs
+++ b/src/docker/state/manager.rs
@@ -3,7 +3,6 @@ use tokio::sync::RwLock;
 use crate::error::Result;
 use super::ContainerState;
 use crate::docker::error::state_err;
-use crate::docker::state::operations;
 use std::collections::HashMap;
 
 #[derive(Debug, Clone)]
@@ -14,7 +13,7 @@ pub struct ContainerStateManager {
 impl ContainerStateManager {
     pub fn new() -> Self {
         Self {
-            state: Arc::new(RwLock::new(ContainerState::Initial)),
+            state: Arc::new(RwLock::new(ContainerState::new())),
         }
     }
 
@@ -24,28 +23,56 @@ impl ContainerStateManager {
 
     pub async fn create_container(&self, container_id: String) -> Result<()> {
         let current_state = self.get_current_state().await;
-        let new_state = operations::create_container(&current_state, container_id).await?;
-        *self.state.write().await = new_state;
+        if !matches!(current_state, ContainerState::Initial) {
+            return Err(state_err(
+                "状態遷移",
+                format!("無効な状態からの作成遷移: {}", current_state)
+            ));
+        }
+        *self.state.write().await = ContainerState::create(container_id);
         Ok(())
     }
 
     pub async fn start_container(&self) -> Result<()> {
         let current_state = self.get_current_state().await;
-        let new_state = operations::start_container(&current_state).await?;
+        let new_state = current_state.start()
+            .ok_or_else(|| state_err(
+                "状態遷移",
+                format!("無効な状態からの開始遷移: {}", current_state)
+            ))?;
+        *self.state.write().await = new_state;
+        Ok(())
+    }
+
+    pub async fn execute_command(&self, command: String) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = current_state.execute(command)
+            .ok_or_else(|| state_err(
+                "状態遷移",
+                format!("無効な状態からのコマンド実行遷移: {}", current_state)
+            ))?;
         *self.state.write().await = new_state;
         Ok(())
     }
 
     pub async fn stop_container(&self) -> Result<()> {
         let current_state = self.get_current_state().await;
-        let new_state = operations::stop_container(&current_state).await?;
+        let new_state = current_state.stop()
+            .ok_or_else(|| state_err(
+                "状態遷移",
+                format!("無効な状態からの停止遷移: {}", current_state)
+            ))?;
         *self.state.write().await = new_state;
         Ok(())
     }
 
-    pub async fn fail_container(&self, container_id: String, error: String) -> Result<()> {
+    pub async fn fail_container(&self, error: String) -> Result<()> {
         let current_state = self.get_current_state().await;
-        let new_state = operations::fail_container(&current_state, container_id, error).await?;
+        let new_state = current_state.fail(error)
+            .ok_or_else(|| state_err(
+                "状態遷移",
+                format!("無効な状態からの失敗遷移: {}", current_state)
+            ))?;
         *self.state.write().await = new_state;
         Ok(())
     }
@@ -58,31 +85,36 @@ impl ContainerStateManager {
     }
 }
 
+#[derive(Debug, Clone)]
 pub struct StateManager {
-    states: HashMap<String, ContainerState>,
+    states: Arc<RwLock<HashMap<Arc<String>, ContainerState>>>,
 }
 
 impl StateManager {
     pub fn new() -> Self {
         Self {
-            states: HashMap::new(),
+            states: Arc::new(RwLock::new(HashMap::new())),
         }
     }
 
-    pub fn get_state(&self, container_id: &str) -> Option<&ContainerState> {
-        self.states.get(container_id)
+    pub async fn get_state(&self, container_id: &str) -> Option<ContainerState> {
+        self.states.read().await
+            .get(&Arc::new(container_id.to_string()))
+            .cloned()
     }
 
-    pub fn set_state(&mut self, container_id: String, state: ContainerState) {
-        self.states.insert(container_id, state);
+    pub async fn set_state(&self, container_id: String, state: ContainerState) {
+        self.states.write().await
+            .insert(Arc::new(container_id), state);
     }
 
-    pub fn remove_state(&mut self, container_id: &str) {
-        self.states.remove(container_id);
+    pub async fn remove_state(&self, container_id: &str) {
+        self.states.write().await
+            .remove(&Arc::new(container_id.to_string()));
     }
 
-    pub fn get_container_id(&self) -> Result<String> {
-        self.states
+    pub async fn get_container_id(&self) -> Result<String> {
+        self.states.read().await
             .keys()
             .next()
             .map(|s| s.to_string())
diff --git a/src/docker/state/operations.rs b/src/docker/state/operations.rs
index dc4d767..ece8578 100644
--- a/src/docker/state/operations.rs
+++ b/src/docker/state/operations.rs
@@ -1,4 +1,5 @@
 use std::time::Instant;
+use std::sync::Arc;
 use crate::error::Result;
 use super::ContainerState;
 use crate::docker::error::state_err;
@@ -22,9 +23,9 @@ pub async fn fail_container(current_state: &ContainerState, container_id: String
         },
         _ => {
             Ok(ContainerState::Failed {
-                container_id,
-                error,
-                occurred_at: Instant::now(),
+                container_id: Arc::new(container_id),
+                error: Arc::new(error),
+                occurred_at: Arc::new(Instant::now()),
             })
         }
     }
@@ -34,8 +35,8 @@ pub async fn create_container(current_state: &ContainerState, container_id: Stri
     match current_state {
         ContainerState::Initial => {
             Ok(ContainerState::Created {
-                container_id,
-                created_at: Instant::now(),
+                container_id: Arc::new(container_id),
+                created_at: Arc::new(Instant::now()),
             })
         },
         _ => {
@@ -51,8 +52,8 @@ pub async fn start_container(current_state: &ContainerState) -> Result<Container
     match current_state {
         ContainerState::Created { container_id, .. } => {
             Ok(ContainerState::Running {
-                container_id: container_id.clone(),
-                started_at: Instant::now(),
+                container_id: Arc::clone(container_id),
+                started_at: Arc::new(Instant::now()),
             })
         },
         _ => {
@@ -69,8 +70,8 @@ pub async fn stop_container(current_state: &ContainerState) -> Result<ContainerS
         ContainerState::Running { container_id, .. } |
         ContainerState::Executing { container_id, .. } => {
             Ok(ContainerState::Stopped {
-                container_id: container_id.clone(),
-                stopped_at: Instant::now(),
+                container_id: Arc::clone(container_id),
+                stopped_at: Arc::new(Instant::now()),
                 exit_status: None,
             })
         },
diff --git a/src/docker/state/types.rs b/src/docker/state/types.rs
index 886f679..24e0ba5 100644
--- a/src/docker/state/types.rs
+++ b/src/docker/state/types.rs
@@ -1,36 +1,94 @@
 use std::fmt;
 use std::time::{Duration, Instant};
 use std::process::ExitStatus;
+use std::sync::Arc;
 
 #[derive(Debug, Clone)]
 pub enum ContainerState {
     Initial,
     Created {
-        container_id: String,
-        created_at: Instant,
+        container_id: Arc<String>,
+        created_at: Arc<Instant>,
     },
     Running {
-        container_id: String,
-        started_at: Instant,
+        container_id: Arc<String>,
+        started_at: Arc<Instant>,
     },
     Executing {
-        container_id: String,
-        started_at: Instant,
-        command: String,
+        container_id: Arc<String>,
+        started_at: Arc<Instant>,
+        command: Arc<String>,
     },
     Stopped {
-        container_id: String,
-        stopped_at: Instant,
-        exit_status: Option<ExitStatus>,
+        container_id: Arc<String>,
+        stopped_at: Arc<Instant>,
+        exit_status: Option<Arc<ExitStatus>>,
     },
     Failed {
-        container_id: String,
-        error: String,
-        occurred_at: Instant,
+        container_id: Arc<String>,
+        error: Arc<String>,
+        occurred_at: Arc<Instant>,
     },
 }
 
 impl ContainerState {
+    pub fn new() -> Self {
+        Self::Initial
+    }
+
+    pub fn create(container_id: String) -> Self {
+        Self::Created {
+            container_id: Arc::new(container_id),
+            created_at: Arc::new(Instant::now()),
+        }
+    }
+
+    pub fn start(&self) -> Option<Self> {
+        match self {
+            Self::Created { container_id, .. } => Some(Self::Running {
+                container_id: Arc::clone(container_id),
+                started_at: Arc::new(Instant::now()),
+            }),
+            _ => None,
+        }
+    }
+
+    pub fn execute(&self, command: String) -> Option<Self> {
+        match self {
+            Self::Running { container_id, started_at } => Some(Self::Executing {
+                container_id: Arc::clone(container_id),
+                started_at: Arc::clone(started_at),
+                command: Arc::new(command),
+            }),
+            _ => None,
+        }
+    }
+
+    pub fn stop(&self) -> Option<Self> {
+        match self {
+            Self::Running { container_id, .. } |
+            Self::Executing { container_id, .. } => Some(Self::Stopped {
+                container_id: Arc::clone(container_id),
+                stopped_at: Arc::new(Instant::now()),
+                exit_status: None,
+            }),
+            _ => None,
+        }
+    }
+
+    pub fn fail(&self, error: String) -> Option<Self> {
+        match self {
+            Self::Created { container_id, .. } |
+            Self::Running { container_id, .. } |
+            Self::Executing { container_id, .. } => Some(Self::Failed {
+                container_id: Arc::clone(container_id),
+                error: Arc::new(error),
+                occurred_at: Arc::new(Instant::now()),
+            }),
+            _ => None,
+        }
+    }
+
     pub fn container_id(&self) -> Option<&str> {
         match self {
             ContainerState::Initial => None,
diff --git a/src/error/contest.rs b/src/error/contest.rs
index 217884c..66457bd 100644
--- a/src/error/contest.rs
+++ b/src/error/contest.rs
@@ -1,20 +1,15 @@
 use std::fmt;
 use crate::error::{Error, ErrorKind, ErrorSeverity};
 
-pub fn contest_err(error: impl Into<String>, message: impl Into<String>) -> Error {
-    Error::new(
-        ContestErrorKind::Other(error.into()),
-        message
-    ).with_hint("コンテストの操作に失敗しました")
-}
-
 #[derive(Debug, Clone)]
 pub enum ContestErrorKind {
     NotFound,
+    Invalid,
     InvalidLanguage,
-    InvalidTestCase,
     InvalidUrl,
     Parse,
+    IO,
+    Docker,
     Other(String),
 }
 
@@ -31,11 +26,18 @@ impl fmt::Display for ContestErrorKind {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self {
             Self::NotFound => write!(f, "リソースが見つかりません"),
+            Self::Invalid => write!(f, "入力値が不正です"),
             Self::InvalidLanguage => write!(f, "サポートされていない言語です"),
-            Self::InvalidTestCase => write!(f, "テストケースが不正です"),
             Self::InvalidUrl => write!(f, "URLの形式が正しくありません"),
             Self::Parse => write!(f, "パースに失敗しました"),
+            Self::IO => write!(f, "I/Oエラーが発生しました"),
+            Self::Docker => write!(f, "Dockerの操作に失敗しました"),
             Self::Other(s) => write!(f, "{}", s),
         }
     }
+}
+
+pub fn contest_error(kind: ContestErrorKind, message: impl Into<String>) -> Error {
+    Error::new(kind, message)
+        .with_hint("コンテストの操作に失敗しました")
 } 
\ No newline at end of file
diff --git a/src/fs/manager.rs b/src/fs/manager.rs
index 64f2dd4..138bea5 100644
--- a/src/fs/manager.rs
+++ b/src/fs/manager.rs
@@ -1,62 +1,102 @@
-use std::path::Path;
+use std::path::{Path, PathBuf};
+use std::sync::Arc;
 use crate::error::Result;
-use crate::fs::error::{io_err, not_found_err};
+use crate::fs::error::{io_err, not_found_err, invalid_path_err};
 
+#[derive(Debug, Clone)]
 pub struct FileManager {
-    root: String,
+    root: Arc<PathBuf>,
 }
 
 impl FileManager {
-    pub fn new(root: impl Into<String>) -> Self {
+    pub fn new(root: impl Into<PathBuf>) -> Self {
         Self {
-            root: root.into(),
+            root: Arc::new(root.into()),
         }
     }
 
-    pub fn read_file(&self, path: impl AsRef<Path>) -> Result<String> {
+    // パスの正規化と検証を行うヘルパーメソッド
+    fn normalize_path(&self, path: impl AsRef<Path>) -> Result<PathBuf> {
         let path = path.as_ref();
+        
+        // 絶対パスの場合はエラー
+        if path.is_absolute() {
+            return Err(invalid_path_err(format!(
+                "絶対パスは使用できません: {}",
+                path.display()
+            )));
+        }
+
+        // パスのトラバーサルを防ぐ
+        let normalized = path.components()
+            .fold(Ok(PathBuf::new()), |acc, component| {
+                let mut path = acc?;
+                match component {
+                    std::path::Component::ParentDir => {
+                        if path.pop() {
+                            Ok(path)
+                        } else {
+                            Err(invalid_path_err(format!(
+                                "パスが親ディレクトリを超えて遡ることはできません: {}",
+                                path.display()
+                            )))
+                        }
+                    },
+                    std::path::Component::Normal(name) => {
+                        path.push(name);
+                        Ok(path)
+                    },
+                    _ => Ok(path),
+                }
+            })?;
+
+        Ok(self.root.join(normalized))
+    }
+
+    pub fn read_file(&self, path: impl AsRef<Path>) -> Result<String> {
+        let path = self.normalize_path(path)?;
         if !path.exists() {
-            return Err(not_found_err(path.to_string_lossy().to_string()));
+            return Err(not_found_err(format!(
+                "ファイルが見つかりません: {}",
+                path.display()
+            )));
         }
-        std::fs::read_to_string(path)
+        std::fs::read_to_string(&path)
             .map_err(|e| io_err(e, format!("ファイルの読み込みに失敗: {}", path.display())))
     }
 
     pub fn write_file(&self, path: impl AsRef<Path>, content: impl AsRef<str>) -> Result<()> {
-        let path = path.as_ref();
+        let path = self.normalize_path(path)?;
         if let Some(parent) = path.parent() {
             std::fs::create_dir_all(parent)
                 .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", parent.display())))?;
         }
-        std::fs::write(path, content.as_ref())
+        std::fs::write(&path, content.as_ref())
             .map_err(|e| io_err(e, format!("ファイルの書き込みに失敗: {}", path.display())))
     }
 
-    pub fn create_dir(&self, path: impl AsRef<Path>) -> Result<()> {
-        let path = path.as_ref();
-        if path.exists() {
+    pub fn delete_file(&self, path: impl AsRef<Path>) -> Result<()> {
+        let path = self.normalize_path(path)?;
+        if !path.exists() {
             return Ok(());
         }
-        std::fs::create_dir_all(path)
+        std::fs::remove_file(&path)
+            .map_err(|e| io_err(e, format!("ファイルの削除に失敗: {}", path.display())))
+    }
+
+    pub fn create_dir(&self, path: impl AsRef<Path>) -> Result<()> {
+        let path = self.normalize_path(path)?;
+        std::fs::create_dir_all(&path)
             .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", path.display())))
     }
 
-    pub fn remove_file(&self, path: impl AsRef<Path>) -> Result<()> {
-        let path = path.as_ref();
-        if !path.exists() {
-            return Ok(());
-        }
-        std::fs::remove_file(path)
-            .map_err(|e| io_err(e, format!("ファイルの削除に失敗: {}", path.display())))
+    pub fn exists(&self, path: impl AsRef<Path>) -> Result<bool> {
+        let path = self.normalize_path(path)?;
+        Ok(path.exists())
     }
 
-    pub fn remove_dir(&self, path: impl AsRef<Path>) -> Result<()> {
-        let path = path.as_ref();
-        if !path.exists() {
-            return Ok(());
-        }
-        std::fs::remove_dir_all(path)
-            .map_err(|e| io_err(e, format!("ディレクトリの削除に失敗: {}", path.display())))
+    pub fn root_path(&self) -> &Path {
+        self.root.as_ref()
     }
 }
 
@@ -80,7 +120,7 @@ mod tests {
         assert_eq!(content, "Hello, World!");
 
         // ファイルの削除
-        manager.remove_file(&test_file)?;
+        manager.delete_file(&test_file)?;
         assert!(!test_file.exists());
 
         // ディレクトリの作成
@@ -89,7 +129,7 @@ mod tests {
         assert!(test_dir.exists());
 
         // ディレクトリの削除
-        manager.remove_dir(&test_dir)?;
+        manager.delete_file(&test_dir)?;
         assert!(!test_dir.exists());
 
         Ok(())
diff --git a/src/fs/transaction.rs b/src/fs/transaction.rs
index e65aad4..d6139ab 100644
--- a/src/fs/transaction.rs
+++ b/src/fs/transaction.rs
@@ -1,22 +1,35 @@
 use std::path::{Path, PathBuf};
+use std::sync::Arc;
 use crate::error::Error;
 use crate::fs::error::{io_err, not_found_err};
 
+pub trait FileOperation: Send + Sync + std::fmt::Debug {
+    fn execute(&self) -> Result<(), Error>;
+    fn rollback(&self) -> Result<(), Error>;
+    fn description(&self) -> String;
+}
+
+#[derive(Debug, Clone)]
 pub struct FileTransaction {
-    operations: Vec<Box<dyn FileOperation>>,
+    operations: Arc<Vec<Arc<dyn FileOperation>>>,
     executed: bool,
 }
 
 impl FileTransaction {
     pub fn new() -> Self {
         Self {
-            operations: Vec::new(),
+            operations: Arc::new(Vec::new()),
             executed: false,
         }
     }
 
-    pub fn add_operation(&mut self, operation: Box<dyn FileOperation>) {
-        self.operations.push(operation);
+    pub fn with_operation(mut self, operation: Arc<dyn FileOperation>) -> Self {
+        let mut operations = Arc::get_mut(&mut self.operations)
+            .expect("FileTransactionのoperationsが他で参照されています")
+            .clone();
+        operations.push(operation);
+        self.operations = Arc::new(operations);
+        self
     }
 
     pub fn execute(&mut self) -> Result<(), Error> {
@@ -24,7 +37,7 @@ impl FileTransaction {
             return Ok(());
         }
 
-        for operation in &self.operations {
+        for operation in self.operations.iter() {
             if let Err(e) = operation.execute() {
                 self.rollback()?;
                 return Err(e);
@@ -35,89 +48,107 @@ impl FileTransaction {
         Ok(())
     }
 
-    pub fn rollback(&mut self) -> Result<(), Error> {
+    pub fn rollback(&self) -> Result<(), Error> {
         for operation in self.operations.iter().rev() {
             if let Err(e) = operation.rollback() {
-                return Err(io_err(
-                    std::io::Error::new(std::io::ErrorKind::Other, e.to_string()),
-                    "トランザクションのロールバック中にエラーが発生".to_string(),
-                ));
+                return Err(e);
             }
         }
-        self.executed = false;
         Ok(())
     }
-}
 
-pub trait FileOperation: Send + Sync {
-    fn execute(&self) -> Result<(), Error>;
-    fn rollback(&self) -> Result<(), Error>;
+    pub fn is_executed(&self) -> bool {
+        self.executed
+    }
+
+    pub fn operations(&self) -> &[Arc<dyn FileOperation>] {
+        &self.operations
+    }
 }
 
-pub struct CopyOperation {
-    source: PathBuf,
-    destination: PathBuf,
+// イミュータブルな操作を実装するための具体的な型
+#[derive(Debug)]
+pub struct CreateFileOperation {
+    path: Arc<PathBuf>,
+    content: Arc<String>,
 }
 
-impl CopyOperation {
-    pub fn new<P: AsRef<Path>>(source: P, destination: P) -> Self {
+impl CreateFileOperation {
+    pub fn new(path: PathBuf, content: String) -> Self {
         Self {
-            source: source.as_ref().to_path_buf(),
-            destination: destination.as_ref().to_path_buf(),
+            path: Arc::new(path),
+            content: Arc::new(content),
         }
     }
 }
 
-impl FileOperation for CopyOperation {
+impl FileOperation for CreateFileOperation {
     fn execute(&self) -> Result<(), Error> {
-        if !self.source.exists() {
-            return Err(not_found_err(self.source.to_string_lossy().to_string()));
-        }
-
-        if let Some(parent) = self.destination.parent() {
+        if let Some(parent) = self.path.parent() {
             std::fs::create_dir_all(parent)
-                .map_err(|e| io_err(e, format!("親ディレクトリの作成に失敗: {}", parent.display())))?;
+                .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", parent.display())))?;
         }
-
-        std::fs::copy(&self.source, &self.destination)
-            .map_err(|e| io_err(e, format!("ファイルのコピーに失敗: {} -> {}", 
-                self.source.display(), self.destination.display())))?;
-        Ok(())
+        std::fs::write(&*self.path, &*self.content)
+            .map_err(|e| io_err(e, format!("ファイルの書き込みに失敗: {}", self.path.display())))
     }
 
     fn rollback(&self) -> Result<(), Error> {
-        if self.destination.exists() {
-            std::fs::remove_file(&self.destination)
-                .map_err(|e| io_err(e, format!("ファイルの削除に失敗: {}", self.destination.display())))?;
+        if self.path.exists() {
+            std::fs::remove_file(&*self.path)
+                .map_err(|e| io_err(e, format!("ファイルの削除に失敗: {}", self.path.display())))?;
         }
         Ok(())
     }
+
+    fn description(&self) -> String {
+        format!("ファイル作成: {}", self.path.display())
+    }
 }
 
-pub struct CreateDirectoryOperation {
-    path: PathBuf,
+#[derive(Debug)]
+pub struct DeleteFileOperation {
+    path: Arc<PathBuf>,
+    original_content: Option<Arc<String>>,
 }
 
-impl CreateDirectoryOperation {
-    pub fn new<P: AsRef<Path>>(path: P) -> Self {
-        Self {
-            path: path.as_ref().to_path_buf(),
-        }
+impl DeleteFileOperation {
+    pub fn new(path: PathBuf) -> Result<Self, Error> {
+        let original_content = if path.exists() {
+            Some(Arc::new(std::fs::read_to_string(&path)
+                .map_err(|e| io_err(e, format!("ファイルの読み込みに失敗: {}", path.display())))?))
+        } else {
+            None
+        };
+
+        Ok(Self {
+            path: Arc::new(path),
+            original_content,
+        })
     }
 }
 
-impl FileOperation for CreateDirectoryOperation {
+impl FileOperation for DeleteFileOperation {
     fn execute(&self) -> Result<(), Error> {
-        std::fs::create_dir_all(&self.path)
-            .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", self.path.display())))?;
+        if self.path.exists() {
+            std::fs::remove_file(&*self.path)
+                .map_err(|e| io_err(e, format!("ファイルの削除に失敗: {}", self.path.display())))?;
+        }
         Ok(())
     }
 
     fn rollback(&self) -> Result<(), Error> {
-        if self.path.exists() {
-            std::fs::remove_dir_all(&self.path)
-                .map_err(|e| io_err(e, format!("ディレクトリの削除に失敗: {}", self.path.display())))?;
+        if let Some(content) = &self.original_content {
+            if let Some(parent) = self.path.parent() {
+                std::fs::create_dir_all(parent)
+                    .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", parent.display())))?;
+            }
+            std::fs::write(&*self.path, &**content)
+                .map_err(|e| io_err(e, format!("ファイルの復元に失敗: {}", self.path.display())))?;
         }
         Ok(())
     }
+
+    fn description(&self) -> String {
+        format!("ファイル削除: {}", self.path.display())
+    }
 } 
