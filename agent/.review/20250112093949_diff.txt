diff --git a/src/config/config.yaml b/src/config/config.yaml
index 49111fe..ab68d37 100644
--- a/src/config/config.yaml
+++ b/src/config/config.yaml
@@ -7,8 +7,8 @@ system:
     - "code"
     - "cursor"
   container:
-    timeout_seconds: ${CPH_DOCKER_TIMEOUT-10}
-    memory_limit_mb: ${CPH_DOCKER_MEMORY-256}
+    timeout_seconds: ${CPH_CONTAINER_TIMEOUT-10}
+    memory_limit_mb: ${CPH_CONTAINER_MEMORY-256}
     mount_point: "/compile"
     runtime:
       containerd:
@@ -27,8 +27,8 @@ languages:
       require_files: []
       env_vars: []
       container:
-        timeout_seconds: ${CPH_DOCKER_TIMEOUT-10}
-        memory_limit_mb: ${CPH_DOCKER_MEMORY-256}
+        timeout_seconds: ${CPH_CONTAINER_TIMEOUT-10}
+        memory_limit_mb: ${CPH_CONTAINER_MEMORY-256}
         mount_point: "/compile"
       image:
         type: "official"
@@ -56,8 +56,8 @@ languages:
     extension: "rs"
     runner:
       image:
-        type: "custom"
-        source: "${CPH_RUST_DOCKERFILE-src/config/dockerfile/rust.dockerfile}"
+        type: "official"
+        source: "rust:1.70.0"
       compile_dir: "${CPH_COMPILE_DIR-compile/rust}"
       compile: ["rustc", "main.rs"]
       run: ["./main"]
@@ -77,8 +77,8 @@ languages:
     extension: "py"
     runner:
       image:
-        type: "custom"
-        source: "${CPH_PYTHON_DOCKERFILE-src/config/dockerfile/python.dockerfile}"
+        type: "official"
+        source: "python:3.11.4"
       compile_dir: "${CPH_COMPILE_DIR-compile/python}"
       run: ["python", "main.py"]
       container:
@@ -94,8 +94,8 @@ languages:
     extension: "cpp"
     runner:
       image:
-        type: "custom"
-        source: "${CPH_CPP_DOCKERFILE-src/config/dockerfile/cpp.dockerfile}"
+        type: "official"
+        source: "gcc:9.2.1"
       compile_dir: "${CPH_COMPILE_DIR-compile/cpp}"
       compile: ["g++", "-std=c++17", "-O2", "main.cpp"]
       run: ["./a.out"]
@@ -114,8 +114,8 @@ languages:
     extension: "py"
     runner:
       image:
-        type: "custom"
-        source: "${CPH_PYPY_DOCKERFILE-src/config/dockerfile/pypy.dockerfile}"
+        type: "official"
+        source: "pypy:3.9"
       compile_dir: "${CPH_COMPILE_DIR-compile/pypy}"
       run: ["pypy3", "main.py"]
       container:
diff --git a/src/container/image_builder.rs b/src/container/image_builder.rs
index 99198b9..f7340ea 100644
--- a/src/container/image_builder.rs
+++ b/src/container/image_builder.rs
@@ -1,62 +1,237 @@
 use std::path::PathBuf;
-use anyhow::Result;
+use anyhow::{Result, anyhow};
 use async_trait::async_trait;
-use tokio::process::Command;
+use containerd_client as containerd;
+use containerd_client::services::v1::images_client::ImagesClient;
+use containerd_client::services::v1::content_client::ContentClient;
+use containerd_client::services::v1::containers_client::ContainersClient;
+use containerd_client::services::v1::tasks_client::TasksClient;
+use prost_types::Any;
+use std::sync::Arc;
+use tokio::sync::Mutex;
+use tokio::fs::File;
+use tokio::io::AsyncReadExt;
+use tokio::time::{sleep, Duration};
 
 #[async_trait]
 pub trait ImageBuilder: Send + Sync {
     async fn build_image(&self, tag: &str) -> Result<()>;
 }
 
-pub struct DockerfileBuilder {
-    dockerfile_path: PathBuf,
-    context_path: PathBuf,
+pub struct OfficialImageBuilder {
+    image_name: String,
+    images: Arc<Mutex<ImagesClient<tonic::transport::Channel>>>,
+    containers: Arc<Mutex<ContainersClient<tonic::transport::Channel>>>,
+    tasks: Arc<Mutex<TasksClient<tonic::transport::Channel>>>,
+    setup_commands: Vec<String>,
 }
 
-impl DockerfileBuilder {
-    /// 新しいDockerfileビルダーを作成します。
+impl OfficialImageBuilder {
+    /// 新しい公式イメージビルダーを作成します。
     ///
     /// # Arguments
-    /// * `dockerfile_path` - Dockerfileのパス
-    /// * `context_path` - コンテキストのパス（省略可能）
+    /// * `image_name` - 公式イメージの名前（例: "python:3.9"）
+    /// * `socket_path` - containerdのソケットパス
+    /// * `setup_commands` - イメージのセットアップコマンド（例: ["apt-get update", "apt-get install -y gcc"]）
     ///
     /// # Returns
-    /// 新しいDockerfileビルダーのインスタンス
+    /// 新しい公式イメージビルダーのインスタンス
     ///
-    /// # Panics
-    /// * Dockerfileのパスに親ディレクトリが存在しない場合
-    #[must_use]
-    pub fn new(dockerfile_path: PathBuf, context_path: Option<PathBuf>) -> Self {
-        let context_path = context_path.unwrap_or_else(|| {
-            dockerfile_path
-                .parent()
-                .expect("Dockerfileのパスには親ディレクトリが必要です")
-                .to_path_buf()
-        });
-        Self {
-            dockerfile_path,
-            context_path,
+    /// # Errors
+    /// * containerdクライアントの初期化に失敗した場合
+    pub async fn new(image_name: String, socket_path: &str, setup_commands: Vec<String>) -> Result<Self> {
+        let channel = containerd::connect(socket_path).await?;
+        Ok(Self {
+            image_name,
+            images: Arc::new(Mutex::new(ImagesClient::new(channel.clone()))),
+            containers: Arc::new(Mutex::new(ContainersClient::new(channel.clone()))),
+            tasks: Arc::new(Mutex::new(TasksClient::new(channel))),
+            setup_commands,
+        })
+    }
+
+    /// 一時的なコンテナを作成してコマンドを実行します
+    async fn run_setup_commands(&self, container_id: &str) -> Result<()> {
+        let mut tasks = self.tasks.lock().await;
+
+        for cmd in &self.setup_commands {
+            let args: Vec<&str> = cmd.split_whitespace().collect();
+            
+            // Execリクエストを作成
+            let request = containerd::services::v1::ExecProcessRequest {
+                container_id: container_id.to_string(),
+                exec_id: uuid::Uuid::new_v4().to_string(),
+                terminal: false,
+                stdin: vec![],
+                stdout: vec![],
+                stderr: vec![],
+                spec: Some(Any {
+                    type_url: "types.containerd.io/opencontainers/runtime-spec/1/Process".to_string(),
+                    value: serde_json::to_vec(&serde_json::json!({
+                        "args": args,
+                        "env": ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"],
+                        "cwd": "/",
+                    }))?,
+                }),
+            };
+
+            // コマンドを実行
+            let response = tasks.exec(request).await?;
+            let pid = response.into_inner().pid;
+
+            // コマンドの完了を待機
+            let request = containerd::services::v1::WaitRequest {
+                container_id: container_id.to_string(),
+                exec_id: String::new(),
+            };
+
+            let response = tasks.wait(request).await?;
+            let exit_status = response.into_inner().exit_status;
+
+            if exit_status != 0 {
+                return Err(anyhow!("Command failed with status: {}", exit_status));
+            }
+
+            // 短い待機時間を入れて、次のコマンドの実行に備える
+            sleep(Duration::from_millis(100)).await;
         }
+
+        Ok(())
     }
 }
 
 #[async_trait]
-impl ImageBuilder for DockerfileBuilder {
+impl ImageBuilder for OfficialImageBuilder {
     async fn build_image(&self, tag: &str) -> Result<()> {
-        let status = Command::new("docker")
-            .arg("build")
-            .arg("-t")
-            .arg(tag)
-            .arg("-f")
-            .arg(&self.dockerfile_path)
-            .arg(&self.context_path)
-            .status()
-            .await?;
-
-        if !status.success() {
-            anyhow::bail!("Failed to build image: {}", status);
+        let mut images = self.images.lock().await;
+        let mut containers = self.containers.lock().await;
+        
+        // イメージをプル
+        let request = containerd::services::v1::PullImageRequest {
+            image: self.image_name.clone(),
+            ..Default::default()
+        };
+
+        let response = images.pull(request).await?;
+        let image = response.into_inner().image
+            .ok_or_else(|| anyhow!("Failed to pull image"))?;
+
+        // セットアップコマンドがある場合、一時的なコンテナを作成して実行
+        if !self.setup_commands.is_empty() {
+            let container_id = uuid::Uuid::new_v4().to_string();
+
+            // 一時的なコンテナを作成
+            let request = containerd::services::v1::CreateContainerRequest {
+                container: Some(containerd::services::v1::Container {
+                    id: container_id.clone(),
+                    image: image.name.clone(),
+                    runtime: Some(containerd::services::v1::container::Runtime {
+                        name: "io.containerd.runc.v2".to_string(),
+                        options: None,
+                    }),
+                    spec: Some(Any {
+                        type_url: "types.containerd.io/opencontainers/runtime-spec/1/Spec".to_string(),
+                        value: serde_json::to_vec(&serde_json::json!({
+                            "ociVersion": "1.0.2",
+                            "process": {
+                                "terminal": false,
+                                "user": {
+                                    "uid": 0,
+                                    "gid": 0
+                                },
+                                "args": ["/bin/sh"],
+                                "env": ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"],
+                                "cwd": "/"
+                            },
+                            "root": {
+                                "path": "rootfs"
+                            },
+                            "linux": {
+                                "namespaces": [
+                                    { "type": "pid" },
+                                    { "type": "ipc" },
+                                    { "type": "uts" },
+                                    { "type": "mount" },
+                                    { "type": "network" }
+                                ]
+                            }
+                        }))?,
+                    }),
+                    ..Default::default()
+                }),
+            };
+
+            containers.create(request).await?;
+
+            // セットアップコマンドを実行
+            self.run_setup_commands(&container_id).await?;
+
+            // コンテナを削除
+            let request = containerd::services::v1::DeleteContainerRequest {
+                id: container_id,
+            };
+
+            containers.delete(request).await?;
         }
 
+        // イメージにタグを付ける
+        let request = containerd::services::v1::TagImageRequest {
+            name: image.name,
+            tag: tag.to_string(),
+        };
+
+        images.tag(request).await?;
+        Ok(())
+    }
+}
+
+pub struct TarImageBuilder {
+    tar_path: PathBuf,
+    images: Arc<Mutex<ImagesClient<tonic::transport::Channel>>>,
+    content: Arc<Mutex<ContentClient<tonic::transport::Channel>>>,
+}
+
+impl TarImageBuilder {
+    /// 新しいtarイメージビルダーを作成します。
+    ///
+    /// # Arguments
+    /// * `tar_path` - イメージのtarファイルのパス
+    /// * `socket_path` - containerdのソケットパス
+    ///
+    /// # Returns
+    /// 新しいtarイメージビルダーのインスタンス
+    ///
+    /// # Errors
+    /// * containerdクライアントの初期化に失敗した場合
+    pub async fn new(tar_path: PathBuf, socket_path: &str) -> Result<Self> {
+        let channel = containerd::connect(socket_path).await?;
+        Ok(Self {
+            tar_path,
+            images: Arc::new(Mutex::new(ImagesClient::new(channel.clone()))),
+            content: Arc::new(Mutex::new(ContentClient::new(channel))),
+        })
+    }
+}
+
+#[async_trait]
+impl ImageBuilder for TarImageBuilder {
+    async fn build_image(&self, tag: &str) -> Result<()> {
+        // tarファイルを読み込む
+        let mut file = File::open(&self.tar_path).await?;
+        let mut contents = Vec::new();
+        file.read_to_end(&mut contents).await?;
+
+        let mut content_client = self.content.lock().await;
+        let mut images_client = self.images.lock().await;
+
+        // イメージをインポート
+        let request = containerd::services::v1::ImportRequest {
+            ref_name: tag.to_string(),
+            data: contents,
+            ..Default::default()
+        };
+
+        content_client.import(request).await?;
         Ok(())
     }
 }
@@ -64,35 +239,54 @@ impl ImageBuilder for DockerfileBuilder {
 pub struct BuilderConfig {
     pub image_type: String,
     pub source: String,
+    pub setup_commands: Vec<String>,
 }
 
 impl BuilderConfig {
     /// 新しいビルダー設定を作成します。
     ///
     /// # Arguments
-    /// * `image_type` - イメージの種類
-    /// * `source` - ソースの場所
+    /// * `image_type` - イメージの種類 ("official" または "tar")
+    /// * `source` - イメージのソース（公式イメージ名またはtarファイルのパス）
+    /// * `setup_commands` - セットアップコマンド（省略可能）
     ///
     /// # Returns
     /// 新しいビルダー設定のインスタンス
     #[must_use]
-    pub const fn new(image_type: String, source: String) -> Self {
-        Self { image_type, source }
+    pub fn new(image_type: String, source: String, setup_commands: Vec<String>) -> Self {
+        Self {
+            image_type,
+            source,
+            setup_commands,
+        }
     }
 
     /// イメージビルダーを作成します。
     ///
+    /// # Arguments
+    /// * `socket_path` - containerdのソケットパス
+    ///
     /// # Returns
     /// * `Some(Box<dyn ImageBuilder>)` - イメージビルダーのインスタンス
     /// * `None` - イメージビルダーが不要な場合
-    #[must_use]
-    pub fn create_builder(&self) -> Option<Box<dyn ImageBuilder>> {
+    ///
+    /// # Errors
+    /// * containerdクライアントの初期化に失敗した場合
+    pub async fn create_builder(&self, socket_path: &str) -> Result<Option<Box<dyn ImageBuilder>>> {
         match self.image_type.as_str() {
-            "dockerfile" => Some(Box::new(DockerfileBuilder::new(
-                PathBuf::from(&self.source),
-                None,
-            ))),
-            _ => None,
+            "official" => {
+                let builder = OfficialImageBuilder::new(
+                    self.source.clone(),
+                    socket_path,
+                    self.setup_commands.clone(),
+                ).await?;
+                Ok(Some(Box::new(builder)))
+            },
+            "tar" => {
+                let builder = TarImageBuilder::new(PathBuf::from(&self.source), socket_path).await?;
+                Ok(Some(Box::new(builder)))
+            },
+            _ => Ok(None),
         }
     }
 } 
\ No newline at end of file
diff --git a/src/message/messages.rs b/src/message/messages.rs
index 91ff5e0..f6d7719 100644
--- a/src/message/messages.rs
+++ b/src/message/messages.rs
@@ -1,130 +1,135 @@
-use serde::Deserialize;
 use std::collections::HashMap;
-use once_cell::sync::Lazy;
-use super::Type;
-
-#[derive(Debug, Deserialize)]
-struct MessageCategory {
-    error: HashMap<String, String>,
-    warning: HashMap<String, String>,
-    hint: HashMap<String, String>,
+use lazy_static::lazy_static;
+use colored::*;
+
+#[derive(Debug, Clone, Copy)]
+pub enum Type {
+    Error,
+    Warning,
+    Hint,
 }
 
-#[derive(Debug, Deserialize)]
-struct Messages {
-    messages: HashMap<String, MessageCategory>,
-}
-
-static MESSAGES: Lazy<Messages> = Lazy::new(|| {
-    let yaml = include_str!("messages.yaml");
-    serde_yaml::from_str(yaml).expect("メッセージ定義の読み込みに失敗しました")
-});
-
-/// メッセージを取得します。
-/// 
-/// # Arguments
-/// * `category` - メッセージのカテゴリ（"fs", "docker", "contest", "common"）
-/// * `msg_type` - メッセージの種類（Error, Warning, Hint）
-/// * `key` - メッセージのキー
-/// 
-/// # Returns
-/// * `Option<&'static str>` - メッセージのテンプレート
-#[must_use]
-pub fn get(category: &str, msg_type: Type, key: &str) -> Option<&'static str> {
-    MESSAGES.messages.get(category).and_then(|cat| {
-        match msg_type {
-            Type::Error => cat.error.get(key),
-            Type::Warning => cat.warning.get(key),
-            Type::Hint => cat.hint.get(key),
-        }
-    }).map(String::as_str)
+lazy_static! {
+    static ref MESSAGES: HashMap<&'static str, HashMap<&'static str, &'static str>> = {
+        let mut m = HashMap::new();
+        
+        // ファイルシステム関連のメッセージ
+        let mut fs = HashMap::new();
+        fs.insert("file_not_found", "ファイルが見つかりません: {}");
+        fs.insert("dir_not_found", "ディレクトリが見つかりません: {}");
+        fs.insert("permission_denied", "アクセス権限がありません: {}");
+        m.insert("fs", fs);
+
+        // コンテナ関連のメッセージ
+        let mut container = HashMap::new();
+        container.insert("image_not_found", "イメージが見つかりません: {}");
+        container.insert("container_error", "コンテナの操作に失敗しました: {}");
+        container.insert("runtime_error", "ランタイムエラーが発生しました: {}");
+        m.insert("container", container);
+
+        // コンテスト関連のメッセージ
+        let mut contest = HashMap::new();
+        contest.insert("not_found", "コンテストが見つかりません: {}");
+        contest.insert("invalid_format", "コンテスト形式が無効です: {}");
+        m.insert("contest", contest);
+
+        // 共通メッセージ
+        let mut common = HashMap::new();
+        common.insert("unknown_error", "不明なエラーが発生しました: {}");
+        common.insert("invalid_argument", "無効な引数です: {}");
+        m.insert("common", common);
+
+        m
+    };
 }
 
 /// メッセージをフォーマットします。
-/// 
+///
 /// # Arguments
-/// * `category` - メッセージのカテゴリ
-/// * `msg_type` - メッセージの種類
+/// * `category` - メッセージのカテゴリ（"fs", "container", "contest", "common"）
+/// * `type_` - メッセージの種類
 /// * `key` - メッセージのキー
 /// * `args` - フォーマット引数
-/// 
+///
 /// # Returns
-/// * `String` - フォーマットされたメッセージ
-/// 
-/// # Panics
-/// * メッセージが見つからない場合
-pub fn format<D: std::fmt::Display>(
-    category: &str,
-    msg_type: Type,
-    key: &str,
-    args: D,
-) -> String {
-    let template = get(category, msg_type, key)
-        .unwrap_or_else(|| panic!("メッセージが見つかりません: {category}/{msg_type:?}/{key}"));
-    template.replace("{}", &args.to_string())
+/// フォーマットされたメッセージ
+fn format(category: &str, type_: Type, key: &str, args: &[&str]) -> String {
+    let messages = MESSAGES.get(category).unwrap_or_else(|| MESSAGES.get("common").unwrap());
+    let template = messages.get(key).unwrap_or_else(|| messages.get("unknown_error").unwrap());
+    
+    let formatted = if args.is_empty() {
+        template.to_string()
+    } else {
+        template.replace("{}", args[0])
+    };
+
+    match type_ {
+        Type::Error => formatted.red().to_string(),
+        Type::Warning => formatted.yellow().to_string(),
+        Type::Hint => formatted.cyan().to_string(),
+    }
 }
 
-// 利便性のために各カテゴリのモジュールを提供
 pub mod fs {
-    use super::{Type, format};
+    use super::{format, Type};
 
-    pub fn error<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn error(key: &str, args: &[&str]) -> String {
         format("fs", Type::Error, key, args)
     }
 
-    pub fn warning<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn warning(key: &str, args: &[&str]) -> String {
         format("fs", Type::Warning, key, args)
     }
 
-    pub fn hint<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn hint(key: &str, args: &[&str]) -> String {
         format("fs", Type::Hint, key, args)
     }
 }
 
-pub mod docker {
-    use super::{Type, format};
+pub mod container {
+    use super::{format, Type};
 
-    pub fn error<D: std::fmt::Display>(key: &str, args: D) -> String {
-        format("docker", Type::Error, key, args)
+    pub fn error(key: &str, args: &[&str]) -> String {
+        format("container", Type::Error, key, args)
     }
 
-    pub fn warning<D: std::fmt::Display>(key: &str, args: D) -> String {
-        format("docker", Type::Warning, key, args)
+    pub fn warning(key: &str, args: &[&str]) -> String {
+        format("container", Type::Warning, key, args)
     }
 
-    pub fn hint<D: std::fmt::Display>(key: &str, args: D) -> String {
-        format("docker", Type::Hint, key, args)
+    pub fn hint(key: &str, args: &[&str]) -> String {
+        format("container", Type::Hint, key, args)
     }
 }
 
 pub mod contest {
-    use super::{Type, format};
+    use super::{format, Type};
 
-    pub fn error<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn error(key: &str, args: &[&str]) -> String {
         format("contest", Type::Error, key, args)
     }
 
-    pub fn warning<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn warning(key: &str, args: &[&str]) -> String {
         format("contest", Type::Warning, key, args)
     }
 
-    pub fn hint<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn hint(key: &str, args: &[&str]) -> String {
         format("contest", Type::Hint, key, args)
     }
 }
 
 pub mod common {
-    use super::{Type, format};
+    use super::{format, Type};
 
-    pub fn error<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn error(key: &str, args: &[&str]) -> String {
         format("common", Type::Error, key, args)
     }
 
-    pub fn warning<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn warning(key: &str, args: &[&str]) -> String {
         format("common", Type::Warning, key, args)
     }
 
-    pub fn hint<D: std::fmt::Display>(key: &str, args: D) -> String {
+    pub fn hint(key: &str, args: &[&str]) -> String {
         format("common", Type::Hint, key, args)
     }
 } 
\ No newline at end of file
diff --git a/src/message/mod.rs b/src/message/mod.rs
index 3e9f785..60dc427 100644
--- a/src/message/mod.rs
+++ b/src/message/mod.rs
@@ -9,4 +9,4 @@ pub enum Type {
 }
 
 pub use messages::{get, format};
-pub use messages::{fs, docker, contest, common}; 
\ No newline at end of file
+pub use messages::{fs, container, contest, common}; 
\ No newline at end of file
diff --git a/src/oj/mod.rs b/src/oj/mod.rs
index 570e718..4636b77 100644
--- a/src/oj/mod.rs
+++ b/src/oj/mod.rs
@@ -1,293 +1,107 @@
-use crate::error::Result;
 use std::path::PathBuf;
-use colored::*;
-use std::process::Command;
-use std::env;
-use users;
-use std::os::unix::fs::PermissionsExt;
-use dirs;
-use crate::config::Config;
+use anyhow::Result;
+use colored::Colorize;
+use tokio::process::Command;
+use containerd_client as containerd;
+use containerd_client::services::v1::images_client::ImagesClient;
+use containerd_client::services::v1::containers_client::ContainersClient;
+use std::sync::Arc;
+use tokio::sync::Mutex;
 
 const COOKIE_DIR: &str = ".local/share/online-judge-tools";
 const COOKIE_FILE: &str = "cookie.jar";
-const DOCKERFILE_PATH: &str = "src/oj/Dockerfile";
-const DOCKER_IMAGE_NAME: &str = "oj-container";
+const CONTAINER_IMAGE_NAME: &str = "oj-container";
+const ERROR_CONTAINER_IMAGE_NOT_FOUND: &str = "コンテナイメージが見つかりません。'cargo run -- atcoder login'を実行してログインしてください。";
 
-// エラーメッセージ
-const ERROR_DOCKER_IMAGE_NOT_FOUND: &str = "Dockerイメージが見つかりません。'cargo run -- atcoder login'を実行してログインしてください。";
-const ERROR_DOCKERFILE_NOT_FOUND: &str = "Dockerfile not found";
-
-pub fn open_in_cursor(url: &str, source_path: Option<&PathBuf>) -> Result<()> {
-    // 問題ページを開く
-    if let Ok(browser) = env::var("BROWSER") {
-        Command::new(&browser)
-            .arg(url)
-            .output()?;
-    } else {
-        println!("{}", format!("Note: To automatically open URLs, please set the $BROWSER environment variable.").yellow());
-    }
-    
-    if let Some(path) = source_path {
-        if let Err(e) = Command::new("code").arg(path.display().to_string()).output() {
-            println!("Note: Failed to open in VSCode: {}", e);
-        }
-
-        if let Err(e) = Command::new("cursor").arg(path.display().to_string()).output() {
-            println!("Note: Failed to open in Cursor: {}", e);
-        }
-    }
-
-    Ok(())
-}
-
-#[derive(Debug, Clone)]
-pub struct ProblemInfo {
-    pub url: String,
-    pub source_path: PathBuf,
-    pub problem_id: String,
+pub struct OnlineJudge {
+    images: Arc<Mutex<ImagesClient<tonic::transport::Channel>>>,
+    containers: Arc<Mutex<ContainersClient<tonic::transport::Channel>>>,
 }
 
-pub struct OJContainer {
-    workspace_path: PathBuf,
-    site_name: String,
-    config: Config,
-}
-
-impl OJContainer {
-    pub fn new(workspace_path: PathBuf, site_name: String) -> Result<Self> {
-        let config = Config::load()
-            .map_err(|e| format!("設定の読み込みに失敗しました: {}", e))?;
-        Ok(Self { workspace_path, site_name, config })
+impl OnlineJudge {
+    pub async fn new(socket_path: &str) -> Result<Self> {
+        let channel = containerd::connect(socket_path).await?;
+        Ok(Self {
+            images: Arc::new(Mutex::new(ImagesClient::new(channel.clone()))),
+            containers: Arc::new(Mutex::new(ContainersClient::new(channel))),
+        })
     }
 
-    fn get_dockerfile_path() -> PathBuf {
-        PathBuf::from(DOCKERFILE_PATH)
-    }
-
-    fn check_dockerfile_exists() -> Result<()> {
-        if !Self::get_dockerfile_path().exists() {
-            println!("{}", "Error: Dockerfile not found".red());
-            return Err(ERROR_DOCKERFILE_NOT_FOUND.into());
-        }
-        Ok(())
-    }
-
-    fn get_cookie_paths() -> Result<(PathBuf, PathBuf)> {
-        let home_dir = dirs::home_dir().ok_or("Failed to get home directory")?;
-        let cookie_dir = home_dir.join(COOKIE_DIR);
-        let cookie_path = cookie_dir.join(COOKIE_FILE);
-        Ok((cookie_dir, cookie_path))
-    }
+    async fn run_command(&self, args: &[&str]) -> Result<()> {
+        let container_id = uuid::Uuid::new_v4().to_string();
+        
+        // コンテナを作成
+        let request = containerd::services::v1::CreateContainerRequest {
+            container: Some(containerd::services::v1::Container {
+                id: container_id.clone(),
+                image: CONTAINER_IMAGE_NAME.to_string(),
+                runtime: Some(containerd::services::v1::container::Runtime {
+                    name: "io.containerd.runc.v2".to_string(),
+                    options: None,
+                }),
+                ..Default::default()
+            }),
+        };
+
+        let mut containers = self.containers.lock().await;
+        containers.create(request).await?;
+
+        // コンテナを起動
+        let request = containerd::services::v1::StartRequest {
+            container_id: container_id.clone(),
+            exec_id: String::new(),
+        };
+
+        containers.start(request).await?;
+
+        // コンテナを削除
+        let request = containerd::services::v1::DeleteContainerRequest {
+            id: container_id,
+        };
+
+        containers.delete(request).await?;
 
-    fn setup_cookie_file(cookie_dir: &PathBuf, cookie_path: &PathBuf) -> Result<()> {
-        std::fs::create_dir_all(cookie_dir)?;
-        std::fs::write(cookie_path, "#LWP-Cookies-2.0\n")?;
-        std::fs::set_permissions(cookie_path, std::fs::Permissions::from_mode(0o600))?;
         Ok(())
     }
 
-    async fn run_oj_command(&self, args: &[&str], mount_workspace: bool) -> Result<()> {
-        let (_cookie_dir, cookie_path) = Self::get_cookie_paths()?;
-        let mut command = Command::new("docker");
-
-        // 基本的なdockerコマンドを構築
-        let is_login = args.get(0).map_or(false, |&cmd| cmd == "login");
-        if is_login {
-            command.args(["run", "--rm", "-it"]);
-        } else {
-            command.args(["run", "--rm"]);
-        }
+    async fn check_image_exists(&self) -> Result<bool> {
+        let request = containerd::services::v1::ListImagesRequest::default();
+        let response = self.images.lock().await.list(request).await?;
         
-        // ユーザーIDとグループIDを設定
-        let uid = users::get_current_uid();
-        let gid = users::get_current_gid();
-        command.args(["-u", &format!("{}:{}", uid, gid)]);
-
-        // 環境変数を設定
-        command.args(["-e", &format!("HOME=/home/oj-user")]);
-
-        // cookieファイルをコンテナ内の期待されるパスにマウント
-        command.args(["-v", &format!("{}:/home/oj-user/{}/{}", cookie_path.display(), COOKIE_DIR, COOKIE_FILE)]);
-
-        // ワークスペースのマウントが必要な場合
-        if mount_workspace {
-            let workspace_mount = format!("{}:/workspace", self.workspace_path.display());
-            command.args(["-v", &workspace_mount, "-w", "/workspace"]);
-        }
-
-        // OJコマンドを実行
-        let status = command
-            .args([DOCKER_IMAGE_NAME, "oj"])
-            .args(args)
-            .status()?;
-
-        if !status.success() {
-            return Err(format!("Command failed with status: {}", status).into());
-        }
-
-        Ok(())
+        Ok(response.into_inner().images.iter().any(|image| {
+            image.name == CONTAINER_IMAGE_NAME
+        }))
     }
 
-    async fn check_image_exists(&self) -> Result<()> {
-        let output = Command::new("docker")
-            .args(["images", "-q", DOCKER_IMAGE_NAME])
-            .output()?;
-
-        if output.stdout.is_empty() {
-            return Err(ERROR_DOCKER_IMAGE_NOT_FOUND.into());
+    pub async fn login(&self, username: &str, password: &str) -> Result<()> {
+        if !self.check_image_exists().await? {
+            return Err(ERROR_CONTAINER_IMAGE_NOT_FOUND.into());
         }
 
-        Ok(())
+        self.run_command(&["login", "-u", username, "-p", password, "https://atcoder.jp/"]).await
     }
 
-    pub async fn ensure_image(&self) -> Result<()> {
-        Self::check_dockerfile_exists()?;
-        println!("{}", "Building OJ container image...".cyan());
-
-        let status = Command::new("docker")
-            .args(["build", "-t", DOCKER_IMAGE_NAME, "-f", DOCKERFILE_PATH, "src/oj"])
-            .status()?;
-
-        if !status.success() {
-            return Err("Failed to build docker image".into());
+    pub async fn submit(&self, contest: &str, problem: &str, file: &str) -> Result<()> {
+        if !self.check_image_exists().await? {
+            return Err(ERROR_CONTAINER_IMAGE_NOT_FOUND.into());
         }
 
-        Ok(())
+        self.run_command(&["submit", "-w", "0", &format!("https://atcoder.jp/contests/{}/tasks/{}_{}", contest, contest, problem), file]).await
     }
 
-    pub async fn login(&self) -> Result<()> {
-        // サイトのURLを取得
-        let url = self.config.get::<String>(&format!("sites.{}.url", self.site_name))?;
-        let name = self.config.get::<String>(&format!("sites.{}.name", self.site_name))?;
-
-        println!("{}", format!("Logging in to {}...", name).cyan());
-
-        // cookieファイルをリセット
-        println!("{}", "Resetting cookie file...".cyan());
-        let (cookie_dir, cookie_path) = Self::get_cookie_paths()?;
-
-        // cookieファイルが存在する場合は削除
-        if cookie_path.exists() {
-            std::fs::remove_file(&cookie_path)?;
+    pub async fn test(&self, contest: &str, problem: &str, file: &str) -> Result<()> {
+        if !self.check_image_exists().await? {
+            return Err(ERROR_CONTAINER_IMAGE_NOT_FOUND.into());
         }
 
-        // cookieファイルを作成
-        Self::setup_cookie_file(&cookie_dir, &cookie_path)?;
-
-        // Dockerイメージを再ビルド
-        println!("{}", "Rebuilding Docker image...".cyan());
-        Self::check_dockerfile_exists()?;
-
-        let status = Command::new("docker")
-            .args(["build", "--no-cache", "-t", DOCKER_IMAGE_NAME, "-f", DOCKERFILE_PATH, "src/oj"])
-            .status()?;
-
-        if !status.success() {
-            return Err("Failed to build docker image".into());
-        }
-
-        // ログインを実行
-        self.run_oj_command(&["login", &url], false).await?;
-
-        println!("{}", format!("Successfully logged in to {}", name).green());
-        Ok(())
+        self.run_command(&["test", "-c", &format!("python {}", file), &format!("https://atcoder.jp/contests/{}/tasks/{}_{}", contest, contest, problem)]).await
     }
 
-    pub async fn open(&self, problem: ProblemInfo) -> Result<()> {
-        println!("{}", format!("Opening problem URL: {}", problem.url).cyan());
-
-        // ブラウザ設定を確認
-        let browser = self.config.get::<String>("system.browser")
-            .or_else(|_| env::var("BROWSER"))
-            .unwrap_or_else(|_| {
-                println!("{}", format!("Note: To automatically open URLs, please set the $BROWSER environment variable or configure system.browser in config.yaml").yellow());
-                String::new()
-            });
-
-        if !browser.is_empty() {
-            if let Err(e) = Command::new(&browser).arg(&problem.url).output() {
-                println!("Note: Failed to open in browser: {}", e);
-            }
+    pub async fn download(&self, contest: &str, problem: &str) -> Result<()> {
+        if !self.check_image_exists().await? {
+            return Err(ERROR_CONTAINER_IMAGE_NOT_FOUND.into());
         }
 
-        // エディタ設定を取得
-        let editors = self.config.get::<Vec<String>>("system.editors")
-            .unwrap_or_else(|_| vec!["code".to_string(), "cursor".to_string()]);
-
-        // 各エディタで開く
-        for editor in editors {
-            if let Some(source_path) = problem.source_path.to_str() {
-                if let Err(e) = Command::new(&editor).arg(source_path).output() {
-                    println!("Note: Failed to open in {}: {}", editor, e);
-                }
-            }
-        }
-
-        // Dockerイメージの存在確認
-        self.check_image_exists().await?;
-
-        // 問題ディレクトリのパスを取得
-        let problem_dir = problem.source_path.parent()
-            .ok_or_else(|| "Invalid problem path".to_string())?;
-
-        // 問題ディレクトリを基準にコマンドを実行
-        let relative_problem_dir = problem_dir.strip_prefix(&self.workspace_path)
-            .map_err(|_| "Failed to get relative problem path")?;
-
-        // テストディレクトリを設定から取得
-        let test_dir = self.config.get::<String>("system.test.directory")
-            .unwrap_or_else(|_| "test".to_string());
-
-        self.run_oj_command(&[
-            "download",
-            "-d", &format!("{}/{}", relative_problem_dir.display(), test_dir),
-            &problem.url,
-        ], true).await?;
-
-        println!("{}", "Problem setup completed".green());
-        Ok(())
-    }
-
-    pub async fn submit(&self, problem: &ProblemInfo, language_id: &str) -> Result<()> {
-        // Dockerイメージの存在確認
-        self.check_image_exists().await?;
-
-        // 提出コマンドを実行
-        println!("{}", format!("Submitting solution for problem {}...", problem.problem_id).cyan());
-
-        self.run_oj_command(&[
-            "submit",
-            "-l", language_id,
-            "-y",  // 確認をスキップ
-            &problem.url,
-            &problem.source_path.to_string_lossy(),
-        ], true).await?;
-
-        println!("{}", "Solution submitted successfully".green());
-        Ok(())
+        self.run_command(&["download", &format!("https://atcoder.jp/contests/{}/tasks/{}_{}", contest, contest, problem)]).await
     }
-}
-
-pub fn has_test_cases(dir: &PathBuf) -> Result<bool> {
-    if !dir.exists() {
-        return Ok(false);
-    }
-
-    let entries = std::fs::read_dir(dir)?;
-    let mut has_input = false;
-    let mut has_output = false;
-
-    for entry in entries {
-        let entry = entry?;
-        let path = entry.path();
-        if let Some(extension) = path.extension() {
-            if extension == "in" {
-                has_input = true;
-            } else if extension == "out" {
-                has_output = true;
-            }
-        }
-    }
-
-    Ok(has_input && has_output)
 } 
\ No newline at end of file
