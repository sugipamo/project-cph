=== Project Structure ===
.
├── agent
│   ├── commit.do
│   ├── diff-review.do
│   ├── feature.do
│   ├── fix-errors.do
│   ├── refactor.do
│   └── test.do
├── Cargo.lock
├── Cargo.toml
├── contest_template
│   ├── cpp
│   │   ├── generator.cpp
│   │   ├── solution.cpp
│   │   └── tester.cpp
│   ├── pypy
│   │   ├── generator.py
│   │   ├── solution.py
│   │   └── tester.py
│   └── rust
│       ├── Cargo.toml
│       └── src
│           ├── generator.rs
│           ├── solution.rs
│           └── tester.rs
├── diff.txt
├── docs
│   ├── configuration.md
│   ├── development.md
│   ├── installation.md
│   └── usage.md
├── LICENSE
├── README.md
├── src
│   ├── bin
│   │   └── cph.rs
│   ├── config
│   │   ├── config.yaml
│   │   └── mod.rs
│   ├── contest
│   │   ├── commands.yaml
│   │   ├── error.rs
│   │   ├── model
│   │   │   ├── mod.rs
│   │   │   └── state.rs
│   │   ├── mod.rs
│   │   ├── parse.rs
│   │   └── service
│   │       ├── contest.rs
│   │       ├── mod.rs
│   │       ├── path.rs
│   │       ├── test.rs
│   │       └── url.rs
│   ├── docker
│   │   ├── config.rs
│   │   ├── error.rs
│   │   ├── execution
│   │   │   ├── command.rs
│   │   │   ├── compilation.rs
│   │   │   ├── container.rs
│   │   │   └── mod.rs
│   │   ├── fs.rs
│   │   ├── mod.rs
│   │   ├── state
│   │   │   ├── manager.rs
│   │   │   ├── mod.rs
│   │   │   └── types.rs
│   │   ├── test_helpers
│   │   │   └── mod.rs
│   │   └── traits
│   │       ├── compilation.rs
│   │       ├── container.rs
│   │       ├── mod.rs
│   │       └── operations.rs
│   ├── error
│   │   ├── config.rs
│   │   ├── contest.rs
│   │   ├── docker.rs
│   │   ├── fs.rs
│   │   ├── helpers.rs
│   │   ├── macros.rs
│   │   └── mod.rs
│   ├── fs
│   │   ├── backup.rs
│   │   ├── docker.rs
│   │   ├── error
│   │   │   ├── helpers.rs
│   │   │   └── kind.rs
│   │   ├── error.rs
│   │   ├── manager.rs
│   │   ├── mod.rs
│   │   ├── operations.rs
│   │   └── transaction.rs
│   ├── language
│   │   └── mod.rs
│   ├── lib.rs
│   ├── main.rs
│   ├── oj
│   │   ├── Dockerfile
│   │   └── mod.rs
│   └── test
│       └── mod.rs
├── target
│   ├── CACHEDIR.TAG
│   └── debug
│       ├── build
│       │   ├── libc-7f8b8ac7a739be42
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── libc-c7ed61892fd7b18f
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-c7ed61892fd7b18f
│       │   │   └── build_script_build-c7ed61892fd7b18f.d
│       │   ├── lock_api-266d0879f4b96f3a
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-266d0879f4b96f3a
│       │   │   └── build_script_build-266d0879f4b96f3a.d
│       │   ├── lock_api-4522f87fdceb03e4
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   │   └── autocfg_2180ea64ed4b29e7_0.ll
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── num-traits-251544501ada282d
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   │   ├── autocfg_d3ed13c589b9d97f_0.ll
│       │   │   │   └── autocfg_d3ed13c589b9d97f_1.ll
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── num-traits-f748bf632aebaf67
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-f748bf632aebaf67
│       │   │   └── build_script_build-f748bf632aebaf67.d
│       │   ├── parking_lot_core-275a9599d5badc27
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-275a9599d5badc27
│       │   │   └── build_script_build-275a9599d5badc27.d
│       │   ├── parking_lot_core-38d3111bb883d3c2
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── proc-macro2-1be6258861b9bf85
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-1be6258861b9bf85
│       │   │   └── build_script_build-1be6258861b9bf85.d
│       │   ├── proc-macro2-8cb02808c8eea528
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── rustix-74dc217bb9e382ea
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── rustix-95a73f36ae631610
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-95a73f36ae631610
│       │   │   └── build_script_build-95a73f36ae631610.d
│       │   ├── serde-59bc6ea1fdf54be6
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── serde-c8ba9f73ef92751f
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-c8ba9f73ef92751f
│       │   │   └── build_script_build-c8ba9f73ef92751f.d
│       │   ├── serde_json-7f48ef6b1be6411e
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── serde_json-e672c04e8b22240d
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-e672c04e8b22240d
│       │   │   └── build_script_build-e672c04e8b22240d.d
│       │   ├── slab-b9b2712f4550c533
│       │   │   ├── build-script-build
│       │   │   ├── build_script_build-b9b2712f4550c533
│       │   │   └── build_script_build-b9b2712f4550c533.d
│       │   ├── slab-c6244bc502f9d6e7
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   │   └── autocfg_8e1004529490d5c5_0.ll
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   ├── thiserror-28941f0e817feef2
│       │   │   ├── invoked.timestamp
│       │   │   ├── out
│       │   │   ├── output
│       │   │   ├── root-output
│       │   │   └── stderr
│       │   └── thiserror-40f811ca39870f46
│       │       ├── build-script-build
│       │       ├── build_script_build-40f811ca39870f46
│       │       └── build_script_build-40f811ca39870f46.d
│       ├── deps
│       │   ├── aho_corasick-67cb4e75c0b4aa9f.d
│       │   ├── anstream-49f2b87b93c201ad.d
│       │   ├── anstyle-874372973aa162b0.d
│       │   ├── anstyle_parse-0d0717b7c26488d6.d
│       │   ├── anstyle_query-27eb6e0e19856df6.d
│       │   ├── async_trait-16bf466bd726f6e6.d
│       │   ├── autocfg-fa673ec83f7410be.d
│       │   ├── bitflags-579c065d70004b46.d
│       │   ├── bytes-6c2a0d0582518189.d
│       │   ├── cfg_if-db0744cc5a653062.d
│       │   ├── cfg_if-f1126d5e99956cbe.d
│       │   ├── chrono-1caf559d8d411cea.d
│       │   ├── clap-058f140dfd5bc174.d
│       │   ├── clap_builder-64ca891405f90d5f.d
│       │   ├── clap_derive-20b6f3aa13dca0ef.d
│       │   ├── clap_lex-1525ea278d57e660.d
│       │   ├── colorchoice-efe230f74b470966.d
│       │   ├── colored-1ccb70d0863e3bb1.d
│       │   ├── cph-52d195026bf387e8.d
│       │   ├── cph-b7e4e5b87169bd99.d
│       │   ├── dirs-b193d206e1e28034.d
│       │   ├── dirs_sys-af60f93152677ecf.d
│       │   ├── downcast-db07890908926c0c.d
│       │   ├── either-4ee7a4567f6081fe.d
│       │   ├── equivalent-52f682e8b26e70ee.d
│       │   ├── fastrand-0061ba45e73f5bd9.d
│       │   ├── filetime-4db287f0fc212b6b.d
│       │   ├── fragile-2056ab41576554c4.d
│       │   ├── fs_extra-d141ac97b9a17a1e.d
│       │   ├── futures_channel-5a177c45792a7bc9.d
│       │   ├── futures_core-f66a89286ecb7371.d
│       │   ├── futures-d22ab025a7ba25dd.d
│       │   ├── futures_executor-b25437e5a655f070.d
│       │   ├── futures_io-4632baef9c03826f.d
│       │   ├── futures_macro-956d5dd01c47e57f.d
│       │   ├── futures_sink-f71d6b5bf7f02d65.d
│       │   ├── futures_task-ece576114b68d4f0.d
│       │   ├── futures_util-2f560af8dcfa7462.d
│       │   ├── getrandom-2429ffd34c9481c8.d
│       │   ├── hashbrown-1f9e8f1537e3e4b0.d
│       │   ├── heck-0fc17a4055c71d47.d
│       │   ├── iana_time_zone-dd92d7b79fe0afa6.d
│       │   ├── indexmap-9cac38425deb1fb7.d
│       │   ├── is_docker-396f4c8ddac7c789.d
│       │   ├── is_terminal_polyfill-8f031649b1f2862c.d
│       │   ├── is_wsl-8c764ca897e64eda.d
│       │   ├── itertools-b3817ab8004dd89f.d
│       │   ├── itoa-31c2c96bd7533630.d
│       │   ├── lazy_static-13c51dac3e3f39c1.d
│       │   ├── libaho_corasick-67cb4e75c0b4aa9f.rmeta
│       │   ├── libanstream-49f2b87b93c201ad.rmeta
│       │   ├── libanstyle-874372973aa162b0.rmeta
│       │   ├── libanstyle_parse-0d0717b7c26488d6.rmeta
│       │   ├── libanstyle_query-27eb6e0e19856df6.rmeta
│       │   ├── libasync_trait-16bf466bd726f6e6.so
│       │   ├── libautocfg-fa673ec83f7410be.rlib
│       │   ├── libautocfg-fa673ec83f7410be.rmeta
│       │   ├── libbitflags-579c065d70004b46.rmeta
│       │   ├── libbytes-6c2a0d0582518189.rmeta
│       │   ├── libc-fe1bec7a19b43783.d
│       │   ├── libcfg_if-db0744cc5a653062.rlib
│       │   ├── libcfg_if-db0744cc5a653062.rmeta
│       │   ├── libcfg_if-f1126d5e99956cbe.rmeta
│       │   ├── libchrono-1caf559d8d411cea.rmeta
│       │   ├── libclap-058f140dfd5bc174.rmeta
│       │   ├── libclap_builder-64ca891405f90d5f.rmeta
│       │   ├── libclap_derive-20b6f3aa13dca0ef.so
│       │   ├── libclap_lex-1525ea278d57e660.rmeta
│       │   ├── libcolorchoice-efe230f74b470966.rmeta
│       │   ├── libcolored-1ccb70d0863e3bb1.rmeta
│       │   ├── libcph-52d195026bf387e8.rmeta
│       │   ├── libcph-b7e4e5b87169bd99.rmeta
│       │   ├── libdirs-b193d206e1e28034.rmeta
│       │   ├── libdirs_sys-af60f93152677ecf.rmeta
│       │   ├── libdowncast-db07890908926c0c.rmeta
│       │   ├── libeither-4ee7a4567f6081fe.rmeta
│       │   ├── libequivalent-52f682e8b26e70ee.rmeta
│       │   ├── libfastrand-0061ba45e73f5bd9.rmeta
│       │   ├── libfiletime-4db287f0fc212b6b.rmeta
│       │   ├── libfragile-2056ab41576554c4.rmeta
│       │   ├── libfs_extra-d141ac97b9a17a1e.rmeta
│       │   ├── libfutures_channel-5a177c45792a7bc9.rmeta
│       │   ├── libfutures_core-f66a89286ecb7371.rmeta
│       │   ├── libfutures-d22ab025a7ba25dd.rmeta
│       │   ├── libfutures_executor-b25437e5a655f070.rmeta
│       │   ├── libfutures_io-4632baef9c03826f.rmeta
│       │   ├── libfutures_macro-956d5dd01c47e57f.so
│       │   ├── libfutures_sink-f71d6b5bf7f02d65.rmeta
│       │   ├── libfutures_task-ece576114b68d4f0.rmeta
│       │   ├── libfutures_util-2f560af8dcfa7462.rmeta
│       │   ├── libgetrandom-2429ffd34c9481c8.rmeta
│       │   ├── libhashbrown-1f9e8f1537e3e4b0.rmeta
│       │   ├── libheck-0fc17a4055c71d47.rlib
│       │   ├── libheck-0fc17a4055c71d47.rmeta
│       │   ├── libiana_time_zone-dd92d7b79fe0afa6.rmeta
│       │   ├── libindexmap-9cac38425deb1fb7.rmeta
│       │   ├── libis_docker-396f4c8ddac7c789.rmeta
│       │   ├── libis_terminal_polyfill-8f031649b1f2862c.rmeta
│       │   ├── libis_wsl-8c764ca897e64eda.rmeta
│       │   ├── libitertools-b3817ab8004dd89f.rmeta
│       │   ├── libitoa-31c2c96bd7533630.rmeta
│       │   ├── liblazy_static-13c51dac3e3f39c1.rmeta
│       │   ├── liblibc-fe1bec7a19b43783.rmeta
│       │   ├── liblinux_raw_sys-73b9062c952413b1.rmeta
│       │   ├── liblock_api-5d156468aadc6305.rmeta
│       │   ├── liblog-6cd4629aa2b17585.rmeta
│       │   ├── libmemchr-5dc2f2fbe59b86ae.rmeta
│       │   ├── libmio-deba033cccc3facf.rmeta
│       │   ├── libmockall-7629eaa388ce295b.rmeta
│       │   ├── libmockall_derive-6e01deed3a52c3d9.so
│       │   ├── libnix-1bd868b90df78989.rmeta
│       │   ├── libnum_traits-b5fb7a10fea4e865.rmeta
│       │   ├── libonce_cell-d5812127dbf95fda.rmeta
│       │   ├── libopen-9350816b22aab171.rmeta
│       │   ├── liboption_ext-6f7fa96f25d92544.rmeta
│       │   ├── libparking_lot-47eec5e13488891d.rmeta
│       │   ├── libparking_lot_core-1c2f926f842b8b50.rmeta
│       │   ├── libpathdiff-803e8bb907f8ab4e.rmeta
│       │   ├── libpin_project_lite-b9d1796c473ec11b.rmeta
│       │   ├── libpin_utils-ea6a80c5a52cb427.rmeta
│       │   ├── libpredicates-b4dd57729913647f.rmeta
│       │   ├── libpredicates_core-4a972ed15ee05eb7.rmeta
│       │   ├── libpredicates_tree-29b69f074dd2de86.rmeta
│       │   ├── libproc_macro2-85ee1178db9d334e.rlib
│       │   ├── libproc_macro2-85ee1178db9d334e.rmeta
│       │   ├── libproconio-3ed4a44fe4bc50d4.rmeta
│       │   ├── libquote-24e4c4ad8087851c.rlib
│       │   ├── libquote-24e4c4ad8087851c.rmeta
│       │   ├── libregex-827182a0ba8074ce.rmeta
│       │   ├── libregex_automata-c5b3c9e7012ddb9f.rmeta
│       │   ├── libregex_syntax-8d7baa200d762905.rmeta
│       │   ├── librpassword-15e53038bdb27e18.rmeta
│       │   ├── librtoolbox-15525837a648eeb4.rmeta
│       │   ├── librustix-9adc52868c87c7a1.rmeta
│       │   ├── libryu-5f32db5f3caaa50c.rmeta
│       │   ├── libscopeguard-6959bebfd559c22f.rmeta
│       │   ├── libserde-c8df369d193609ec.rmeta
│       │   ├── libserde_derive-510fc85a7674ae50.so
│       │   ├── libserde_json-74f17f7969cfc8b1.rmeta
│       │   ├── libserde_yaml-bd11247655c7415c.rmeta
│       │   ├── libsignal_hook_registry-f06782ab9899fe44.rmeta
│       │   ├── libslab-0a9a1578932bac2c.rmeta
│       │   ├── libsmallvec-b9156fd417ed1f6b.rmeta
│       │   ├── libsocket2-beff616ac680c0a7.rmeta
│       │   ├── libstrsim-f2e39a63b5377e46.rmeta
│       │   ├── libsyn-e62a01da217c3cd5.rlib
│       │   ├── libsyn-e62a01da217c3cd5.rmeta
│       │   ├── libtar-8c5c07ad440a6633.rmeta
│       │   ├── libtempfile-cd0b405da8986ab9.rmeta
│       │   ├── libtermtree-c72ab1b1e0ad1803.rmeta
│       │   ├── libthiserror-3ce04a1e83c84ffc.rmeta
│       │   ├── libthiserror_impl-cad109f874fb6f84.so
│       │   ├── libtokio-60d39fe2ef8c41e9.rmeta
│       │   ├── libtokio_macros-3685a7acebc11479.so
│       │   ├── libunicode_ident-f7f10e726d017c79.rlib
│       │   ├── libunicode_ident-f7f10e726d017c79.rmeta
│       │   ├── libunsafe_libyaml-7381adfd2f251def.rmeta
│       │   ├── libusers-a4372465a2b3f9c7.rmeta
│       │   ├── libutf8parse-fd79f0fb0f127bde.rmeta
│       │   ├── libuuid-2f21b4bd3e7f91b9.rmeta
│       │   ├── libxattr-603e9a39274f8213.rmeta
│       │   ├── linux_raw_sys-73b9062c952413b1.d
│       │   ├── lock_api-5d156468aadc6305.d
│       │   ├── log-6cd4629aa2b17585.d
│       │   ├── memchr-5dc2f2fbe59b86ae.d
│       │   ├── mio-deba033cccc3facf.d
│       │   ├── mockall-7629eaa388ce295b.d
│       │   ├── mockall_derive-6e01deed3a52c3d9.d
│       │   ├── nix-1bd868b90df78989.d
│       │   ├── num_traits-b5fb7a10fea4e865.d
│       │   ├── once_cell-d5812127dbf95fda.d
│       │   ├── open-9350816b22aab171.d
│       │   ├── option_ext-6f7fa96f25d92544.d
│       │   ├── parking_lot-47eec5e13488891d.d
│       │   ├── parking_lot_core-1c2f926f842b8b50.d
│       │   ├── pathdiff-803e8bb907f8ab4e.d
│       │   ├── pin_project_lite-b9d1796c473ec11b.d
│       │   ├── pin_utils-ea6a80c5a52cb427.d
│       │   ├── predicates-b4dd57729913647f.d
│       │   ├── predicates_core-4a972ed15ee05eb7.d
│       │   ├── predicates_tree-29b69f074dd2de86.d
│       │   ├── proc_macro2-85ee1178db9d334e.d
│       │   ├── proconio-3ed4a44fe4bc50d4.d
│       │   ├── quote-24e4c4ad8087851c.d
│       │   ├── regex-827182a0ba8074ce.d
│       │   ├── regex_automata-c5b3c9e7012ddb9f.d
│       │   ├── regex_syntax-8d7baa200d762905.d
│       │   ├── rpassword-15e53038bdb27e18.d
│       │   ├── rtoolbox-15525837a648eeb4.d
│       │   ├── rustix-9adc52868c87c7a1.d
│       │   ├── ryu-5f32db5f3caaa50c.d
│       │   ├── scopeguard-6959bebfd559c22f.d
│       │   ├── serde-c8df369d193609ec.d
│       │   ├── serde_derive-510fc85a7674ae50.d
│       │   ├── serde_json-74f17f7969cfc8b1.d
│       │   ├── serde_yaml-bd11247655c7415c.d
│       │   ├── signal_hook_registry-f06782ab9899fe44.d
│       │   ├── slab-0a9a1578932bac2c.d
│       │   ├── smallvec-b9156fd417ed1f6b.d
│       │   ├── socket2-beff616ac680c0a7.d
│       │   ├── strsim-f2e39a63b5377e46.d
│       │   ├── syn-e62a01da217c3cd5.d
│       │   ├── tar-8c5c07ad440a6633.d
│       │   ├── tempfile-cd0b405da8986ab9.d
│       │   ├── termtree-c72ab1b1e0ad1803.d
│       │   ├── thiserror-3ce04a1e83c84ffc.d
│       │   ├── thiserror_impl-cad109f874fb6f84.d
│       │   ├── tokio-60d39fe2ef8c41e9.d
│       │   ├── tokio_macros-3685a7acebc11479.d
│       │   ├── unicode_ident-f7f10e726d017c79.d
│       │   ├── unsafe_libyaml-7381adfd2f251def.d
│       │   ├── users-a4372465a2b3f9c7.d
│       │   ├── utf8parse-fd79f0fb0f127bde.d
│       │   ├── uuid-2f21b4bd3e7f91b9.d
│       │   └── xattr-603e9a39274f8213.d
│       ├── examples
│       └── incremental
│           ├── cph-2f3pi9sxdzpit
│           │   ├── s-h3fzfy0egh-0s8ko1k-ctrh6vfz31fo41z9zqtrfaoxv
│           │   │   ├── dep-graph.bin
│           │   │   ├── query-cache.bin
│           │   │   └── work-products.bin
│           │   └── s-h3fzfy0egh-0s8ko1k.lock
│           └── cph-3smxpb7h7sc4i
│               ├── s-h3fzfxkcxn-1qvuxes-754gtb4b3xmjltxbbttkz73g8
│               │   ├── dep-graph.bin
│               │   ├── query-cache.bin
│               │   └── work-products.bin
│               └── s-h3fzfxkcxn-1qvuxes.lock
└── tests
    ├── config.yaml
    ├── docker
    │   └── mod.rs
    ├── error_test.rs
    ├── fs
    │   └── mod.rs
    ├── helpers
    │   └── mod.rs
    ├── lib.rs
    └── mod.rs

69 directories, 382 files

=== Cargo Check ===

=== Git Diff ===
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 8fd795b..4b0a839 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -51,6 +51,8 @@
 // ```
 
 use std::fs;
+use std::sync::Arc;
+use std::time::SystemTime;
 use serde::{Deserialize, Serialize};
 use serde_yaml::{self, Value};
 use thiserror::Error;
@@ -72,11 +74,14 @@ pub enum ConfigError {
         actual: ConfigType,
     },
 
+    #[error("設定の検証に失敗しました: {0}")]
+    Validation(String),
+
     #[error("{0}")]
     Config(String),
 }
 
-#[derive(Debug)]
+#[derive(Debug, Clone)]
 pub enum ConfigType {
     String,
     StringArray,
@@ -84,33 +89,99 @@ pub enum ConfigType {
     Boolean,
     Number,
     Null,
+    Tagged,
+}
+
+#[derive(Debug, Clone)]
+pub struct ConfigAccess {
+    path: String,
+    timestamp: SystemTime,
+    value_type: ConfigType,
 }
 
 pub type ConfigResult<T> = Result<T, ConfigError>;
 
-#[derive(Debug, Serialize, Deserialize)]
-pub struct Config {
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct ConfigValue {
     system: Value,
     languages: Value,
 }
 
+#[derive(Clone)]
+pub struct Config {
+    value: Arc<ConfigValue>,
+    access_history: Arc<Vec<ConfigAccess>>,
+    validation_rules: Arc<Vec<Arc<dyn Fn(&ConfigValue) -> ConfigResult<()> + Send + Sync>>>,
+}
+
+impl std::fmt::Debug for Config {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("Config")
+            .field("value", &self.value)
+            .field("access_history", &self.access_history)
+            .field("validation_rules", &format!("<{} rules>", self.validation_rules.len()))
+            .finish()
+    }
+}
+
 impl Config {
     pub fn new() -> ConfigResult<Self> {
         let config_str = fs::read_to_string("config.yml")
             .map_err(|e| ConfigError::Config(format!("設定ファイルの読み込みに失敗しました: {}", e)))?;
 
-        let config: Config = serde_yaml::from_str(&config_str)
+        let value: ConfigValue = serde_yaml::from_str(&config_str)
             .map_err(|e| ConfigError::Config(format!("設定ファイルのパースに失敗しました: {}", e)))?;
 
+        let config = Self {
+            value: Arc::new(value),
+            access_history: Arc::new(Vec::new()),
+            validation_rules: Arc::new(Vec::new()),
+        };
+
+        config.validate()?;
         Ok(config)
     }
 
-    pub fn get<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<T> {
+    fn with_access(&self, path: String, value_type: ConfigType) -> Self {
+        let mut history = (*self.access_history).clone();
+        history.push(ConfigAccess {
+            path,
+            timestamp: SystemTime::now(),
+            value_type,
+        });
+        Self {
+            value: self.value.clone(),
+            access_history: Arc::new(history),
+            validation_rules: self.validation_rules.clone(),
+        }
+    }
+
+    pub fn with_validation_rule<F>(self, rule: F) -> Self
+    where
+        F: Fn(&ConfigValue) -> ConfigResult<()> + Send + Sync + 'static,
+    {
+        let mut rules = (*self.validation_rules).clone();
+        rules.push(Arc::new(rule));
+        Self {
+            value: self.value,
+            access_history: self.access_history,
+            validation_rules: Arc::new(rules),
+        }
+    }
+
+    pub fn validate(&self) -> ConfigResult<()> {
+        for rule in self.validation_rules.iter() {
+            rule(&self.value)?;
+        }
+        Ok(())
+    }
+
+    pub fn get<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<(T, Self)> {
         let parts: Vec<&str> = path.split('.').collect();
         let mut current = match parts[0] {
-            "system" => serde_yaml::to_value(&self.system)
+            "system" => serde_yaml::to_value(&self.value.system)
                 .map_err(|e| ConfigError::Config(e.to_string()))?,
-            "languages" => serde_yaml::to_value(&self.languages)
+            "languages" => serde_yaml::to_value(&self.value.languages)
                 .map_err(|e| ConfigError::Config(e.to_string()))?,
             _ => return Err(ConfigError::Config(format!("無効な設定パス: {}", path))),
         };
@@ -121,30 +192,105 @@ impl Config {
                 .clone();
         }
 
-        serde_yaml::from_value(current)
-            .map_err(|e| ConfigError::Config(format!("値の変換に失敗しました: {}", e)))
-    }
+        let value_type = match current {
+            Value::String(_) => ConfigType::String,
+            Value::Sequence(_) => ConfigType::StringArray,
+            Value::Mapping(_) => ConfigType::Object,
+            Value::Bool(_) => ConfigType::Boolean,
+            Value::Number(_) => ConfigType::Number,
+            Value::Null => ConfigType::Null,
+            Value::Tagged(_) => ConfigType::Tagged,
+        };
 
-    pub fn get_with_alias<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<T> {
-        let result = self.get::<T>(path);
-        if result.is_ok() {
-            return result;
-        }
+        let new_config = self.with_access(path.to_string(), value_type);
+        let value = serde_yaml::from_value(current)
+            .map_err(|e| ConfigError::Config(format!("値の変換に失敗しました: {}", e)))?;
 
-        // エイリアスの解決を試みる
-        let parts: Vec<&str> = path.split('.').collect();
-        if parts.len() >= 2 && parts[0] == "languages" {
-            let alias_path = format!("languages.{}.alias", parts[1]);
-            if let Ok(alias) = self.get::<String>(&alias_path) {
-                let new_path = format!("languages.{}.{}", alias, parts[2..].join("."));
-                return self.get::<T>(&new_path);
+        Ok((value, new_config))
+    }
+
+    pub fn get_with_alias<T: serde::de::DeserializeOwned>(&self, path: &str) -> ConfigResult<(T, Self)> {
+        match self.get::<T>(path) {
+            Ok(result) => Ok(result),
+            Err(_) => {
+                let parts: Vec<&str> = path.split('.').collect();
+                if parts.len() >= 2 && parts[0] == "languages" {
+                    let alias_path = format!("languages.{}.alias", parts[1]);
+                    let (alias, config) = self.get::<String>(&alias_path)?;
+                    let new_path = format!("languages.{}.{}", alias, parts[2..].join("."));
+                    config.get::<T>(&new_path)
+                } else {
+                    Err(ConfigError::Config(format!("設定パスが見つかりません: {}", path)))
+                }
             }
         }
+    }
+
+    pub fn get_raw_value(&self, key: &str) -> ConfigResult<(&Value, Self)> {
+        let value = self.value.system.get(key)
+            .ok_or_else(|| ConfigError::Config(format!("設定キーが見つかりません: {}", key)))?;
+
+        let value_type = match value {
+            Value::String(_) => ConfigType::String,
+            Value::Sequence(_) => ConfigType::StringArray,
+            Value::Mapping(_) => ConfigType::Object,
+            Value::Bool(_) => ConfigType::Boolean,
+            Value::Number(_) => ConfigType::Number,
+            Value::Null => ConfigType::Null,
+            Value::Tagged(_) => ConfigType::Tagged,
+        };
+
+        let new_config = self.with_access(key.to_string(), value_type);
+        Ok((value, new_config))
+    }
+
+    pub fn access_history(&self) -> &[ConfigAccess] {
+        &self.access_history
+    }
 
-        result
+    pub fn get_accesses_since(&self, since: SystemTime) -> Vec<ConfigAccess> {
+        self.access_history
+            .iter()
+            .filter(|access| access.timestamp >= since)
+            .cloned()
+            .collect()
     }
 
-    pub fn get_raw_value(&self, key: &str) -> ConfigResult<&Value> {
-        self.system.get(key).ok_or_else(|| ConfigError::Config(format!("設定キーが見つかりません: {}", key)))
+    pub fn merge(&self, other: &Config) -> ConfigResult<Self> {
+        let merged_value = self.merge_values(&self.value, &other.value)?;
+        let mut merged_rules = (*self.validation_rules).clone();
+        merged_rules.extend((*other.validation_rules).clone());
+
+        let config = Self {
+            value: Arc::new(merged_value),
+            access_history: Arc::new(Vec::new()),
+            validation_rules: Arc::new(merged_rules),
+        };
+
+        config.validate()?;
+        Ok(config)
+    }
+
+    fn merge_values(&self, base: &ConfigValue, other: &ConfigValue) -> ConfigResult<ConfigValue> {
+        let merged_system = self.merge_yaml(&base.system, &other.system)?;
+        let merged_languages = self.merge_yaml(&base.languages, &other.languages)?;
+
+        Ok(ConfigValue {
+            system: merged_system,
+            languages: merged_languages,
+        })
+    }
+
+    fn merge_yaml(&self, base: &Value, other: &Value) -> ConfigResult<Value> {
+        match (base, other) {
+            (Value::Mapping(base_map), Value::Mapping(other_map)) => {
+                let mut merged = base_map.clone();
+                for (key, value) in other_map {
+                    merged.insert(key.clone(), value.clone());
+                }
+                Ok(Value::Mapping(merged))
+            },
+            (_, other) => Ok(other.clone()),
+        }
     }
 } 
\ No newline at end of file
diff --git a/src/contest/model/state.rs b/src/contest/model/state.rs
index 2dab735..ae02905 100644
--- a/src/contest/model/state.rs
+++ b/src/contest/model/state.rs
@@ -17,10 +17,17 @@
 
 use std::path::PathBuf;
 use std::sync::Arc;
+use std::time::SystemTime;
 use crate::error::Result;
 use crate::error::contest::ContestErrorKind;
 use crate::contest::error::contest_error;
 
+#[derive(Debug, Clone)]
+pub struct StateHistory {
+    timestamp: SystemTime,
+    transition: StateTransition,
+}
+
 #[derive(Debug, Clone)]
 pub struct ContestState {
     site: Option<Arc<String>>,
@@ -28,6 +35,7 @@ pub struct ContestState {
     problem_id: Option<Arc<String>>,
     language: Option<Arc<String>>,
     source_path: Option<Arc<PathBuf>>,
+    history: Vec<StateHistory>,
 }
 
 #[derive(Debug, Clone)]
@@ -37,6 +45,7 @@ pub struct ValidatedState {
     pub(crate) problem_id: Arc<String>,
     pub(crate) language: Arc<String>,
     pub(crate) source_path: Arc<PathBuf>,
+    pub(crate) history: Arc<Vec<StateHistory>>,
 }
 
 // 状態遷移の型安全性を向上させるための新しい型
@@ -57,6 +66,7 @@ impl ContestState {
             problem_id: None,
             language: None,
             source_path: None,
+            history: Vec::new(),
         }
     }
 
@@ -82,12 +92,28 @@ impl ContestState {
 
     // 型安全な状態遷移メソッドを追加
     pub fn apply_transition(self, transition: StateTransition) -> Self {
-        match transition {
+        let history_entry = StateHistory {
+            timestamp: SystemTime::now(),
+            transition: transition.clone(),
+        };
+        
+        let new_state = match transition {
             StateTransition::SetSite(site) => self.with_site(site),
             StateTransition::SetContestId(id) => self.with_contest_id(id),
             StateTransition::SetProblemId(id) => self.with_problem_id(id),
             StateTransition::SetLanguage(lang) => self.with_language(lang),
             StateTransition::SetSourcePath(path) => self.with_source_path(path),
+        };
+
+        let mut history = new_state.history.clone();
+        history.push(history_entry);
+        Self {
+            site: new_state.site,
+            contest_id: new_state.contest_id,
+            problem_id: new_state.problem_id,
+            language: new_state.language,
+            source_path: new_state.source_path,
+            history,
         }
     }
 
@@ -108,7 +134,7 @@ impl ContestState {
         let source_path = self.source_path.clone()
             .ok_or_else(|| contest_error(ContestErrorKind::NotFound, "ソースパスが指定されていません"))?;
 
-        // 追加のバリデーションルール
+        // 拡張されたバリデーションルール
         if site.is_empty() {
             return Err(contest_error(ContestErrorKind::Invalid, "サイトが空です"));
         }
@@ -122,12 +148,21 @@ impl ContestState {
             return Err(contest_error(ContestErrorKind::Invalid, "言語が空です"));
         }
 
+        // パスのバリデーション
+        if !source_path.exists() {
+            return Err(contest_error(ContestErrorKind::Invalid, "指定されたソースパスが存在しません"));
+        }
+        if !source_path.is_file() {
+            return Err(contest_error(ContestErrorKind::Invalid, "指定されたソースパスはファイルではありません"));
+        }
+
         Ok(ValidatedState {
             site,
             contest_id,
             problem_id,
             language,
             source_path,
+            history: Arc::new(self.history.clone()),
         })
     }
 
@@ -178,6 +213,14 @@ impl ValidatedState {
         &self.source_path
     }
 
+    pub fn history(&self) -> &[StateHistory] {
+        &self.history
+    }
+
+    pub fn last_transition(&self) -> Option<&StateHistory> {
+        self.history.last()
+    }
+
     // 新しいメソッド：状態の変更を試みる（新しいValidatedStateを返す）
     pub fn try_update(&self, transition: StateTransition) -> Result<ValidatedState> {
         let mut new_state = ContestState::new()
@@ -187,7 +230,21 @@ impl ValidatedState {
             .with_language(self.language.as_ref().clone())
             .with_source_path(self.source_path.as_ref().clone());
 
+        new_state.history = (*self.history).clone();
         new_state = new_state.apply_transition(transition);
         new_state.validate()
     }
-} 
\ No newline at end of file
+}
+
+// 新しい実装：状態の比較
+impl PartialEq for ValidatedState {
+    fn eq(&self, other: &Self) -> bool {
+        self.site == other.site &&
+        self.contest_id == other.contest_id &&
+        self.problem_id == other.problem_id &&
+        self.language == other.language &&
+        self.source_path == other.source_path
+    }
+}
+
+impl Eq for ValidatedState {} 
\ No newline at end of file
diff --git a/src/contest/parse.rs b/src/contest/parse.rs
index 445a821..062b07d 100644
--- a/src/contest/parse.rs
+++ b/src/contest/parse.rs
@@ -54,9 +54,10 @@ impl NameResolver {
         let mut command_aliases = HashMap::new();
         let executions = config.get_raw_value("executions")
             .map_err(|_| ParseError::MissingSection("executions".to_string()))?;
+        let executions = executions.0;
 
-        if let Value::Mapping(executions) = executions {
-            for (cmd_name, cmd_config) in executions {
+        if let Value::Mapping(executions_map) = executions {
+            for (cmd_name, cmd_config) in executions_map {
                 if let (Value::String(name), Value::Mapping(config)) = (cmd_name, cmd_config) {
                     if let Some(Value::Sequence(aliases)) = config.get("aliases") {
                         let aliases: Vec<String> = aliases.iter()
@@ -80,11 +81,12 @@ impl NameResolver {
 
         let settings = config.get_raw_value("settings")
             .map_err(|_| ParseError::MissingSection("settings".to_string()))?;
+        let settings = settings.0;
 
-        if let Value::Mapping(settings) = settings {
+        if let Value::Mapping(settings_map) = settings {
             Ok(Self {
                 command_aliases,
-                settings: settings.iter()
+                settings: settings_map.iter()
                     .map(|(k, v)| (k.as_str().unwrap_or_default().to_string(), v.clone()))
                     .collect(),
             })
diff --git a/src/docker/state/manager.rs b/src/docker/state/manager.rs
index 0e6ca54..d576e5f 100644
--- a/src/docker/state/manager.rs
+++ b/src/docker/state/manager.rs
@@ -1,11 +1,25 @@
 use std::sync::Arc;
+use std::time::{SystemTime, Duration};
 use tokio::sync::RwLock;
 use crate::error::Result;
 use super::ContainerState;
 use crate::docker::error::state_err;
 use super::types::{StateInfo, StateType};
 
-// 状態遷移を表現する型
+#[derive(Debug, Clone)]
+pub struct StateTransitionInfo {
+    pub timestamp: SystemTime,
+    pub transition: StateTransition,
+    pub result: TransitionResult,
+    pub duration: Duration,
+}
+
+#[derive(Debug, Clone)]
+pub enum TransitionResult {
+    Success(ContainerState),
+    Failure(String),
+}
+
 #[derive(Debug, Clone)]
 pub enum StateTransition {
     Create(String),
@@ -20,12 +34,14 @@ pub enum StateTransition {
 #[derive(Debug, Clone)]
 pub struct ContainerStateManager {
     state: Arc<RwLock<ContainerState>>,
+    history: Arc<RwLock<Vec<StateTransitionInfo>>>,
 }
 
 impl ContainerStateManager {
     pub fn new() -> Self {
         Self {
             state: Arc::new(RwLock::new(ContainerState::new())),
+            history: Arc::new(RwLock::new(Vec::new())),
         }
     }
 
@@ -33,61 +49,91 @@ impl ContainerStateManager {
         self.state.read().await.clone()
     }
 
-    // 状態遷移を適用する共通メソッド
+    pub async fn get_transition_history(&self) -> Vec<StateTransitionInfo> {
+        self.history.read().await.clone()
+    }
+
+    async fn record_transition(&self, transition: StateTransition, result: TransitionResult, duration: Duration) {
+        let info = StateTransitionInfo {
+            timestamp: SystemTime::now(),
+            transition,
+            result,
+            duration,
+        };
+        self.history.write().await.push(info);
+    }
+
+    async fn validate_transition(&self, transition: &StateTransition, current_state: &ContainerState) -> Result<()> {
+        match (current_state, transition) {
+            (ContainerState::Initial, StateTransition::Create(_)) => Ok(()),
+            (ContainerState::Created { .. }, StateTransition::Start) => Ok(()),
+            (ContainerState::Running { .. }, StateTransition::Execute(_)) => Ok(()),
+            (ContainerState::Running { .. } | ContainerState::Executing { .. }, StateTransition::Stop) => Ok(()),
+            (_, StateTransition::Fail(_)) => Ok(()),
+            (ContainerState::Failed { .. }, StateTransition::Regenerate) => Ok(()),
+            (ContainerState::Created { .. }, StateTransition::Restore(_)) => Ok(()),
+            _ => Err(state_err(
+                "状態遷移の検証",
+                format!("無効な状態遷移: {} -> {:?}", current_state, transition)
+            )),
+        }
+    }
+
     async fn apply_transition(&self, transition: StateTransition) -> Result<()> {
+        let start_time = SystemTime::now();
         let current_state = self.get_current_state().await;
-        let new_state = match transition {
+
+        // 状態遷移の検証
+        if let Err(e) = self.validate_transition(&transition, &current_state).await {
+            let duration = start_time.elapsed().unwrap_or(Duration::from_secs(0));
+            self.record_transition(
+                transition,
+                TransitionResult::Failure(e.to_string()),
+                duration
+            ).await;
+            return Err(e);
+        }
+
+        let new_state = match transition.clone() {
             StateTransition::Create(container_id) => {
-                if !matches!(current_state, ContainerState::Initial) {
-                    return Err(state_err(
-                        "状態遷移",
-                        format!("無効な状態からの作成遷移: {}", current_state)
-                    ));
-                }
                 ContainerState::create(container_id)
             },
             StateTransition::Start => {
                 current_state.start()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("無効な状態からの開始遷移: {}", current_state)
+                        format!("開始遷移の失敗: {}", current_state)
                     ))?
             },
             StateTransition::Execute(command) => {
                 current_state.execute(command)
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("無効な状態からのコマンド実行遷移: {}", current_state)
+                        format!("コマンド実行遷移の失敗: {}", current_state)
                     ))?
             },
             StateTransition::Stop => {
                 current_state.stop()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("無効な状態からの停止遷移: {}", current_state)
+                        format!("停止遷移の失敗: {}", current_state)
                     ))?
             },
             StateTransition::Fail(error) => {
                 current_state.fail(error)
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("無効な状態からの失敗遷移: {}", current_state)
+                        format!("失敗遷移の失敗: {}", current_state)
                     ))?
             },
             StateTransition::Regenerate => {
                 current_state.regenerate()
                     .ok_or_else(|| state_err(
                         "状態遷移",
-                        format!("無効な状態からの再生成遷移: {}", current_state)
+                        format!("再生成遷移の失敗: {}", current_state)
                     ))?
             },
             StateTransition::Restore(state_info) => {
-                if !matches!(current_state, ContainerState::Created { .. }) {
-                    return Err(state_err(
-                        "状態遷移",
-                        format!("無効な状態からの状態復元: {}", current_state)
-                    ));
-                }
                 match state_info.state_type {
                     StateType::Running => ContainerState::Running {
                         container_id: state_info.container_id,
@@ -112,7 +158,13 @@ impl ContainerStateManager {
             },
         };
 
-        *self.state.write().await = new_state;
+        let duration = start_time.elapsed().unwrap_or(Duration::from_secs(0));
+        *self.state.write().await = new_state.clone();
+        self.record_transition(
+            transition,
+            TransitionResult::Success(new_state),
+            duration
+        ).await;
         Ok(())
     }
 
@@ -151,4 +203,16 @@ impl ContainerStateManager {
             .map(String::from)
             .ok_or_else(|| state_err("状態管理", "コンテナIDが見つかりません"))
     }
+
+    pub async fn get_last_transition(&self) -> Option<StateTransitionInfo> {
+        self.history.read().await.last().cloned()
+    }
+
+    pub async fn get_transitions_since(&self, since: SystemTime) -> Vec<StateTransitionInfo> {
+        self.history.read().await
+            .iter()
+            .filter(|info| info.timestamp >= since)
+            .cloned()
+            .collect()
+    }
 } 
\ No newline at end of file
diff --git a/src/fs/transaction.rs b/src/fs/transaction.rs
index c70aad2..9d5c46b 100644
--- a/src/fs/transaction.rs
+++ b/src/fs/transaction.rs
@@ -1,5 +1,6 @@
 use std::path::PathBuf;
 use std::sync::Arc;
+use std::time::SystemTime;
 use crate::error::Error;
 use crate::fs::error::io_err;
 
@@ -7,9 +8,22 @@ pub trait FileOperation: Send + Sync + std::fmt::Debug {
     fn execute(&self) -> Result<(), Error>;
     fn rollback(&self) -> Result<(), Error>;
     fn description(&self) -> String;
+    fn validate(&self) -> Result<(), Error>;
+}
+
+#[derive(Debug, Clone)]
+pub struct TransactionHistory {
+    timestamp: SystemTime,
+    transition: TransactionTransition,
+    result: TransactionResult,
+}
+
+#[derive(Debug, Clone)]
+pub enum TransactionResult {
+    Success,
+    Failure(String),
 }
 
-// 状態遷移を表現する型
 #[derive(Debug, Clone)]
 pub enum TransactionTransition {
     AddOperation(Arc<dyn FileOperation>),
@@ -29,6 +43,7 @@ pub enum TransactionState {
 pub struct FileTransaction {
     operations: Arc<Vec<Arc<dyn FileOperation>>>,
     state: TransactionState,
+    history: Arc<Vec<TransactionHistory>>,
 }
 
 impl FileTransaction {
@@ -36,62 +51,100 @@ impl FileTransaction {
         Self {
             operations: Arc::new(Vec::new()),
             state: TransactionState::Pending,
+            history: Arc::new(Vec::new()),
+        }
+    }
+
+    fn with_transition_record(&self, transition: TransactionTransition, result: TransactionResult) -> Self {
+        let mut history = (*self.history).clone();
+        history.push(TransactionHistory {
+            timestamp: SystemTime::now(),
+            transition,
+            result,
+        });
+        Self {
+            operations: self.operations.clone(),
+            state: self.state.clone(),
+            history: Arc::new(history),
+        }
+    }
+
+    fn with_operations(&self, operations: Vec<Arc<dyn FileOperation>>) -> Self {
+        Self {
+            operations: Arc::new(operations),
+            state: self.state.clone(),
+            history: self.history.clone(),
+        }
+    }
+
+    fn with_state(&self, state: TransactionState) -> Self {
+        Self {
+            operations: self.operations.clone(),
+            state,
+            history: self.history.clone(),
         }
     }
 
-    // 状態遷移を適用するメソッド
     pub fn apply_transition(self, transition: TransactionTransition) -> Result<Self, Error> {
-        match (self.state, transition) {
+        match (self.state.clone(), transition.clone()) {
             (TransactionState::Pending, TransactionTransition::AddOperation(op)) => {
+                if let Err(e) = op.validate() {
+                    return Ok(self.with_transition_record(
+                        transition,
+                        TransactionResult::Failure(format!("操作の検証に失敗: {}", e))
+                    ));
+                }
+
                 let mut operations = (*self.operations).clone();
                 operations.push(op);
-                Ok(Self {
-                    operations: Arc::new(operations),
-                    state: TransactionState::Pending,
-                })
+                Ok(self.with_transition_record(
+                    transition,
+                    TransactionResult::Success
+                ).with_operations(operations))
             },
             (TransactionState::Pending, TransactionTransition::Execute) => {
                 let operations = self.operations.clone();
                 for operation in operations.iter() {
                     if let Err(e) = operation.execute() {
-                        let failed_state = Self {
-                            operations: operations.clone(),
-                            state: TransactionState::Failed(Arc::new(e)),
-                        };
+                        let failed_state = self.with_transition_record(
+                            transition.clone(),
+                            TransactionResult::Failure(format!("実行に失敗: {}", e))
+                        ).with_state(TransactionState::Failed(Arc::new(e)));
                         return Ok(failed_state.apply_transition(TransactionTransition::Rollback)?);
                     }
                 }
-                Ok(Self {
-                    operations,
-                    state: TransactionState::Executed,
-                })
+                Ok(self.with_transition_record(
+                    transition,
+                    TransactionResult::Success
+                ).with_state(TransactionState::Executed))
             },
             (TransactionState::Executed | TransactionState::Pending, TransactionTransition::Rollback) => {
                 let operations = self.operations.clone();
                 for operation in operations.iter().rev() {
                     if let Err(e) = operation.rollback() {
-                        return Ok(Self {
-                            operations,
-                            state: TransactionState::Failed(Arc::new(e)),
-                        });
+                        return Ok(self.with_transition_record(
+                            transition,
+                            TransactionResult::Failure(format!("ロールバックに失敗: {}", e))
+                        ).with_state(TransactionState::Failed(Arc::new(e))));
                     }
                 }
-                Ok(Self {
-                    operations,
-                    state: TransactionState::RolledBack,
-                })
+                Ok(self.with_transition_record(
+                    transition,
+                    TransactionResult::Success
+                ).with_state(TransactionState::RolledBack))
             },
             (state, transition) => {
-                Ok(Self {
-                    operations: self.operations,
-                    state: TransactionState::Failed(Arc::new(io_err(
-                        std::io::Error::new(
-                            std::io::ErrorKind::InvalidInput,
-                            format!("無効な状態遷移: {:?} -> {:?}", state, transition)
-                        ),
-                        "トランザクション状態遷移エラー".to_string(),
-                    ))),
-                })
+                let error = io_err(
+                    std::io::Error::new(
+                        std::io::ErrorKind::InvalidInput,
+                        format!("無効な状態遷移: {:?} -> {:?}", state, transition)
+                    ),
+                    "トランザクション状態遷移エラー".to_string(),
+                );
+                Ok(self.with_transition_record(
+                    transition,
+                    TransactionResult::Failure(error.to_string())
+                ).with_state(TransactionState::Failed(Arc::new(error))))
             }
         }
     }
@@ -117,24 +170,37 @@ impl FileTransaction {
         &self.operations
     }
 
+    pub fn history(&self) -> &[TransactionHistory] {
+        &self.history
+    }
+
     // トランザクションの合成メソッド
     pub fn combine(self, other: Self) -> Result<Self, Error> {
-        match (self.state, other.state) {
+        match (self.state.clone(), other.state) {
             (TransactionState::Pending, TransactionState::Pending) => {
                 let mut operations = (*self.operations).clone();
                 operations.extend((*other.operations).clone());
+                let mut history = (*self.history).clone();
+                history.extend((*other.history).clone());
                 Ok(Self {
                     operations: Arc::new(operations),
                     state: TransactionState::Pending,
+                    history: Arc::new(history),
                 })
             },
-            _ => Err(io_err(
-                std::io::Error::new(
-                    std::io::ErrorKind::InvalidInput,
-                    "トランザクションの合成は保留状態でのみ可能です"
-                ),
-                "トランザクション合成エラー".to_string(),
-            )),
+            _ => {
+                let error = io_err(
+                    std::io::Error::new(
+                        std::io::ErrorKind::InvalidInput,
+                        "トランザクションの合成は保留状態でのみ可能です"
+                    ),
+                    "トランザクション合成エラー".to_string(),
+                );
+                Ok(self.with_transition_record(
+                    TransactionTransition::Execute,
+                    TransactionResult::Failure(error.to_string())
+                ).with_state(TransactionState::Failed(Arc::new(error))))
+            }
         }
     }
 }
@@ -176,6 +242,30 @@ impl FileOperation for CreateFileOperation {
     fn description(&self) -> String {
         format!("ファイル作成: {}", self.path.display())
     }
+
+    fn validate(&self) -> Result<(), Error> {
+        if self.path.exists() {
+            return Err(io_err(
+                std::io::Error::new(
+                    std::io::ErrorKind::AlreadyExists,
+                    format!("ファイルが既に存在します: {}", self.path.display())
+                ),
+                "ファイル作成検証エラー".to_string(),
+            ));
+        }
+        if let Some(parent) = self.path.parent() {
+            if parent.exists() && !parent.is_dir() {
+                return Err(io_err(
+                    std::io::Error::new(
+                        std::io::ErrorKind::InvalidInput,
+                        format!("親パスがディレクトリではありません: {}", parent.display())
+                    ),
+                    "ファイル作成検証エラー".to_string(),
+                ));
+            }
+        }
+        Ok(())
+    }
 }
 
 #[derive(Debug)]
@@ -224,4 +314,26 @@ impl FileOperation for DeleteFileOperation {
     fn description(&self) -> String {
         format!("ファイル削除: {}", self.path.display())
     }
+
+    fn validate(&self) -> Result<(), Error> {
+        if !self.path.exists() {
+            return Err(io_err(
+                std::io::Error::new(
+                    std::io::ErrorKind::NotFound,
+                    format!("ファイルが存在しません: {}", self.path.display())
+                ),
+                "ファイル削除検証エラー".to_string(),
+            ));
+        }
+        if !self.path.is_file() {
+            return Err(io_err(
+                std::io::Error::new(
+                    std::io::ErrorKind::InvalidInput,
+                    format!("パスがファイルではありません: {}", self.path.display())
+                ),
+                "ファイル削除検証エラー".to_string(),
+            ));
+        }
+        Ok(())
+    }
 } 
