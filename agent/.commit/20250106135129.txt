diff --git a/src/docker/execution/compilation.rs b/src/docker/execution/compilation.rs
index 1a6b41a..9efb1b9 100644
--- a/src/docker/execution/compilation.rs
+++ b/src/docker/execution/compilation.rs
@@ -14,7 +14,7 @@ impl CompilationManager {
         }
     }
 
-    pub async fn compile<P: AsRef<Path>>(&mut self, source_code: &str, compile_cmd: Option<Vec<String>>, env_vars: Vec<String>, working_dir: P) -> Result<()> {
+    pub async fn compile<P: AsRef<Path>>(&mut self, _source_code: &str, compile_cmd: Option<Vec<String>>, env_vars: Vec<String>, working_dir: P) -> Result<()> {
         if self.container_id.is_some() {
             return Err(compilation_err("コンパイルは既に実行されています".to_string()));
         }
diff --git a/src/docker/fs.rs b/src/docker/fs.rs
index f637a76..ec344ac 100644
--- a/src/docker/fs.rs
+++ b/src/docker/fs.rs
@@ -1,37 +1,100 @@
 use std::path::Path;
+use std::os::unix::fs::PermissionsExt;
 use crate::error::Result;
+use nix::unistd::{Uid, Gid};
 use crate::docker::error::docker_err;
 
 pub trait DockerFileOperations {
-    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<()>;
+    fn create_temp_directory(&self) -> Result<std::path::PathBuf>;
     fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()>;
+    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf>;
 }
 
-pub struct DefaultDockerFileOperations;
+/// Docker環境でのファイル操作のデフォルト実装
+pub trait DefaultDockerFileOperations: DockerFileOperations {
+    /// ディレクトリの権限を確認・設定
+    fn ensure_directory_permissions(&self, dir: &Path) -> Result<()> {
+        let metadata = std::fs::metadata(dir)
+            .map_err(|e| docker_err(format!("ディレクトリのメタデータの取得に失敗しました: {}", e)))?;
+        let mut perms = metadata.permissions();
+        perms.set_mode(0o777);
+        std::fs::set_permissions(dir, perms)
+            .map_err(|e| docker_err(format!("ディレクトリの権限設定に失敗しました: {}", e)))?;
+        Ok(())
+    }
 
-impl DefaultDockerFileOperations {
-    pub fn new() -> Self {
-        Self
+    /// 現在のユーザーIDとグループIDを取得
+    fn get_current_user_ids(&self) -> (Uid, Gid) {
+        let uid = Uid::from_raw(std::process::id() as u32);
+        let gid = Gid::from_raw(unsafe { libc::getgid() } as u32);
+        (uid, gid)
     }
 }
 
-impl DockerFileOperations for DefaultDockerFileOperations {
-    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<()> {
-        let path = dir.as_ref().join(filename);
-        std::fs::write(&path, content)
-            .map_err(|e| docker_err(format!("ソースファイルの書き込みに失敗しました: {}", e)))?;
-        Ok(())
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use tempfile::TempDir;
+    use std::fs;
+
+    struct MockDockerFileOps {
+        temp_dir: TempDir,
     }
 
-    fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()> {
-        use std::os::unix::fs::PermissionsExt;
-        let path = path.as_ref();
-        let metadata = std::fs::metadata(path)
-            .map_err(|e| docker_err(format!("メタデータの取得に失敗しました: {}", e)))?;
-        let mut perms = metadata.permissions();
-        perms.set_mode(mode);
-        std::fs::set_permissions(path, perms)
-            .map_err(|e| docker_err(format!("権限の設定に失敗しました: {}", e)))?;
+    impl MockDockerFileOps {
+        fn new() -> Result<Self> {
+            let temp_dir = TempDir::new()
+                .map_err(|e| container_err(format!("一時ディレクトリの作成に失敗しました: {}", e)))?;
+            Ok(Self { temp_dir })
+        }
+    }
+
+    impl DockerFileOperations for MockDockerFileOps {
+        fn create_temp_directory(&self) -> Result<std::path::PathBuf> {
+            Ok(self.temp_dir.path().to_path_buf())
+        }
+
+        fn set_permissions<P: AsRef<Path>>(&self, path: P, _mode: u32) -> Result<()> {
+            if path.as_ref().exists() {
+                Ok(())
+            } else {
+                Err(container_err("パスが存在しません".to_string()))
+            }
+        }
+
+        fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf> {
+            let file_path = dir.as_ref().join(filename);
+            fs::write(&file_path, content)
+                .map_err(|e| container_err(format!("ソースファイルの書き込みに失敗しました: {}", e)))?;
+            Ok(file_path)
+        }
+    }
+
+    impl DefaultDockerFileOperations for MockDockerFileOps {}
+
+    #[test]
+    fn test_mock_docker_file_ops() -> Result<()> {
+        let ops = MockDockerFileOps::new()?;
+        
+        // テスト一時ディレクトリの作成
+        let temp_dir = ops.create_temp_directory()?;
+        assert!(temp_dir.exists());
+
+        // ソースファイルの書き込み
+        let file_path = ops.write_source_file(&temp_dir, "test.txt", "test content")?;
+        assert!(file_path.exists());
+        let content = fs::read_to_string(&file_path)
+            .map_err(|e| container_err(format!("ファイルの読み取りに失敗しました: {}", e)))?;
+        assert_eq!(content, "test content");
+
+        // 権限設定
+        assert!(ops.set_permissions(&temp_dir, 0o777).is_ok());
+
+        // 所有者設定
+        let (uid, gid) = ops.get_current_user_ids();
+        assert!(uid.is_root() || !uid.is_root());
+        assert!(gid.is_root() || !gid.is_root());
+
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/state/validation.rs b/src/docker/state/validation.rs
index 2e80dfd..89e4969 100644
--- a/src/docker/state/validation.rs
+++ b/src/docker/state/validation.rs
@@ -1,60 +1,57 @@
-use crate::docker::error::state_err;
 use crate::error::Result;
-use super::ContainerState;
+use super::types::ContainerState;
+use crate::docker::error::docker_err;
 
+#[allow(dead_code)]
 pub async fn validate_transition(current: &ContainerState, new: &ContainerState) -> Result<()> {
+    validate_container_id(current, new)?;
+    validate_state_transition(current, new)?;
+    Ok(())
+}
+
+#[allow(dead_code)]
+fn validate_container_id(current: &ContainerState, new: &ContainerState) -> Result<()> {
+    match (current.container_id(), new.container_id()) {
+        (Some(current_id), Some(new_id)) if current_id != new_id => {
+            Err(docker_err("コンテナIDが一致しません".to_string()))
+        }
+        _ => Ok(())
+    }
+}
+
+#[allow(dead_code)]
+fn validate_state_transition(current: &ContainerState, new: &ContainerState) -> Result<()> {
     match (current, new) {
         // 初期状態からの遷移
         (ContainerState::Initial, ContainerState::Created { .. }) => Ok(()),
         
         // Created状態からの遷移
         (ContainerState::Created { .. }, ContainerState::Running { .. }) |
-        (ContainerState::Created { .. }, ContainerState::Failed { .. }) => {
-            validate_container_id(current, new)
-        }
+        (ContainerState::Created { .. }, ContainerState::Failed { .. }) => Ok(()),
         
         // Running状態からの遷移
         (ContainerState::Running { .. }, ContainerState::Executing { .. }) |
         (ContainerState::Running { .. }, ContainerState::Stopped { .. }) |
-        (ContainerState::Running { .. }, ContainerState::Failed { .. }) => {
-            validate_container_id(current, new)
-        }
+        (ContainerState::Running { .. }, ContainerState::Failed { .. }) => Ok(()),
         
         // Executing状態からの遷移
         (ContainerState::Executing { .. }, ContainerState::Running { .. }) |
         (ContainerState::Executing { .. }, ContainerState::Stopped { .. }) |
-        (ContainerState::Executing { .. }, ContainerState::Failed { .. }) => {
-            validate_container_id(current, new)
-        }
+        (ContainerState::Executing { .. }, ContainerState::Failed { .. }) => Ok(()),
         
         // 終端状態からの遷移は許可しない
         (ContainerState::Stopped { .. }, _) |
         (ContainerState::Failed { .. }, _) => {
-            Err(state_err(format!(
+            Err(docker_err(format!(
                 "無効な状態遷移: {} -> {}",
                 current, new
             )))
         }
         
         // その他の遷移は無効
-        _ => Err(state_err(format!(
+        _ => Err(docker_err(format!(
             "無効な状態遷移: {} -> {}",
             current, new
         ))),
     }
-}
-
-fn validate_container_id(current: &ContainerState, new: &ContainerState) -> Result<()> {
-    let current_id = current.container_id();
-    let new_id = new.container_id();
-    
-    if current_id != new_id {
-        Err(state_err(format!(
-            "コンテナIDが一致しません: {} != {}",
-            current_id.unwrap_or("なし"),
-            new_id.unwrap_or("なし")
-        )))
-    } else {
-        Ok(())
-    }
 } 
\ No newline at end of file
diff --git a/src/test/mod.rs b/src/test/mod.rs
index 96bd1d4..d662cf3 100644
--- a/src/test/mod.rs
+++ b/src/test/mod.rs
@@ -19,7 +19,8 @@ pub fn load_test_cases(test_dir: &PathBuf) -> Result<Vec<TestCase>> {
         let path = entry.path();
 
         if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-            let test_file = path.to_str().unwrap();
+            let test_file = path.to_str()
+                .ok_or_else(|| config_err("テストファイルのパスが無効です".to_string()))?;
             let expected_path = PathBuf::from(test_file).with_extension("out");
             if !expected_path.exists() {
                 return Err(config_err(format!("期待値ファイルが存在しません: {:?}", expected_path)));
@@ -40,5 +41,27 @@ pub fn load_test_cases(test_dir: &PathBuf) -> Result<Vec<TestCase>> {
 
 #[cfg(test)]
 mod tests {
-    // テストの実装
+    use super::*;
+    use std::fs;
+    use tempfile::TempDir;
+
+    #[test]
+    fn test_load_test_cases() -> Result<()> {
+        let temp_dir = TempDir::new()
+            .map_err(|e| config_err(format!("一時ディレクトリの作成に失敗しました: {}", e)))?;
+        let test_dir = temp_dir.path().to_path_buf();
+
+        // テストケースファイルの作成
+        fs::write(test_dir.join("test1.in"), "input1")
+            .map_err(|e| config_err(format!("テストファイルの作成に失敗しました: {}", e)))?;
+        fs::write(test_dir.join("test1.out"), "output1")
+            .map_err(|e| config_err(format!("テストファイルの作成に失敗しました: {}", e)))?;
+
+        let test_cases = load_test_cases(&test_dir)?;
+        assert_eq!(test_cases.len(), 1);
+        assert_eq!(test_cases[0].input, "input1");
+        assert_eq!(test_cases[0].expected, "output1");
+
+        Ok(())
+    }
 } 
\ No newline at end of file
