diff --git a/agent/diff-review.do b/agent/diff-review.do
index 51fa1a8..b1d0c32 100644
--- a/agent/diff-review.do
+++ b/agent/diff-review.do
@@ -1,6 +1,6 @@
 date +%Y%m%d%H%M%Sを実行
 tree ./ を実行
-git diff develop > agent/.diff-review/yyyymmddhhmm.txt
+git diff develop > agent/.diff-review/yyyymmddhhmm_diff.txt
 を実行し、変更点を確認する。
 
 もし、重要な機能を削除しているのであれば作業を中断、今回の作業結果を作成されたファイルに追記する
@@ -11,4 +11,4 @@ cargo checkを行い、エラーがないか確認する。エラーがあれば
 
 追加された機能について、実装が非効率になっていないか確認する。非効率な点があれば、作業を中断。
 
-今回の作業結果を作成されたファイルの先頭に追記する
\ No newline at end of file
+今回の作業結果をagent/.diff-review/yyyymmddhhmm_review.txtに記載
\ No newline at end of file
diff --git a/src/contest/parse.rs b/src/contest/parse.rs
index dbcb8ac..13b603a 100644
--- a/src/contest/parse.rs
+++ b/src/contest/parse.rs
@@ -20,6 +20,8 @@ pub enum ParseError {
     InvalidCommand(String),
     ConfigError(ConfigError),
     MissingSection(String),
+    EmptyCommand,
+    UnknownCommand(String),
 }
 
 impl std::fmt::Display for ParseError {
@@ -28,6 +30,8 @@ impl std::fmt::Display for ParseError {
             ParseError::InvalidCommand(msg) => write!(f, "無効なコマンド: {}", msg),
             ParseError::ConfigError(err) => write!(f, "設定エラー: {}", err),
             ParseError::MissingSection(msg) => write!(f, "設定セクションが見つかりません: {}", msg),
+            ParseError::EmptyCommand => write!(f, "コマンドが空です"),
+            ParseError::UnknownCommand(cmd) => write!(f, "未知のコマンド: {}", cmd),
         }
     }
 }
@@ -132,43 +136,25 @@ impl NameResolver {
         Ok(None)
     }
 
-    pub fn resolve(&self, input: &str) -> Result<ResolvedCommand, ParseError> {
-        // 空白の正規化と分割
-        let tokens: Vec<&str> = input
-            .split_whitespace()
-            .collect();
-
+    pub fn parse_command(&self, tokens: &[&str]) -> Result<(CommandType, HashMap<String, String>), ParseError> {
         if tokens.is_empty() {
-            return Err(ParseError::InvalidCommand("コマンドが空です".to_string()));
+            return Err(ParseError::EmptyCommand);
         }
 
-        // コマンドの解決
-        let mut commands = Vec::new();
         let mut current_pos = 0;
-
-        while current_pos < tokens.len() {
-            let token = tokens[current_pos].to_lowercase();
-            if let Some(command) = self.command_aliases.get(&token) {
-                commands.push(command.name.clone());
-                current_pos += 1;
-            } else {
-                break;
-            }
-        }
-
-        if commands.is_empty() {
-            return Err(ParseError::InvalidCommand("有効なコマンドが見つかりません".to_string()));
-        }
+        let command_type = if let Some(command_type) = self.command_aliases.get(tokens[0]) {
+            current_pos += 1;
+            command_type.clone()
+        } else {
+            return Err(ParseError::UnknownCommand(tokens[0].to_string()));
+        };
 
         // 残りのトークンを収集
-        let mut remaining_tokens: Vec<String> = tokens[current_pos..].iter().map(|&s| s.to_string()).collect();
+        let remaining_tokens: Vec<String> = tokens[current_pos..].iter().map(|&s| s.to_string()).collect();
         let mut args = HashMap::new();
 
         // 言語とサイトの解決
-        let mut i = 0;
-        while i < remaining_tokens.len() {
-            let mut token_resolved = false;
-            
+        for (i, token) in remaining_tokens.iter().enumerate() {
             for (setting_name, setting_value) in &self.settings {
                 if setting_name == "contest" || setting_name == "problem" {
                     continue;
@@ -176,30 +162,15 @@ impl NameResolver {
 
                 if let Some(resolved_value) = self.try_resolve_setting(
                     setting_value,
-                    &remaining_tokens[i],
+                    token,
                 )? {
                     args.insert(setting_name.clone(), resolved_value);
-                    remaining_tokens.remove(i);
-                    token_resolved = true;
                     break;
                 }
             }
-
-            if !token_resolved {
-                i += 1;
-            }
-        }
-
-        // コンテストと問題の解決
-        if remaining_tokens.len() >= 2 {
-            args.insert("contest".to_string(), remaining_tokens[0].clone());
-            args.insert("problem".to_string(), remaining_tokens[1].clone());
-        } else if !remaining_tokens.is_empty() {
-            // 解決できなかったトークンは問題IDとして扱う
-            args.insert("problem_id".to_string(), remaining_tokens.join(" "));
         }
 
-        Ok(ResolvedCommand { commands, args })
+        Ok((command_type, args))
     }
 }
 
diff --git a/src/fs/manager.rs b/src/fs/manager.rs
index 693a174..64f2dd4 100644
--- a/src/fs/manager.rs
+++ b/src/fs/manager.rs
@@ -16,7 +16,7 @@ impl FileManager {
     pub fn read_file(&self, path: impl AsRef<Path>) -> Result<String> {
         let path = path.as_ref();
         if !path.exists() {
-            return Err(not_found_err(path.display().to_string()));
+            return Err(not_found_err(path.to_string_lossy().to_string()));
         }
         std::fs::read_to_string(path)
             .map_err(|e| io_err(e, format!("ファイルの読み込みに失敗: {}", path.display())))
@@ -24,12 +24,19 @@ impl FileManager {
 
     pub fn write_file(&self, path: impl AsRef<Path>, content: impl AsRef<str>) -> Result<()> {
         let path = path.as_ref();
+        if let Some(parent) = path.parent() {
+            std::fs::create_dir_all(parent)
+                .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", parent.display())))?;
+        }
         std::fs::write(path, content.as_ref())
             .map_err(|e| io_err(e, format!("ファイルの書き込みに失敗: {}", path.display())))
     }
 
     pub fn create_dir(&self, path: impl AsRef<Path>) -> Result<()> {
         let path = path.as_ref();
+        if path.exists() {
+            return Ok(());
+        }
         std::fs::create_dir_all(path)
             .map_err(|e| io_err(e, format!("ディレクトリの作成に失敗: {}", path.display())))
     }
