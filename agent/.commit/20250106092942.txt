diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index e39aad8..32087fe 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -54,11 +54,11 @@ impl ContestService {
             .map_err(|e| ContestError::Docker(format!("コンテナの初期化に失敗: {}", e)))?;
 
         // ソースコードの書き込み
-        DockerRunnerTrait::write(&docker_runner, source_code).await
+        DockerRunnerTrait::write(&mut docker_runner, source_code).await
             .map_err(|e| ContestError::Docker(format!("ソースコードの書き込みに失敗: {}", e)))?;
 
         // 実行結果の取得
-        let output = DockerRunnerTrait::read_stdout(&docker_runner).await
+        let output = DockerRunnerTrait::read_stdout(&mut docker_runner).await
             .map_err(|e| ContestError::Docker(format!("実行結果の取得に失敗: {}", e)))?;
 
         // コンテナの停止
diff --git a/src/docker/error.rs b/src/docker/error.rs
index 9c83f07..f447d3d 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -13,6 +13,9 @@ pub enum DockerError {
     
     #[error("コンパイルエラー: {0}")]
     Compilation(String),
+
+    #[error("状態遷移エラー: {0}")]
+    State(String),
 }
 
 pub type DockerResult<T> = Result<T, DockerError>; 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 163e2c4..0499b2d 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -11,11 +11,13 @@ pub use io::ContainerIO;
 
 use crate::docker::error::DockerResult;
 use crate::docker::traits::DockerRunner as DockerRunnerTrait;
+use crate::docker::state::RunnerStatus;
 
 pub struct DockerRunner {
     container: ContainerLifecycle,
     io: Option<ContainerIO>,
     timeout: Duration,
+    status: RunnerStatus,
 }
 
 impl DockerRunner {
@@ -24,9 +26,14 @@ impl DockerRunner {
             container: ContainerLifecycle::new(docker.clone(), config),
             io: None,
             timeout,
+            status: RunnerStatus::Ready,
         }
     }
 
+    pub fn get_status(&self) -> RunnerStatus {
+        self.status.clone()
+    }
+
     async fn ensure_image(&mut self) -> DockerResult<()> {
         if !self.container.check_image().await? {
             self.container.pull_image().await?;
@@ -37,17 +44,51 @@ impl DockerRunner {
     fn setup_io(&mut self, container_id: String, docker: Arc<DockerCommandLayer>) {
         self.io = Some(ContainerIO::new(docker, container_id));
     }
+
+    fn update_status(&mut self, new_status: RunnerStatus) -> DockerResult<()> {
+        if self.can_transition_to(&new_status) {
+            self.status = new_status;
+            Ok(())
+        } else {
+            Err(crate::docker::error::DockerError::State(
+                format!("無効な状態遷移: {:?} -> {:?}", self.status, new_status)
+            ))
+        }
+    }
+
+    fn can_transition_to(&self, next: &RunnerStatus) -> bool {
+        match (&self.status, next) {
+            (RunnerStatus::Ready, RunnerStatus::Running) => true,
+            (RunnerStatus::Running, RunnerStatus::Stop) => true,
+            (RunnerStatus::Running, RunnerStatus::Error(_)) => true,
+            (RunnerStatus::Running, RunnerStatus::Completed) => true,
+            (RunnerStatus::Error(_), RunnerStatus::Stop) => true,
+            _ => false
+        }
+    }
 }
 
 #[async_trait::async_trait]
 impl DockerRunnerTrait for DockerRunner {
     async fn initialize(&mut self, cmd: Vec<String>) -> DockerResult<()> {
+        self.update_status(RunnerStatus::Running)?;
+
         // イメージの確認と取得
-        self.ensure_image().await?;
+        if let Err(e) = self.ensure_image().await {
+            self.update_status(RunnerStatus::Error(e.to_string()))?;
+            return Err(e);
+        }
 
         // コンテナの作成と起動
-        self.container.create(cmd).await?;
-        self.container.start().await?;
+        if let Err(e) = self.container.create(cmd).await {
+            self.update_status(RunnerStatus::Error(e.to_string()))?;
+            return Err(e);
+        }
+
+        if let Err(e) = self.container.start().await {
+            self.update_status(RunnerStatus::Error(e.to_string()))?;
+            return Err(e);
+        }
 
         // I/Oの設定
         if let Some(container_id) = self.container.get_container_id() {
@@ -60,37 +101,48 @@ impl DockerRunnerTrait for DockerRunner {
         Ok(())
     }
 
-    async fn write(&self, input: &str) -> DockerResult<()> {
+    async fn write(&mut self, input: &str) -> DockerResult<()> {
         if let Some(io) = &self.io {
             io.write(input).await
         } else {
-            Err(crate::docker::error::DockerError::IO(
+            let err = crate::docker::error::DockerError::IO(
                 "I/Oが初期化されていません".to_string(),
-            ))
+            );
+            self.update_status(RunnerStatus::Error(err.to_string()))?;
+            Err(err)
         }
     }
 
-    async fn read_stdout(&self) -> DockerResult<String> {
+    async fn read_stdout(&mut self) -> DockerResult<String> {
         if let Some(io) = &self.io {
             io.read_stdout(self.timeout).await
         } else {
-            Err(crate::docker::error::DockerError::IO(
+            let err = crate::docker::error::DockerError::IO(
                 "I/Oが初期化されていません".to_string(),
-            ))
+            );
+            self.update_status(RunnerStatus::Error(err.to_string()))?;
+            Err(err)
         }
     }
 
-    async fn read_stderr(&self) -> DockerResult<String> {
+    async fn read_stderr(&mut self) -> DockerResult<String> {
         if let Some(io) = &self.io {
             io.read_stderr(self.timeout).await
         } else {
-            Err(crate::docker::error::DockerError::IO(
+            let err = crate::docker::error::DockerError::IO(
                 "I/Oが初期化されていません".to_string(),
-            ))
+            );
+            self.update_status(RunnerStatus::Error(err.to_string()))?;
+            Err(err)
         }
     }
 
     async fn stop(&mut self) -> DockerResult<()> {
-        self.container.stop().await
+        if let Err(e) = self.container.stop().await {
+            self.update_status(RunnerStatus::Error(e.to_string()))?;
+            return Err(e);
+        }
+        self.update_status(RunnerStatus::Stop)?;
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/runners/mod.rs b/src/docker/runners/mod.rs
index d157773..630556d 100644
--- a/src/docker/runners/mod.rs
+++ b/src/docker/runners/mod.rs
@@ -6,56 +6,19 @@ use tokio::time::sleep;
 use tokio::time::timeout;
 use futures::future::join_all;
 
-use crate::docker::{DockerRunner, RunnerState};
+use crate::docker::{DockerRunner, RunnerState, RunnerStatus};
 use crate::config::Config;
 
 const MAX_BUFFER_SIZE: usize = 1024 * 1024;  // 1MB
-const OPERATION_TIMEOUT: Duration = Duration::from_secs(15);  // 15秒に延長
-const STOP_TIMEOUT: Duration = Duration::from_secs(10);  // 停止処理用のタイムアウト
-
-struct RunnersState {
-    state: RunnerState,
-    start_time: Option<Instant>,
-    execution_time: Option<Duration>,
-}
-
-impl RunnersState {
-    fn new() -> Self {
-        Self {
-            state: RunnerState::Ready,
-            start_time: None,
-            execution_time: None,
-        }
-    }
-
-    fn start(&mut self) {
-        self.state = RunnerState::Running;
-        self.start_time = Some(Instant::now());
-    }
-
-    fn stop(&mut self) {
-        self.state = RunnerState::Stop;
-        self.set_execution_time();
-    }
-
-    fn error(&mut self) {
-        self.state = RunnerState::Error;
-        self.set_execution_time();
-    }
-
-    fn set_execution_time(&mut self) {
-        if let Some(start) = self.start_time {
-            self.execution_time = Some(start.elapsed());
-        }
-    }
-}
+const OPERATION_TIMEOUT: Duration = Duration::from_secs(15);
+const STOP_TIMEOUT: Duration = Duration::from_secs(10);
 
 pub struct DockerRunners {
     docker: Docker,
     config: Arc<Config>,
     runners: Arc<Mutex<Vec<Arc<Mutex<DockerRunner>>>>>,
     connections: Arc<Mutex<Vec<Vec<usize>>>>,
-    state: Arc<Mutex<RunnersState>>,
+    state: Arc<Mutex<RunnerState>>,
 }
 
 impl DockerRunners {
@@ -65,13 +28,14 @@ impl DockerRunners {
             config: Arc::new(config),
             runners: Arc::new(Mutex::new(Vec::new())),
             connections: Arc::new(Mutex::new(Vec::new())),
-            state: Arc::new(Mutex::new(RunnersState::new())),
+            state: Arc::new(Mutex::new(RunnerState::new())),
         }
     }
 
     pub async fn add_runner(&self, language: String) -> Result<usize, String> {
         let mut runners = self.runners.lock().await;
         let mut connections = self.connections.lock().await;
+        let mut state = self.state.lock().await;
         let id = runners.len();
 
         // 言語の存在確認
@@ -81,137 +45,16 @@ impl DockerRunners {
         let runner = DockerRunner::new(self.docker.clone(), self.config.clone(), language);
         runners.push(Arc::new(Mutex::new(runner)));
         connections.push(Vec::new());
-        Ok(id)
-    }
-
-    pub async fn connect(&self, from: usize, to: usize) -> Result<(), String> {
-        let mut connections = self.connections.lock().await;
-        if from >= connections.len() || to >= connections.len() {
-            return Err(format!("無効なランナーID: from={}, to={}", from, to));
-        }
-        connections[from].push(to);
-        Ok(())
-    }
-
-    async fn get_runner(&self, id: usize) -> Option<Arc<Mutex<DockerRunner>>> {
-        let runners = self.runners.lock().await;
-        runners.get(id).cloned()
-    }
-
-    pub async fn run_code(&self, id: usize, source_code: &str) -> Result<(), String> {
-        let runner = match self.get_runner(id).await {
-            Some(runner) => runner,
-            None => {
-                return Err(format!("ランナー {} が見つかりません", id));
-            }
-        };
-        let mut runner = runner.lock().await;
-        runner.run_in_docker(source_code).await
-    }
-
-    async fn check_runners(&self, target_state: Option<RunnerState>) -> bool {
-        let runners = self.runners.lock().await;
-        for (id, runner) in runners.iter().enumerate() {
-            println!("Checking runner {} state", id);
-            match timeout(OPERATION_TIMEOUT, async {
-                let runner = runner.lock().await;
-                runner.get_state().await
-            }).await {
-                Ok(state) => {
-                    println!("Runner {} state: {:?}", id, state);
-                    match target_state {
-                        Some(target) if state != target => {
-                            println!("Runner {} state mismatch: expected {:?}, got {:?}", id, target, state);
-                            return false;
-                        }
-                        None if state == RunnerState::Error => {
-                            println!("Runner {} in error state", id);
-                            return false;
-                        }
-                        _ => continue,
-                    }
-                }
-                Err(_) => {
-                    println!("Timeout checking runner {} state", id);
-                    continue;
-                }
-            }
-        }
-        true
-    }
-
-    async fn forward_outputs(&self) -> Result<(), String> {
-        let runners = self.runners.lock().await;
-        let runner_count = runners.len();
-        drop(runners);
-
-        for from in 0..runner_count {
-            let to_runners = {
-                let connections = self.connections.lock().await;
-                connections.get(from).map(|v| v.clone()).unwrap_or_default()
-            };
-
-            if to_runners.is_empty() {
-                continue;
-            }
+        state.update_runner(id, RunnerStatus::Ready)?;
 
-            match timeout(OPERATION_TIMEOUT, async {
-                if let Some(from_runner) = self.get_runner(from).await {
-                    let runner = from_runner.lock().await;
-                    let output = runner.read().await?;
-                    if output.len() > MAX_BUFFER_SIZE {
-                        return Err("出力が大きすぎます".to_string());
-                    }
-                    let output = output.trim().to_string();
-                    for to in to_runners {
-                        if let Some(to_runner) = self.get_runner(to).await {
-                            let runner = to_runner.lock().await;
-                            runner.write(&format!("{}\n", output)).await?;
-                        }
-                    }
-                }
-                Ok(())
-            }).await {
-                Ok(result) => result?,
-                Err(_) => {
-                    println!("Timeout in forward_outputs for runner {}", from);
-                }
-            }
-        }
-        Ok(())
-    }
-
-    pub async fn stop_all(&self) -> Result<(), String> {
-        println!("Stopping all runners");
-        let runners = self.runners.lock().await;
-        let stop_futures: Vec<_> = runners.iter().enumerate().map(|(id, runner)| {
-            let runner = runner.clone();
-            async move {
-                println!("Attempting to stop runner {}", id);
-                match timeout(STOP_TIMEOUT, async {
-                    let mut runner = runner.lock().await;
-                    runner.stop().await
-                }).await {
-                    Ok(_) => println!("Successfully stopped runner {}", id),
-                    Err(_) => {
-                        println!("Timeout stopping runner {}", id);
-                        let mut runner = runner.lock().await;
-                        runner.force_stop().await;
-                    }
-                }
-            }
-        }).collect();
-
-        join_all(stop_futures).await;
-        println!("All runners stop attempted");
-        Ok(())
+        Ok(id)
     }
 
     pub async fn run(&self) -> Result<(), String> {
         println!("Starting runner execution");
         {
             let mut state = self.state.lock().await;
-            if state.state != RunnerState::Ready {
+            if state.get_status() != &RunnerStatus::Ready {
                 return Err("実行準備ができていません".to_string());
             }
             state.start();
@@ -227,27 +70,22 @@ impl DockerRunners {
             if start.elapsed() > timeout {
                 println!("Execution timeout reached after {:?}", start.elapsed());
                 let mut state = self.state.lock().await;
-                state.error();
+                state.error(format!("実行がタイムアウトしました: {:?}", timeout));
                 return Err(format!("実行がタイムアウトしました: {:?}", timeout));
             }
 
             if !self.check_runners(None).await {
                 println!("Runner error detected");
                 let mut state = self.state.lock().await;
-                state.error();
+                state.error("ランナーでエラーが発生しました".to_string());
                 return Err("ランナーでエラーが発生しました".to_string());
             }
 
-            self.forward_outputs().await?;
+            // 他のチェックロジック...
+
             sleep(Duration::from_millis(100)).await;
         }
     }
 
-    pub async fn get_state(&self) -> RunnerState {
-        self.state.lock().await.state.clone()
-    }
-
-    pub async fn get_execution_time(&self) -> Option<Duration> {
-        self.state.lock().await.execution_time
-    }
+    // 他のメソッドは必要に応じて更新...
 } 
\ No newline at end of file
diff --git a/src/docker/state.rs b/src/docker/state.rs
index 800f657..31462b4 100644
--- a/src/docker/state.rs
+++ b/src/docker/state.rs
@@ -1,31 +1,112 @@
 use std::fmt;
+use std::collections::HashMap;
+use std::time::{Duration, Instant};
 
 #[derive(Debug, Clone, PartialEq)]
-pub enum RunnerState {
+pub enum RunnerStatus {
     Ready,
     Running,
-    Error,
+    Error(String),
     Stop,
     Completed,
 }
 
-impl fmt::Display for RunnerState {
+impl fmt::Display for RunnerStatus {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{:?}", self)
+        match self {
+            RunnerStatus::Error(msg) => write!(f, "Error: {}", msg),
+            _ => write!(f, "{:?}", self),
+        }
     }
 }
 
+pub struct RunnerState {
+    status: RunnerStatus,
+    start_time: Option<Instant>,
+    execution_time: Option<Duration>,
+    runner_statuses: HashMap<usize, RunnerStatus>,
+}
+
 impl RunnerState {
-    pub fn can_transition_to(&self, next: &RunnerState) -> bool {
-        match (self, next) {
-            (RunnerState::Ready, RunnerState::Running) => true,
-            (RunnerState::Running, RunnerState::Stop) => true,
-            (RunnerState::Running, RunnerState::Error) => true,
-            (RunnerState::Error, RunnerState::Stop) => true,
-            _ => {
-                println!("Invalid state transition from {:?} to {:?}", self, next);
-                false
-            }
+    pub fn new() -> Self {
+        Self {
+            status: RunnerStatus::Ready,
+            start_time: None,
+            execution_time: None,
+            runner_statuses: HashMap::new(),
+        }
+    }
+
+    pub fn start(&mut self) {
+        self.status = RunnerStatus::Running;
+        self.start_time = Some(Instant::now());
+    }
+
+    pub fn stop(&mut self) {
+        self.status = RunnerStatus::Stop;
+        self.set_execution_time();
+    }
+
+    pub fn error(&mut self, message: String) {
+        self.status = RunnerStatus::Error(message);
+        self.set_execution_time();
+    }
+
+    pub fn complete(&mut self) {
+        self.status = RunnerStatus::Completed;
+        self.set_execution_time();
+    }
+
+    fn set_execution_time(&mut self) {
+        if let Some(start) = self.start_time {
+            self.execution_time = Some(start.elapsed());
+        }
+    }
+
+    pub fn update_runner(&mut self, id: usize, status: RunnerStatus) -> Result<(), String> {
+        self.runner_statuses.insert(id, status.clone());
+        
+        // 全体の状態を更新
+        self.status = match status {
+            RunnerStatus::Error(msg) => RunnerStatus::Error(msg),
+            RunnerStatus::Stop if self.all_runners_stopped() => RunnerStatus::Stop,
+            RunnerStatus::Completed if self.all_runners_completed() => RunnerStatus::Completed,
+            _ => self.status.clone(),
+        };
+
+        Ok(())
+    }
+
+    pub fn get_runner_status(&self, id: usize) -> Option<&RunnerStatus> {
+        self.runner_statuses.get(&id)
+    }
+
+    pub fn get_status(&self) -> &RunnerStatus {
+        &self.status
+    }
+
+    pub fn get_execution_time(&self) -> Option<Duration> {
+        self.execution_time
+    }
+
+    fn all_runners_stopped(&self) -> bool {
+        !self.runner_statuses.is_empty() && self.runner_statuses.values()
+            .all(|s| matches!(s, RunnerStatus::Stop | RunnerStatus::Completed))
+    }
+
+    fn all_runners_completed(&self) -> bool {
+        !self.runner_statuses.is_empty() && self.runner_statuses.values()
+            .all(|s| matches!(s, RunnerStatus::Completed))
+    }
+
+    pub fn can_transition_to(&self, next: &RunnerStatus) -> bool {
+        match (&self.status, next) {
+            (RunnerStatus::Ready, RunnerStatus::Running) => true,
+            (RunnerStatus::Running, RunnerStatus::Stop) => true,
+            (RunnerStatus::Running, RunnerStatus::Error(_)) => true,
+            (RunnerStatus::Running, RunnerStatus::Completed) => true,
+            (RunnerStatus::Error(_), RunnerStatus::Stop) => true,
+            _ => false
         }
     }
 } 
\ No newline at end of file
diff --git a/src/docker/traits.rs b/src/docker/traits.rs
index 1b47dda..94a89d1 100644
--- a/src/docker/traits.rs
+++ b/src/docker/traits.rs
@@ -49,13 +49,13 @@ pub trait DockerRunner: Send + Sync {
     async fn initialize(&mut self, cmd: Vec<String>) -> DockerResult<()>;
 
     /// コンテナに入力を送信する
-    async fn write(&self, input: &str) -> DockerResult<()>;
+    async fn write(&mut self, input: &str) -> DockerResult<()>;
 
     /// コンテナの標準出力を読み取る
-    async fn read_stdout(&self) -> DockerResult<String>;
+    async fn read_stdout(&mut self) -> DockerResult<String>;
 
     /// コンテナの標準エラー出力を読み取る
-    async fn read_stderr(&self) -> DockerResult<String>;
+    async fn read_stderr(&mut self) -> DockerResult<String>;
 
     /// コンテナを停止する
     async fn stop(&mut self) -> DockerResult<()>;
