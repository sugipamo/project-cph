diff --git a/src/docker/executor.rs b/src/docker/executor.rs
index d631fdc..98ddc93 100644
--- a/src/docker/executor.rs
+++ b/src/docker/executor.rs
@@ -160,11 +160,11 @@ impl MockDockerExecutor {
 #[async_trait::async_trait]
 impl DockerCommandExecutor for MockDockerExecutor {
     async fn check_image(&self, _image: &str) -> DockerResult<bool> {
-        Ok(!self.should_fail)
+        Ok(true)
     }
 
     async fn pull_image(&self, _image: &str) -> DockerResult<bool> {
-        Ok(!self.should_fail)
+        Ok(true)
     }
 
     async fn run_container(
@@ -174,13 +174,21 @@ impl DockerCommandExecutor for MockDockerExecutor {
         _memory_limit: u32,
         _mount_source: &str,
         _mount_target: &str,
-        _command: &str,
+        command: &str,
         _timeout_seconds: u32,
     ) -> DockerResult<String> {
         if self.should_fail {
             Err(DockerError::Runtime("モックエラー".to_string()))
         } else {
-            Ok("モック出力".to_string())
+            if command.contains("main.rs") {
+                Ok("Hello from Rust!\n".to_string())
+            } else if command.contains("main.py") {
+                Ok("Hello from Python!\n".to_string())
+            } else if command.contains("main.cpp") {
+                Ok("Hello from C++!\n".to_string())
+            } else {
+                Ok("実行成功\n".to_string())
+            }
         }
     }
 
@@ -194,6 +202,6 @@ impl DockerCommandExecutor for MockDockerExecutor {
         _image: &str,
         _mount_point: &str,
     ) -> DockerResult<String> {
-        Ok("モックディレクトリ一覧".to_string())
+        Ok("total 4\ndrwxr-xr-x 2 root root 4096 Jan 1 00:00 .\n".to_string())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/fs.rs b/src/docker/fs.rs
index 73f4d93..181f174 100644
--- a/src/docker/fs.rs
+++ b/src/docker/fs.rs
@@ -56,27 +56,44 @@ pub struct MockDockerFileManager {
 #[cfg(test)]
 impl MockDockerFileManager {
     pub fn new() -> Self {
-        Self {
-            temp_dir: PathBuf::from("/mock/temp/dir"),
+        let temp_dir = std::env::temp_dir().join("mock-cph-test");
+        if temp_dir.exists() {
+            let _ = fs::remove_dir_all(&temp_dir);
         }
+        let _ = fs::create_dir_all(&temp_dir);
+        Self { temp_dir }
     }
 }
 
 #[cfg(test)]
 impl DockerFileManager for MockDockerFileManager {
     fn create_temp_directory(&self) -> DockerResult<PathBuf> {
-        Ok(self.temp_dir.clone())
+        let dir = self.temp_dir.join(Uuid::new_v4().to_string());
+        fs::create_dir_all(&dir)?;
+        Ok(dir)
     }
 
-    fn write_source_file(&self, dir: &Path, filename: &str, _content: &str) -> DockerResult<PathBuf> {
-        Ok(dir.join(filename))
+    fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf> {
+        let file_path = dir.join(filename);
+        fs::create_dir_all(dir)?;
+        fs::write(&file_path, content)?;
+        Ok(file_path)
     }
 
-    fn set_permissions(&self, _path: &Path, _mode: u32) -> DockerResult<()> {
-        Ok(())
+    fn set_permissions(&self, path: &Path, _mode: u32) -> DockerResult<()> {
+        if path.exists() {
+            Ok(())
+        } else {
+            Err(crate::docker::error::DockerError::Runtime(
+                format!("Path does not exist: {:?}", path)
+            ))
+        }
     }
 
-    fn cleanup(&self, _dir: &Path) -> DockerResult<()> {
+    fn cleanup(&self, dir: &Path) -> DockerResult<()> {
+        if dir.exists() {
+            fs::remove_dir_all(dir)?;
+        }
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index f668f20..d7a9172 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -7,6 +7,7 @@ use crate::docker::state::RunnerState;
 use crate::docker::config::DockerConfig;
 use crate::docker::fs::{DockerFileManager, DefaultDockerFileManager};
 use crate::docker::executor::{DockerCommandExecutor, DefaultDockerExecutor};
+use std::fs;
 
 pub struct DockerRunner {
     config: DockerConfig,
@@ -52,27 +53,34 @@ impl DockerRunner {
 
         // 一時ディレクトリの作成
         let temp_dir = self.file_manager.create_temp_directory()?;
+        let compile_dir = temp_dir.join("compile");
+        fs::create_dir_all(&compile_dir)?;
         
         // ソースファイルの作成
         let source_file = self.file_manager.write_source_file(
-            &temp_dir,
+            &compile_dir,
             &format!("main.{}", self.config.extension()),
             source_code,
         )?;
         
         // ファイルのパーミッション設定
         self.file_manager.set_permissions(&source_file, 0o644)?;
-        self.file_manager.set_permissions(&temp_dir, 0o777)?;
+        self.file_manager.set_permissions(&compile_dir, 0o777)?;
 
         // コマンドの構築
         let command = if let Some(compile_cmd) = self.config.compile_cmd() {
             format!(
-                "{} && {}",
+                "cd {} && {} && {}",
+                self.config.mount_point(),
                 compile_cmd.join(" "),
                 self.config.run_cmd().join(" ")
             )
         } else {
-            self.config.run_cmd().join(" ")
+            format!(
+                "cd {} && {}",
+                self.config.mount_point(),
+                self.config.run_cmd().join(" ")
+            )
         };
 
         // コンテナの実行
@@ -81,22 +89,26 @@ impl DockerRunner {
             &container_name,
             self.config.image(),
             self.config.memory_limit(),
-            temp_dir.to_str().unwrap(),
+            compile_dir.to_str().unwrap(),
             self.config.mount_point(),
             &command,
             self.config.timeout_seconds(),
         ).await;
 
         // 一時ディレクトリの削除
-        self.file_manager.cleanup(&temp_dir)?;
+        let _ = self.file_manager.cleanup(&temp_dir);
 
         // 状態の更新と結果の返却
-        *self.state.lock().await = match &result {
-            Ok(_) => RunnerState::Completed,
-            Err(_) => RunnerState::Error,
-        };
-
-        result
+        match &result {
+            Ok(_) => {
+                *self.state.lock().await = RunnerState::Completed;
+                result
+            }
+            Err(_) => {
+                *self.state.lock().await = RunnerState::Error;
+                result
+            }
+        }
     }
 
     pub async fn cleanup(&mut self) -> DockerResult<()> {
@@ -135,8 +147,11 @@ mod tests {
             state: Arc::new(Mutex::new(RunnerState::Ready)),
         };
 
-        let result = runner.run_in_docker("fn main() {}").await;
+        let result = runner.run_in_docker("fn main() { println!(\"Hello from Rust!\"); }").await;
         assert!(result.is_ok());
+        if let Ok(output) = result {
+            assert!(output.contains("Hello from Rust!"));
+        }
         assert_eq!(runner.get_state().await, RunnerState::Completed);
     }
 
diff --git a/tests/docker/runner_test.rs b/tests/docker/runner_test.rs
index 08202b0..7450517 100644
--- a/tests/docker/runner_test.rs
+++ b/tests/docker/runner_test.rs
@@ -3,6 +3,17 @@ use tokio::test;
 use cph::config::Config;
 use cph::docker::{DockerRunner, DockerError};
 use std::fs;
+use std::path::PathBuf;
+
+fn setup() -> PathBuf {
+    let temp_dir = std::env::temp_dir().join("cph-test");
+    fs::create_dir_all(&temp_dir).unwrap();
+    temp_dir
+}
+
+fn teardown(temp_dir: &PathBuf) {
+    let _ = fs::remove_dir_all(temp_dir);
+}
 
 // Dockerデーモンが利用可能かチェックする
 fn check_docker_available() -> bool {
@@ -33,7 +44,7 @@ async fn test_docker_available() {
 
 #[tokio::test]
 async fn test_rust_runner() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -53,6 +64,8 @@ async fn test_rust_runner() {
             panic!("実行に失敗しました");
         }
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
