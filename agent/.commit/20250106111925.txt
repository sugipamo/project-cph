diff --git a/src/docker/runner/default_impl.rs b/src/docker/runner/default_impl.rs
index c5585ca..a7b2c84 100644
--- a/src/docker/runner/default_impl.rs
+++ b/src/docker/runner/default_impl.rs
@@ -9,6 +9,7 @@ use std::collections::HashMap;
 use crate::docker::error::{DockerError, DockerResult};
 use crate::docker::traits::{ContainerManager, IOHandler, CompilationManager};
 use crate::docker::executor::{DockerCommand, DockerCommandExecutor, CommandOutput};
+use crate::docker::runner::io::ContainerIO;
 
 pub struct DefaultContainerManager {
     container_id: String,
@@ -155,70 +156,6 @@ impl ContainerManager for DefaultContainerManager {
     }
 }
 
-pub struct DefaultIOHandler {
-    container_id: String,
-    stdout_buffer: Arc<Mutex<Vec<String>>>,
-    stderr_buffer: Arc<Mutex<Vec<String>>>,
-    stdin_tx: Option<mpsc::Sender<String>>,
-    docker_executor: Arc<dyn DockerCommandExecutor>,
-}
-
-impl DefaultIOHandler {
-    pub fn new(container_id: String, executor: Arc<dyn DockerCommandExecutor>) -> Self {
-        Self {
-            container_id,
-            stdout_buffer: Arc::new(Mutex::new(Vec::new())),
-            stderr_buffer: Arc::new(Mutex::new(Vec::new())),
-            stdin_tx: None,
-            docker_executor: executor,
-        }
-    }
-}
-
-#[async_trait]
-impl IOHandler for DefaultIOHandler {
-    async fn write(&self, input: &str) -> DockerResult<()> {
-        let command = DockerCommand::new("exec")
-            .arg("-i")
-            .arg(&self.container_id)
-            .arg("sh")
-            .arg("-c")
-            .arg(input);
-
-        let output = self.docker_executor.execute(command).await?;
-
-        if output.success {
-            Ok(())
-        } else {
-            Err(DockerError::IO(format!(
-                "入力の送信に失敗しました: {}",
-                output.stderr
-            )))
-        }
-    }
-
-    async fn read_stdout(&self, timeout_duration: Duration) -> DockerResult<String> {
-        let command = DockerCommand::new("logs")
-            .arg(&self.container_id);
-
-        let output = self.docker_executor.execute(command).await?;
-        Ok(output.stdout)
-    }
-
-    async fn read_stderr(&self, timeout_duration: Duration) -> DockerResult<String> {
-        let command = DockerCommand::new("logs")
-            .arg("--stderr")
-            .arg(&self.container_id);
-
-        let output = self.docker_executor.execute(command).await?;
-        Ok(output.stderr)
-    }
-
-    async fn setup_io(&mut self) -> DockerResult<()> {
-        Ok(())
-    }
-}
-
 pub struct DefaultCompilationManager {
     container_id: String,
     working_dir: String,
diff --git a/src/docker/runner/test_helpers.rs b/src/docker/runner/test_helpers.rs
index 8a1b318..0bcaa34 100644
--- a/src/docker/runner/test_helpers.rs
+++ b/src/docker/runner/test_helpers.rs
@@ -1,6 +1,5 @@
 use crate::docker::error::DockerResult;
-use crate::docker::traits::{ContainerManager, IOHandler, CompilationManager};
-use crate::config::Config;
+use crate::docker::traits::{ContainerManager, IOHandler};
 use std::time::Duration;
 use mockall::mock;
 use mockall::predicate::*;
@@ -13,8 +12,7 @@ mock! {
         async fn create_container(&mut self, image: &str, cmd: Vec<String>, working_dir: &str) -> DockerResult<()>;
         async fn start_container(&mut self) -> DockerResult<()>;
         async fn stop_container(&mut self) -> DockerResult<()>;
-        async fn check_image(&self, image: &str) -> DockerResult<bool>;
-        async fn pull_image(&self, image: &str) -> DockerResult<()>;
+        async fn get_container_id(&self) -> DockerResult<String>;
     }
 }
 
@@ -25,76 +23,5 @@ mock! {
         async fn write(&self, input: &str) -> DockerResult<()>;
         async fn read_stdout(&self, timeout: Duration) -> DockerResult<String>;
         async fn read_stderr(&self, timeout: Duration) -> DockerResult<String>;
-        async fn setup_io(&mut self) -> DockerResult<()>;
     }
-}
-
-mock! {
-    pub CompilationManager {}
-    #[async_trait::async_trait]
-    impl CompilationManager for CompilationManager {
-        async fn compile(&mut self, source_code: &str, compile_cmd: Option<Vec<String>>, env_vars: Vec<String>) -> DockerResult<()>;
-        async fn get_compilation_output(&self) -> DockerResult<(String, String)>;
-    }
-}
-
-// テストヘルパー構造体
-pub struct TestHelper {
-    pub container_manager: MockContainerManager,
-    pub io_handler: MockIOHandler,
-    pub compilation_manager: MockCompilationManager,
-}
-
-impl TestHelper {
-    pub fn new() -> Self {
-        Self {
-            container_manager: MockContainerManager::new(),
-            io_handler: MockIOHandler::new(),
-            compilation_manager: MockCompilationManager::new(),
-        }
-    }
-
-    pub fn setup_success_expectations(&mut self) {
-        self.container_manager
-            .expect_check_image()
-            .returning(|_| Ok(true));
-        
-        self.container_manager
-            .expect_create_container()
-            .returning(|_, _, _| Ok(()));
-        
-        self.container_manager
-            .expect_start_container()
-            .returning(|| Ok(()));
-
-        self.io_handler
-            .expect_setup_io()
-            .returning(|| Ok(()));
-        
-        self.io_handler
-            .expect_read_stdout()
-            .returning(|_| Ok("Test output".to_string()));
-        
-        self.io_handler
-            .expect_read_stderr()
-            .returning(|_| Ok("".to_string()));
-    }
-
-    pub fn setup_compilation_expectations(&mut self) {
-        self.compilation_manager
-            .expect_compile()
-            .returning(|_, _, _| Ok(()));
-        
-        self.compilation_manager
-            .expect_get_compilation_output()
-            .returning(|| Ok(("".to_string(), "".to_string())));
-    }
-}
-
-// テスト用の設定ヘルパー
-pub fn create_test_config() -> Config {
-    let mut config = Config::new();
-    config.set("system.docker.timeout_seconds", 30).unwrap();
-    config.set("system.docker.memory_limit", 512).unwrap();
-    config
 } 
\ No newline at end of file
diff --git a/src/docker/runners/mod.rs b/src/docker/runners/mod.rs
index 630556d..33fa3ec 100644
--- a/src/docker/runners/mod.rs
+++ b/src/docker/runners/mod.rs
@@ -63,17 +63,21 @@ impl DockerRunners {
         // タイムアウト設定の取得
         let timeout_seconds = self.config.get::<u64>("system.docker.timeout_seconds")
             .map_err(|e| format!("タイムアウト設定の読み込みに失敗しました: {}", e))?;
-        let timeout = Duration::from_secs(timeout_seconds);
-        let start = Instant::now();
+        let timeout_duration = Duration::from_secs(timeout_seconds);
 
-        loop {
-            if start.elapsed() > timeout {
-                println!("Execution timeout reached after {:?}", start.elapsed());
+        tokio::select! {
+            _ = tokio::time::sleep(timeout_duration) => {
+                println!("Execution timeout reached after {:?}", timeout_duration);
                 let mut state = self.state.lock().await;
-                state.error(format!("実行がタイムアウトしました: {:?}", timeout));
-                return Err(format!("実行がタイムアウトしました: {:?}", timeout));
+                state.error(format!("実行がタイムアウトしました: {:?}", timeout_duration));
+                Err(format!("実行がタイムアウトしました: {:?}", timeout_duration))
             }
+            result = self.run_internal() => result,
+        }
+    }
 
+    async fn run_internal(&self) -> Result<(), String> {
+        loop {
             if !self.check_runners(None).await {
                 println!("Runner error detected");
                 let mut state = self.state.lock().await;
@@ -83,7 +87,7 @@ impl DockerRunners {
 
             // 他のチェックロジック...
 
-            sleep(Duration::from_millis(100)).await;
+            tokio::time::sleep(Duration::from_millis(100)).await;
         }
     }
 
