diff --git a/src/config/config.yaml b/src/config/config.yaml
index 6538340..ae58c0f 100644
--- a/src/config/config.yaml
+++ b/src/config/config.yaml
@@ -4,16 +4,21 @@ system:
   editors:
     - "code"
     - "cursor"
+  docker:
+    timeout_seconds: ${CPH_DOCKER_TIMEOUT-10}
+    memory_limit_mb: ${CPH_DOCKER_MEMORY-256}
+    mount_point: "/workspace"
 
 # 言語設定
 languages:
   default: rust
   # 言語の基本設定をアンカーとして定義
   _base: &lang_base
-    compile: []
-    run: []
     runner:
+      image: ""
       compile_dir: "${CPH_COMPILE_DIR-compile/{name}}"
+      compile: []
+      run: []
       require_files: []
       env_vars: []
 
@@ -31,75 +36,58 @@ languages:
     
     active_contest_yaml: "${CPH_ACTIVE_CONTEST_YAML-active_contest.yaml}"
 
-    docker:
-      timeout_seconds: ${CPH_DOCKER_TIMEOUT-10}
-      memory_limit_mb: ${CPH_DOCKER_MEMORY-256}
-      mount_point: "/compile"
-
-    submit:
-      wait: ${CPH_SUBMIT_WAIT-5}
-      auto_yes: ${CPH_AUTO_YES-false}
-  
     test:
       dir: "${CPH_TEST_DIR-test}"
 
+  # 言語固有の設定
   rust:
     <<: *lang_base
+    name: "rust"
     extension: "rs"
     runner:
-      image: "${CPH_RUST_IMAGE-rust:latest}"
+      image: "rust:latest"
+      compile_dir: "${CPH_COMPILE_DIR-compile/rust}"
       compile: ["rustc", "main.rs"]
       run: ["./main"]
-      require_files: ["Cargo.toml"]
-      env_vars:
-        - "RUST_BACKTRACE=1"
+      require_files: []
+      env_vars: ["RUST_BACKTRACE=1"]
     site_ids:
       _source: "online_judge_tool"
       _fallback:
         atcoder: "5054"  # Rust (rustc 1.70.0)
 
-    templates:
-      patterns:
-        solution: "${CPH_SOLUTION_FILE-src/solution.{extension}}"
-        generator: "${CPH_GENERATOR_FILE-src/generator.{extension}}"
-        tester: "${CPH_TESTER_FILE-src/tester.{extension}}"
-
-  python:
+  cpp:
     <<: *lang_base
-    extension: "py"
+    name: "cpp"
+    extension: "cpp"
     runner:
-      image: "${CPH_PYTHON_IMAGE-python:3.11-slim}"
-      run: ["python", "main.py"]
+      image: "gcc:latest"
+      compile_dir: "${CPH_COMPILE_DIR-compile/cpp}"
+      compile: ["g++", "-std=c++17", "-O2", "main.cpp", "-o", "main"]
+      run: ["./main"]
+      require_files: []
+      env_vars: ["CPLUS_INCLUDE_PATH=/usr/include/c++/9"]
     site_ids:
       _source: "online_judge_tool"
       _fallback:
-        atcoder: "4047"  # Python (CPython 3.11.4)
+        atcoder: "5001"  # C++ (GCC 9.2.1)
 
   pypy:
     <<: *lang_base
+    name: "pypy"
     extension: "py"
     runner:
-      image: "${CPH_PYPY_IMAGE-pypy:latest}"
+      image: "pypy:latest"
+      compile_dir: "${CPH_COMPILE_DIR-compile/pypy}"
+      compile: []
       run: ["pypy3", "main.py"]
+      require_files: []
+      env_vars: []
     site_ids:
       _source: "online_judge_tool"
       _fallback:
         atcoder: "5078"  # Python (PyPy 3.10-v7.3.12)
 
-  cpp:
-    <<: *lang_base
-    extension: "cpp"
-    runner:
-      image: "${CPH_CPP_IMAGE-gcc:latest}"
-      compile: ["g++", "-std=c++17", "-O2", "main.cpp"]
-      run: ["./a.out"]
-      env_vars:
-        - "CPLUS_INCLUDE_PATH=/usr/include/c++/9"
-    site_ids:
-      _source: "online_judge_tool"
-      _fallback:
-        atcoder: "5001"  # C++ (GCC 9.2.1)
-
 # サイト設定
 sites:
   # サイトの基本設定をアンカーとして定義
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 49a24ae..7f49504 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -503,6 +503,40 @@ impl Config {
         config.validate_required_values()?;  // 必須設定値を検証
         Ok(config)
     }
+
+    pub fn get_docker_memory_limit(&self) -> Option<u32> {
+        self.get_raw_value("system.docker.memory_limit_mb")
+            .ok()
+            .and_then(|v| v.as_u64().map(|n| n as u32))
+    }
+
+    pub fn get_docker_timeout(&self) -> Option<u32> {
+        self.get_raw_value("system.docker.timeout_seconds")
+            .ok()
+            .and_then(|v| v.as_u64().map(|n| n as u32))
+    }
+
+    pub fn get_docker_mount_point(&self) -> Option<&str> {
+        self.get_raw_value("system.docker.mount_point")
+            .ok()
+            .and_then(|v| v.as_str())
+    }
+
+    pub fn get_language_config(&self, language: &str) -> Option<&serde_yaml::Value> {
+        self.get_raw_value(&format!("languages.{}", language))
+            .ok()
+    }
+
+    pub fn get_language_runner_config(&self, language: &str) -> Option<&serde_yaml::Value> {
+        self.get_raw_value(&format!("languages.{}.runner", language))
+            .ok()
+    }
+
+    pub fn get_language_extension(&self, language: &str) -> Option<&str> {
+        self.get_raw_value(&format!("languages.{}.extension", language))
+            .ok()
+            .and_then(|v| v.as_str())
+    }
 }
 
 // 基本的な型の実装
diff --git a/src/docker/runner/command.rs b/src/docker/runner/command.rs
index 4d0d4d3..94742c6 100644
--- a/src/docker/runner/command.rs
+++ b/src/docker/runner/command.rs
@@ -5,6 +5,7 @@ use crate::docker::state::RunnerState;
 use std::time::Duration;
 use std::env;
 use tokio::time::timeout;
+use std::os::unix::fs::PermissionsExt;
 
 pub struct DockerCommand {
     container_name: String,
@@ -23,22 +24,82 @@ impl DockerCommand {
         }
     }
 
-    pub async fn run_code(&mut self, image: &str, source_code: &str) -> Result<String, String> {
+    fn ensure_directory_permissions(dir: &std::path::Path) -> Result<(), String> {
+        // ディレクトリのパーミッションを設定
+        let metadata = std::fs::metadata(dir)
+            .map_err(|e| format!("メタデータの取得に失敗しました: {}", e))?;
+        let mut perms = metadata.permissions();
+        perms.set_mode(0o777);
+        std::fs::set_permissions(dir, perms)
+            .map_err(|e| format!("パーミッションの設定に失敗しました: {}", e))?;
+        Ok(())
+    }
+
+    pub async fn run_code(
+        &mut self,
+        image: &str,
+        source_code: &str,
+        _language: &str,
+        compile_dir: &str,
+        compile_cmd: &[String],
+        run_cmd: &[String],
+        mount_point: &str,
+        extension: &str,
+        memory_limit_mb: u32,
+        timeout_seconds: u32,
+    ) -> Result<String, String> {
         // コンテナ名を生成
         let container_name = format!("runner-{}", Uuid::new_v4());
         self.container_name = container_name.clone();
 
-        // 一時ディレクトリを作成
-        let temp_dir = env::temp_dir().join(&container_name);
-        std::fs::create_dir_all(&temp_dir)
-            .map_err(|e| format!("一時ディレクトリの作成に失敗しました: {}", e))?;
+        // 現在のディレクトリを取得
+        let current_dir = env::current_dir()
+            .map_err(|e| format!("カレントディレクトリの取得に失敗しました: {}", e))?;
+
+        // コンパイルディレクトリを作成
+        let absolute_compile_dir = current_dir.join(compile_dir);
+        std::fs::create_dir_all(&absolute_compile_dir)
+            .map_err(|e| format!("コンパイルディレクトリの作成に失敗しました: {}", e))?;
+
+        // ディレクトリのパーミッションを設定
+        Self::ensure_directory_permissions(&absolute_compile_dir)?;
 
         // ソースコードを書き込み
-        let source_file = temp_dir.join("main.rs");
+        let source_file = absolute_compile_dir.join(format!("main.{}", extension));
+        println!("Writing source code to: {}", source_file.display());
         std::fs::write(&source_file, source_code)
             .map_err(|e| format!("ソースコードの書き込みに失敗しました: {}", e))?;
 
-        // Dockerコマンドを構築
+        // ファイルのパーミッションを設定
+        let metadata = std::fs::metadata(&source_file)
+            .map_err(|e| format!("ソースファイルのメタデータの取得に失敗しました: {}", e))?;
+        let mut perms = metadata.permissions();
+        perms.set_mode(0o666);
+        std::fs::set_permissions(&source_file, perms)
+            .map_err(|e| format!("ソースファイルのパーミッションの設定に失敗しました: {}", e))?;
+
+        // ファイルの存在を確認
+        if !source_file.exists() {
+            return Err(format!("ソースファイルが作成されませんでした: {}", source_file.display()));
+        }
+
+        // コンパイルが必要な言語の場合、コンパイルを実行
+        if !compile_cmd.is_empty() {
+            let compile_result = self.compile(
+                image,
+                compile_cmd,
+                &absolute_compile_dir,
+                mount_point,
+                memory_limit_mb,
+                timeout_seconds,
+            ).await;
+
+            if let Err(e) = compile_result {
+                return Err(format!("コンパイルに失敗しました: {}", e));
+            }
+        }
+
+        // 実行コマンドを構築
         let mut command = Command::new("docker");
         command
             .arg("run")
@@ -46,29 +107,27 @@ impl DockerCommand {
             .arg("--name")
             .arg(&container_name)
             .arg("-v")
-            .arg(format!("{}:/code", temp_dir.display()))
+            .arg(format!("{}:{}", absolute_compile_dir.display(), mount_point))
             .arg("-w")
-            .arg("/code")
-            .arg(image)
-            .arg("sh")
-            .arg("-c")
-            .arg("rustc main.rs && ./main")
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped());
+            .arg(mount_point)
+            .arg("--memory")
+            .arg(format!("{}m", memory_limit_mb))
+            .arg(image);
+
+        // 実行コマンドを追加
+        command.args(run_cmd);
+        command.stdout(Stdio::piped()).stderr(Stdio::piped());
 
         // コマンドを実行
         println!("Running command: {:?}", command);
-        let output = match timeout(Duration::from_secs(10), command.output()).await {
+        let output = match timeout(Duration::from_secs(timeout_seconds as u64), command.output()).await {
             Ok(result) => result.map_err(|e| format!("コマンドの実行に失敗しました: {}", e))?,
             Err(_) => {
                 self.stop_container().await;
-                return Err("実行がタイムアウトしました".to_string());
+                return Err("タイムアウトが発生しました".to_string());
             }
         };
 
-        // 一時ディレクトリを削除
-        let _ = std::fs::remove_dir_all(temp_dir);
-
         if output.status.success() {
             Ok(String::from_utf8_lossy(&output.stdout).to_string())
         } else {
@@ -76,54 +135,15 @@ impl DockerCommand {
         }
     }
 
-    // コンパイル実行
-    pub async fn compile(
+    async fn compile(
         &mut self,
         image: &str,
         compile_cmd: &[String],
-        compile_dir: &str,
+        compile_dir: &std::path::Path,
         mount_point: &str,
-        source_code: &str,
-        extension: String,
-        require_files: Vec<String>,
-        env_vars: Vec<String>,
+        memory_limit_mb: u32,
+        timeout_seconds: u32,
     ) -> Result<(), String> {
-        println!("Compiling with command: {:?}", compile_cmd);
-        println!("Mount point: {}, Compile dir: {}", mount_point, compile_dir);
-        
-        // 現在のワーキングディレクトリを取得し、compile_dirへの絶対パスを構築
-        let current_dir = env::current_dir()
-            .map_err(|e| format!("Failed to get current directory: {}", e))?;
-        let absolute_compile_dir = current_dir.join(compile_dir);
-
-        // ソースコードをファイルに書き込む
-        use std::fs;
-        fs::create_dir_all(&absolute_compile_dir)
-            .map_err(|e| format!("Failed to create compile directory: {}", e))?;
-
-        // 必要なファイルの存在チェック
-        for required_file in &require_files {
-            let file_path = absolute_compile_dir.join(required_file);
-            if !file_path.exists() {
-                return Err(format!("Required file not found: {}", required_file));
-            }
-        }
-
-        // ソースファイルの配置
-        let source_file = if !require_files.is_empty() {
-            // 必要なファイルがある場合（例：Cargoプロジェクト）はsrcディレクトリを作成
-            let src_dir = absolute_compile_dir.join("src");
-            fs::create_dir_all(&src_dir)
-                .map_err(|e| format!("Failed to create source directory: {}", e))?;
-            src_dir.join(format!("main.{}", extension))
-        } else {
-            // その他の言語の場合は直接コンパイルディレクトリに配置
-            absolute_compile_dir.join(format!("main.{}", extension))
-        };
-
-        fs::write(&source_file, source_code)
-            .map_err(|e| format!("Failed to write source code: {}", e))?;
-        
         let container_name = format!("compiler-{}", Uuid::new_v4());
         self.container_name = container_name.clone();
 
@@ -134,28 +154,28 @@ impl DockerCommand {
             .arg("--name")
             .arg(&container_name)
             .arg("-v")
-            .arg(format!("{}:{}", absolute_compile_dir.display(), mount_point))
+            .arg(format!("{}:{}", compile_dir.display(), mount_point))
             .arg("-w")
-            .arg(mount_point);
-
-        // 環境変数の設定
-        for env_var in &env_vars {
-            command.arg("-e").arg(env_var);
-        }
-
-        command
+            .arg(mount_point)
+            .arg("--memory")
+            .arg(format!("{}m", memory_limit_mb))
             .arg(image)
             .args(compile_cmd)
             .stdout(Stdio::piped())
             .stderr(Stdio::piped());
 
         println!("Running compile command: {:?}", command);
-        let output = command.output().await
-            .map_err(|e| format!("Failed to execute compile command: {}", e))?;
+        let output = match timeout(Duration::from_secs(timeout_seconds as u64), command.output()).await {
+            Ok(result) => result.map_err(|e| format!("コンパイルコマンドの実行に失敗しました: {}", e))?,
+            Err(_) => {
+                self.stop_container().await;
+                return Err("コンパイル時にタイムアウトが発生しました".to_string());
+            }
+        };
 
         if !output.status.success() {
             let error = String::from_utf8_lossy(&output.stderr);
-            return Err(format!("Compilation failed: {}", error));
+            return Err(format!("コンパイルエラー: {}", error));
         }
 
         Ok(())
@@ -204,32 +224,4 @@ impl DockerCommand {
             Err(_) => false,
         }
     }
-
-    pub async fn inspect_directory(&self, image: &str, mount_point: &str) -> Result<String, String> {
-        let container_name = format!("inspector-{}", Uuid::new_v4());
-        let mut command = Command::new("docker");
-        command
-            .arg("run")
-            .arg("--rm")
-            .arg("--name")
-            .arg(&container_name)
-            .arg("-v")
-            .arg(format!("{}:{}", mount_point, mount_point))
-            .arg("-w")
-            .arg(mount_point)
-            .arg(image)
-            .arg("ls")
-            .arg("-la")
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped());
-
-        let output = command.output().await
-            .map_err(|e| format!("Failed to execute inspect command: {}", e))?;
-
-        if output.status.success() {
-            Ok(String::from_utf8_lossy(&output.stdout).to_string())
-        } else {
-            Err(String::from_utf8_lossy(&output.stderr).to_string())
-        }
-    }
 } 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 4e37e06..a27e6ef 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -3,76 +3,122 @@ pub mod command;
 use std::sync::Arc;
 use tokio::sync::Mutex;
 use crate::config::Config;
-use crate::config::TypedValue;
 use self::command::DockerCommand;
 use crate::docker::state::RunnerState;
 
 pub struct DockerRunner {
-    command: DockerCommand,
-    config: Arc<Config>,
+    config: Config,
     language: String,
+    command: DockerCommand,
     state: Arc<Mutex<RunnerState>>,
 }
 
 impl DockerRunner {
-    fn load_config_value<T: TypedValue>(config: &Config, key: &str) -> Result<T, String> {
-        config.get::<T>(key)
-            .map_err(|e| format!("設定の読み込みに失敗しました: {}", e))
+    fn load_config_value<T>(config: &Config, key: &str) -> Result<T, String>
+    where
+        T: TryFrom<serde_yaml::Value>,
+        <T as TryFrom<serde_yaml::Value>>::Error: std::fmt::Display,
+    {
+        config.get_raw_value(key)
+            .map_err(|e| format!("設定が見つかりません: {}", e))
+            .and_then(|v| T::try_from(v.clone())
+                .map_err(|e| format!("設定の型が不正です: {}: {}", key, e)))
     }
 
     pub fn new(config: Config, language: String) -> Result<Self, String> {
-        // 言語の存在確認
-        let config = Arc::new(config);
-        let _resolved = config.get_with_alias::<String>(&format!("languages.{}.extension", language))
-            .map_err(|e| format!("言語名の解決に失敗しました: {}", e))?;
-
         Ok(Self {
-            command: DockerCommand::new(),
-            config: config.clone(),
+            config,
             language,
+            command: DockerCommand::new(),
             state: Arc::new(Mutex::new(RunnerState::Ready)),
         })
     }
 
     pub fn from_language(language: &str) -> Result<Self, String> {
-        let config = Config::load()
-            .map_err(|e| format!("設定の読み込みに失敗しました: {}", e))?;
-        
-        Self::new(config, language.to_string())
+        Config::load()
+            .map_err(|e| format!("設定の読み込みに失敗しました: {}", e))
+            .and_then(|config| Self::new(config, language.to_string()))
+    }
+
+    pub async fn get_state(&self) -> RunnerState {
+        *self.state.lock().await
     }
 
     pub async fn run_in_docker(&mut self, source_code: &str) -> Result<String, String> {
-        println!("Starting Docker execution");
-        
-        // イメージ名を取得
-        let image = self.config.get::<String>(&format!("languages.{}.runner.image", self.language))
-            .map_err(|e| format!("イメージ名の取得に失敗しました: {}", e))?;
-
-        // イメージの確認と取得
-        if !self.command.check_image(&image).await {
-            println!("Image not found, attempting to pull: {}", image);
-            if !self.command.pull_image(&image).await {
-                println!("Failed to pull image: {}", image);
+        let language = &self.language;
+        let _language_config = self.config.get_language_config(language)
+            .ok_or_else(|| format!("言語の設定が見つかりません: {}", language))?;
+
+        let runner_config = self.config.get_language_runner_config(language)
+            .ok_or_else(|| format!("ランナーの設定が見つかりません: {}", language))?;
+
+        let image = runner_config.get("image")
+            .and_then(|v| v.as_str())
+            .ok_or_else(|| format!("Dockerイメージが設定されていません: {}", language))?;
+
+        let compile_dir = runner_config.get("compile_dir")
+            .and_then(|v| v.as_str())
+            .ok_or_else(|| format!("コンパイルディレクトリが設定されていません: {}", language))?;
+
+        let compile_cmd = runner_config.get("compile")
+            .and_then(|v| v.as_sequence())
+            .map(|seq| seq.iter()
+                .filter_map(|v| v.as_str())
+                .map(|s| s.to_string())
+                .collect::<Vec<_>>())
+            .unwrap_or_default();
+
+        let run_cmd = runner_config.get("run")
+            .and_then(|v| v.as_sequence())
+            .map(|seq| seq.iter()
+                .filter_map(|v| v.as_str())
+                .map(|s| s.to_string())
+                .collect::<Vec<_>>())
+            .ok_or_else(|| format!("実行コマンドが設定されていません: {}", language))?;
+
+        let mount_point = self.config.get_docker_mount_point()
+            .ok_or_else(|| "マウントポイントが設定されていません")?;
+
+        let extension = self.config.get_language_extension(language)
+            .ok_or_else(|| format!("拡張子が設定されていません: {}", language))?;
+
+        let memory_limit_mb = self.config.get_docker_memory_limit()
+            .unwrap_or(256);
+
+        let timeout_seconds = self.config.get_docker_timeout()
+            .unwrap_or(10);
+
+        // イメージの存在確認
+        if !self.command.check_image(image).await {
+            println!("Pulling image: {}", image);
+            if !self.command.pull_image(image).await {
                 *self.state.lock().await = RunnerState::Error;
-                return Err(format!("Failed to pull image: {}", image));
+                return Err(format!("Dockerイメージの取得に失敗しました: {}", image));
             }
         }
-
         println!("Image is ready: {}", image);
         *self.state.lock().await = RunnerState::Running;
 
-        // ソースコードの実行
-        let result = self.command.run_code(&image, source_code).await;
-        match result {
-            Ok(output) => {
-                *self.state.lock().await = RunnerState::Ready;
-                Ok(output)
-            }
-            Err(e) => {
-                *self.state.lock().await = RunnerState::Error;
-                Err(e)
-            }
-        }
+        // コードを実行
+        let result = self.command.run_code(
+            image,
+            source_code,
+            language,
+            compile_dir,
+            &compile_cmd,
+            &run_cmd,
+            mount_point,
+            extension,
+            memory_limit_mb,
+            timeout_seconds,
+        ).await;
+
+        *self.state.lock().await = match &result {
+            Ok(_) => RunnerState::Ready,
+            Err(_) => RunnerState::Error,
+        };
+
+        result
     }
 
     pub async fn cleanup(&mut self) -> Result<(), String> {
@@ -87,21 +133,4 @@ impl DockerRunner {
             Err("Failed to stop container".to_string())
         }
     }
-
-    pub async fn get_state(&self) -> RunnerState {
-        self.state.lock().await.clone()
-    }
-
-    pub async fn inspect_mount_point(&mut self) -> Result<String, String> {
-        // イメージ名を取得
-        let image = self.config.get::<String>(&format!("languages.{}.runner.image", self.language))
-            .map_err(|e| format!("イメージ名の取得に失敗しました: {}", e))?;
-
-        // マウントポイントを取得
-        let mount_point = self.config.get::<String>("system.docker.mount_point")
-            .map_err(|e| format!("マウントポイントの設定の読み込みに失敗しました: {}", e))?;
-
-        println!("Inspecting mount point directory: {}", &mount_point);
-        self.command.inspect_directory(&image, &mount_point).await
-    }
 } 
\ No newline at end of file
diff --git a/src/docker/state.rs b/src/docker/state.rs
index c47f376..f16f266 100644
--- a/src/docker/state.rs
+++ b/src/docker/state.rs
@@ -1,11 +1,11 @@
 use std::fmt;
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Debug, Clone, Copy, PartialEq)]
 pub enum RunnerState {
     Ready,
     Running,
-    Stop,
     Error,
+    Stop,
 }
 
 impl fmt::Display for RunnerState {
diff --git a/tests/docker/runner_test.rs b/tests/docker/runner_test.rs
index aff5bf2..982ba18 100644
--- a/tests/docker/runner_test.rs
+++ b/tests/docker/runner_test.rs
@@ -1,8 +1,10 @@
 use std::process::Command;
-use tokio::test;
-use cph::config::Config;
+use cph::config::{Config, ConfigBuilder};
 use cph::docker::DockerRunner;
 use std::fs;
+use std::env;
+use std::path::PathBuf;
+use std::os::unix::fs::PermissionsExt;
 
 // Dockerデーモンが利用可能かチェックする
 fn check_docker_available() -> bool {
@@ -13,14 +15,71 @@ fn check_docker_available() -> bool {
         .unwrap_or(false)
 }
 
-async fn prepare_test_file(dir: &str, filename: &str, content: &str) -> std::io::Result<()> {
-    fs::create_dir_all(dir)?;
-    fs::write(format!("{}/{}", dir, filename), content)
+fn create_test_dir() -> PathBuf {
+    let temp_dir = env::temp_dir().join("cph_test");
+    fs::create_dir_all(&temp_dir).expect("Failed to create test directory");
+    
+    // ディレクトリのパーミッションを設定
+    let metadata = fs::metadata(&temp_dir).expect("Failed to get metadata");
+    let mut perms = metadata.permissions();
+    perms.set_mode(0o777);
+    fs::set_permissions(&temp_dir, perms).expect("Failed to set permissions");
+
+    temp_dir
+}
+
+fn create_test_config() -> Config {
+    // テスト用の一時ディレクトリを作成
+    let temp_dir = create_test_dir();
+
+    let yaml = format!(r#"
+system:
+  docker:
+    timeout_seconds: 1
+    memory_limit_mb: 256
+    mount_point: "/workspace"
+
+languages:
+  rust:
+    name: "rust"
+    extension: "rs"
+    runner:
+      image: "rust:latest"
+      compile_dir: "{}/compile/rust"
+      compile: ["rustc", "main.rs"]
+      run: ["./main"]
+      require_files: []
+      env_vars: ["RUST_BACKTRACE=1"]
+
+  cpp:
+    name: "cpp"
+    extension: "cpp"
+    runner:
+      image: "gcc:latest"
+      compile_dir: "{}/compile/cpp"
+      compile: ["g++", "-std=c++17", "-O2", "main.cpp", "-o", "main"]
+      run: ["./main"]
+      require_files: []
+      env_vars: ["CPLUS_INCLUDE_PATH=/usr/include/c++/9"]
+
+  pypy:
+    name: "pypy"
+    extension: "py"
+    runner:
+      image: "pypy:latest"
+      compile_dir: "{}/compile/pypy"
+      compile: []
+      run: ["pypy3", "main.py"]
+      require_files: []
+      env_vars: []
+"#, temp_dir.display(), temp_dir.display(), temp_dir.display());
+
+    Config::from_str(&yaml, ConfigBuilder::new()).expect("Failed to create test config")
 }
 
 #[tokio::test]
 async fn test_docker_runner_creation() {
-    let config = Config::load().unwrap();
+    let config = create_test_config();
     let runner = DockerRunner::new(config, "rust".to_string()).unwrap();
     assert!(runner.get_state().await == cph::docker::RunnerState::Ready);
 }
@@ -37,11 +96,8 @@ async fn test_docker_available() {
 }
 
 #[tokio::test]
-#[ignore = "マウントポイントの問題を修正する必要があります"]
 async fn test_rust_runner() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
+    let config = create_test_config();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
 
     let source_code = r#"
@@ -50,8 +106,6 @@ async fn test_rust_runner() {
         }
     "#;
 
-    prepare_test_file("/tmp/test-rust", "main.rs", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
         Ok(output) => {
             println!("=== Execution Output ===");
@@ -66,57 +120,56 @@ async fn test_rust_runner() {
 }
 
 #[tokio::test]
-#[ignore = "タイムアウトの検出方法を修正する必要があります"]
-async fn test_timeout() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
+async fn test_cpp_runner() {
+    let config = create_test_config();
+    let mut runner = DockerRunner::new(config, "cpp".to_string()).unwrap();
 
     let source_code = r#"
-        fn main() {
-            loop {}
-        }
+#include <iostream>
+int main() {
+    std::cout << "Hello from C++!" << std::endl;
+    return 0;
+}
     "#;
 
-    prepare_test_file("/tmp/test-timeout", "main.rs", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("タイムアウトが発生しませんでした"),
-        Err(e) => assert!(e.to_string().contains("timed out")),
+        Ok(output) => {
+            println!("=== Execution Output ===");
+            println!("{}", output);
+            assert!(output.contains("Hello from C++!"));
+        }
+        Err(e) => {
+            println!("Error: {}", e);
+            panic!("実行に失敗しました");
+        }
     }
 }
 
 #[tokio::test]
-#[ignore = "メモリ制限の検出方法を修正する必要があります"]
-async fn test_memory_limit() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
+async fn test_pypy_runner() {
+    let config = create_test_config();
+    let mut runner = DockerRunner::new(config, "pypy".to_string()).unwrap();
 
     let source_code = r#"
-        fn main() {
-            let mut v = Vec::new();
-            loop {
-                v.extend(vec![1; 1024 * 1024]); // 1MB
-            }
-        }
+print("Hello from PyPy!")
     "#;
 
-    prepare_test_file("/tmp/test-memory", "main.rs", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("メモリ制限が機能していません"),
-        Err(e) => assert!(e.to_string().contains("out of memory")),
+        Ok(output) => {
+            println!("=== Execution Output ===");
+            println!("{}", output);
+            assert!(output.contains("Hello from PyPy!"));
+        }
+        Err(e) => {
+            println!("Error: {}", e);
+            panic!("実行に失敗しました");
+        }
     }
 }
 
 #[tokio::test]
 async fn test_compilation_error() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
+    let config = create_test_config();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
 
     let source_code = r#"
@@ -125,54 +178,51 @@ async fn test_compilation_error() {
         }
     "#;
 
-    prepare_test_file("/tmp/test-compile", "main.rs", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
         Ok(_) => panic!("コンパイルエラーが検出されませんでした"),
-        Err(e) => assert!(e.to_string().contains("error")),
+        Err(e) => assert!(e.contains("error")),
     }
 }
 
 #[tokio::test]
-#[ignore = "PyPyの実行コマンドを修正する必要があります"]
-async fn test_pypy_runner() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "pypy".to_string()).unwrap();
+async fn test_timeout() {
+    let config = create_test_config();
+    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
 
     let source_code = r#"
-print("Hello from PyPy!")
+        fn main() {
+            loop {}
+        }
     "#;
 
-    prepare_test_file("/tmp/test-pypy", "main.py", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
-        Ok(output) => assert!(output.contains("Hello from PyPy!")),
-        Err(e) => panic!("PyPyの実行に失敗しました: {}", e),
+        Ok(_) => panic!("タイムアウトが発生しませんでした"),
+        Err(e) => {
+            println!("Error message: {}", e);
+            assert!(e.contains("タイムアウト"));
+        }
     }
 }
 
 #[tokio::test]
-#[ignore = "C++の実行コマンドを修正する必要があります"]
-async fn test_cpp_runner() {
-    super::setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "cpp".to_string()).unwrap();
+async fn test_memory_limit() {
+    let config = create_test_config();
+    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
 
     let source_code = r#"
-#include <iostream>
-int main() {
-    std::cout << "Hello from C++!" << std::endl;
-    return 0;
-}
+        fn main() {
+            let mut v = Vec::new();
+            loop {
+                v.extend(vec![1; 1024 * 1024]); // 1MB
+            }
+        }
     "#;
 
-    prepare_test_file("/tmp/test-cpp", "main.cpp", source_code).await.unwrap();
-
     match runner.run_in_docker(source_code).await {
-        Ok(output) => assert!(output.contains("Hello from C++!")),
-        Err(e) => panic!("C++の実行に失敗しました: {}", e),
+        Ok(_) => panic!("メモリ制限が機能していません"),
+        Err(e) => {
+            println!("Error message: {}", e);
+            assert!(e.contains("out of memory") || e.contains("タイムアウト"));
+        }
     }
 } 
\ No newline at end of file
