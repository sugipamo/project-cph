diff --git a/Cargo.toml b/Cargo.toml
index 9099091..c7759f8 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,11 +23,11 @@ clap = { version = "4.4.6", features = ["derive"] }
 serde = { version = "1.0", features = ["derive"] }
 serde_yaml = "0.9"
 serde_json = "1.0"
-tokio = { version = "1.32.0", features = ["full"] }
+tokio = { version = "1.0", features = ["full"] }
 open = "5.0.0"
 thiserror = "1.0"
 once_cell = "1.18"
-tempfile = "3.8"
+tempfile = "3.2"
 rpassword = "7.3"
 chrono = "0.4"
 dirs = "5.0"
@@ -36,11 +36,13 @@ proconio = "0.4"
 async-trait = "0.1"
 futures = "0.3"
 tar = "0.4"
-uuid = { version = "1.4", features = ["v4"] }
+uuid = { version = "1.0", features = ["v4"] }
 users = "0.11"
 regex = "1.10.2"
 itertools = "0.11"
 fs_extra = "1.3"
+libc = "0.2"
+nix = { version = "0.27", features = ["user", "fs"] }
 
 [dev-dependencies]
 assert_cmd = "2.0"
diff --git a/src/docker/error.rs b/src/docker/error.rs
index 82cd20b..d7c60e3 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,41 +1,26 @@
-use std::fmt;
-use std::error::Error;
+use thiserror::Error;
+use std::io;
 
-#[derive(Debug)]
+#[derive(Debug, Error)]
 pub enum DockerError {
-    Config(String),
+    #[error("ランタイムエラー: {0}")]
     Runtime(String),
+    #[error("タイムアウト: {0}")]
     Timeout(String),
+    #[error("メモリ制限超過: {0}")]
     Memory(String),
-    IO(std::io::Error),
+    #[error("設定エラー: {0}")]
+    Config(String),
+    #[error("ファイルシステムエラー: {0}")]
+    Filesystem(String),
+    #[error("I/Oエラー: {0}")]
+    Io(#[from] io::Error),
 }
 
-impl fmt::Display for DockerError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            DockerError::Config(msg) => write!(f, "Docker設定エラー: {}", msg),
-            DockerError::Runtime(msg) => write!(f, "Docker実行時エラー: {}", msg),
-            DockerError::Timeout(msg) => write!(f, "Dockerタイムアウトエラー: {}", msg),
-            DockerError::Memory(msg) => write!(f, "Dockerメモリ制限エラー: {}", msg),
-            DockerError::IO(err) => write!(f, "Docker I/Oエラー: {}", err),
-        }
-    }
-}
+pub type DockerResult<T> = Result<T, DockerError>;
 
-impl Error for DockerError {
-    fn source(&self) -> Option<&(dyn Error + 'static)> {
-        match self {
-            DockerError::IO(err) => Some(err),
-            _ => None,
-        }
+impl From<nix::Error> for DockerError {
+    fn from(err: nix::Error) -> Self {
+        DockerError::Filesystem(err.to_string())
     }
-}
-
-impl From<std::io::Error> for DockerError {
-    fn from(err: std::io::Error) -> Self {
-        DockerError::IO(err)
-    }
-}
-
-// 便利なResult型エイリアス
-pub type DockerResult<T> = Result<T, DockerError>; 
\ No newline at end of file
+} 
\ No newline at end of file
diff --git a/src/docker/executor.rs b/src/docker/executor.rs
index 98ddc93..13b4d82 100644
--- a/src/docker/executor.rs
+++ b/src/docker/executor.rs
@@ -1,11 +1,10 @@
-use std::process::Stdio;
 use tokio::process::Command;
+use tokio::time::{timeout, Duration};
+use async_trait::async_trait;
 use crate::docker::error::{DockerError, DockerResult};
-use std::time::Duration;
-use tokio::time::timeout;
 
-#[async_trait::async_trait]
-pub trait DockerCommandExecutor {
+#[async_trait]
+pub trait DockerCommandExecutor: Send + Sync {
     async fn check_image(&self, image: &str) -> DockerResult<bool>;
     async fn pull_image(&self, image: &str) -> DockerResult<bool>;
     async fn run_container(
@@ -18,13 +17,6 @@ pub trait DockerCommandExecutor {
         command: &str,
         timeout_seconds: u32,
     ) -> DockerResult<String>;
-    async fn stop_container(&self, container_name: &str) -> DockerResult<()>;
-    async fn inspect_directory(
-        &self,
-        container_name: &str,
-        image: &str,
-        mount_point: &str,
-    ) -> DockerResult<String>;
 }
 
 pub struct DefaultDockerExecutor;
@@ -35,31 +27,29 @@ impl DefaultDockerExecutor {
     }
 }
 
-#[async_trait::async_trait]
+#[async_trait]
 impl DockerCommandExecutor for DefaultDockerExecutor {
     async fn check_image(&self, image: &str) -> DockerResult<bool> {
         let output = Command::new("docker")
             .arg("image")
             .arg("inspect")
             .arg(image)
-            .stdout(Stdio::null())
-            .stderr(Stdio::null())
-            .status()
+            .output()
             .await
-            .map_err(|e| DockerError::Runtime(format!("イメージの確認に失敗しました: {}", e)))?;
+            .map_err(|e| DockerError::Runtime(e.to_string()))?;
 
-        Ok(output.success())
+        Ok(output.status.success())
     }
 
     async fn pull_image(&self, image: &str) -> DockerResult<bool> {
         let output = Command::new("docker")
             .arg("pull")
             .arg(image)
-            .status()
+            .output()
             .await
-            .map_err(|e| DockerError::Runtime(format!("イメージの取得に失敗しました: {}", e)))?;
+            .map_err(|e| DockerError::Runtime(e.to_string()))?;
 
-        Ok(output.success())
+        Ok(output.status.success())
     }
 
     async fn run_container(
@@ -72,6 +62,9 @@ impl DockerCommandExecutor for DefaultDockerExecutor {
         command: &str,
         timeout_seconds: u32,
     ) -> DockerResult<String> {
+        let uid = std::process::id();
+        let gid = unsafe { libc::getgid() };
+
         let mut cmd = Command::new("docker");
         cmd.arg("run")
             .arg("--rm")
@@ -83,10 +76,14 @@ impl DockerCommandExecutor for DefaultDockerExecutor {
             .arg("1.0")
             .arg("--network")
             .arg("none")
-            .arg("-v")
-            .arg(format!("{}:{}", mount_source, mount_target))
-            .arg("-w")
+            .arg("--security-opt")
+            .arg("seccomp=unconfined")
+            .arg("--user")
+            .arg(format!("{}:{}", uid, gid))
+            .arg("--workdir")
             .arg(mount_target)
+            .arg("-v")
+            .arg(format!("{}:{}:rw,z", mount_source, mount_target))
             .arg(image)
             .arg("sh")
             .arg("-c")
@@ -94,10 +91,9 @@ impl DockerCommandExecutor for DefaultDockerExecutor {
 
         let timeout_duration = Duration::from_secs(timeout_seconds as u64);
         let output = match timeout(timeout_duration, cmd.output()).await {
-            Ok(result) => result.map_err(|e| DockerError::Runtime(format!("コンテナの実行に失敗しました: {}", e)))?,
+            Ok(result) => result.map_err(|e| DockerError::Runtime(e.to_string()))?,
             Err(_) => {
-                self.stop_container(container_name).await?;
-                return Err(DockerError::Timeout("実行がタイムアウトしました".to_string()));
+                return Err(DockerError::Timeout(format!("実行がタイムアウトしました: {}秒", timeout_seconds)))
             }
         };
 
@@ -109,44 +105,11 @@ impl DockerCommandExecutor for DefaultDockerExecutor {
 
         Ok(String::from_utf8_lossy(&output.stdout).to_string())
     }
-
-    async fn stop_container(&self, container_name: &str) -> DockerResult<()> {
-        Command::new("docker")
-            .arg("stop")
-            .arg(container_name)
-            .output()
-            .await
-            .map_err(|e| DockerError::Runtime(format!("コンテナの停止に失敗しました: {}", e)))?;
-
-        Ok(())
-    }
-
-    async fn inspect_directory(
-        &self,
-        container_name: &str,
-        image: &str,
-        mount_point: &str,
-    ) -> DockerResult<String> {
-        let output = Command::new("docker")
-            .arg("run")
-            .arg("--rm")
-            .arg("--name")
-            .arg(container_name)
-            .arg(image)
-            .arg("ls")
-            .arg("-la")
-            .arg(mount_point)
-            .output()
-            .await
-            .map_err(|e| DockerError::Runtime(format!("ディレクトリの検査に失敗しました: {}", e)))?;
-
-        Ok(String::from_utf8_lossy(&output.stdout).to_string())
-    }
 }
 
 #[cfg(test)]
 pub struct MockDockerExecutor {
-    pub should_fail: bool,
+    should_fail: bool,
 }
 
 #[cfg(test)]
@@ -157,7 +120,7 @@ impl MockDockerExecutor {
 }
 
 #[cfg(test)]
-#[async_trait::async_trait]
+#[async_trait]
 impl DockerCommandExecutor for MockDockerExecutor {
     async fn check_image(&self, _image: &str) -> DockerResult<bool> {
         Ok(true)
@@ -174,34 +137,13 @@ impl DockerCommandExecutor for MockDockerExecutor {
         _memory_limit: u32,
         _mount_source: &str,
         _mount_target: &str,
-        command: &str,
+        _command: &str,
         _timeout_seconds: u32,
     ) -> DockerResult<String> {
         if self.should_fail {
-            Err(DockerError::Runtime("モックエラー".to_string()))
+            Err(DockerError::Runtime("Mock execution failed".to_string()))
         } else {
-            if command.contains("main.rs") {
-                Ok("Hello from Rust!\n".to_string())
-            } else if command.contains("main.py") {
-                Ok("Hello from Python!\n".to_string())
-            } else if command.contains("main.cpp") {
-                Ok("Hello from C++!\n".to_string())
-            } else {
-                Ok("実行成功\n".to_string())
-            }
+            Ok("Hello from Rust!\n".to_string())
         }
     }
-
-    async fn stop_container(&self, _container_name: &str) -> DockerResult<()> {
-        Ok(())
-    }
-
-    async fn inspect_directory(
-        &self,
-        _container_name: &str,
-        _image: &str,
-        _mount_point: &str,
-    ) -> DockerResult<String> {
-        Ok("total 4\ndrwxr-xr-x 2 root root 4096 Jan 1 00:00 .\n".to_string())
-    }
 } 
\ No newline at end of file
diff --git a/src/docker/fs.rs b/src/docker/fs.rs
index 181f174..bdf1ae8 100644
--- a/src/docker/fs.rs
+++ b/src/docker/fs.rs
@@ -1,7 +1,9 @@
-use std::path::{Path, PathBuf};
-use crate::docker::error::DockerResult;
 use std::fs;
-use uuid::Uuid;
+use std::path::{Path, PathBuf};
+use std::os::unix::fs::PermissionsExt;
+use tempfile::TempDir;
+use crate::docker::error::{DockerError, DockerResult};
+use nix::unistd::{Uid, Gid};
 
 pub trait DockerFileManager {
     fn create_temp_directory(&self) -> DockerResult<PathBuf>;
@@ -16,27 +18,66 @@ impl DefaultDockerFileManager {
     pub fn new() -> Self {
         Self
     }
+
+    fn ensure_directory_permissions(&self, dir: &Path) -> DockerResult<()> {
+        let metadata = fs::metadata(dir)?;
+        let mut perms = metadata.permissions();
+        perms.set_mode(0o777);
+        fs::set_permissions(dir, perms)?;
+        Ok(())
+    }
 }
 
 impl DockerFileManager for DefaultDockerFileManager {
     fn create_temp_directory(&self) -> DockerResult<PathBuf> {
-        let temp_dir = std::env::temp_dir().join(format!("cph_{}", Uuid::new_v4()));
-        fs::create_dir_all(&temp_dir)?;
-        Ok(temp_dir)
+        let temp_dir = TempDir::new()
+            .map_err(|e| DockerError::Filesystem(format!("一時ディレクトリの作成に失敗しました: {}", e)))?;
+        
+        let temp_path = temp_dir.path().to_path_buf();
+        self.ensure_directory_permissions(&temp_path)?;
+
+        // 所有者とグループを現在のユーザーに設定
+        let uid = Uid::from_raw(std::process::id() as u32);
+        let gid = Gid::from_raw(unsafe { libc::getgid() } as u32);
+        
+        nix::unistd::chown(&temp_path, Some(uid), Some(gid))?;
+
+        println!("=== Temporary Directory Created ===");
+        println!("Path: {:?}", temp_path);
+        println!("Permissions: {:o}", fs::metadata(&temp_path)?.permissions().mode());
+        println!("Owner: {}:{}", uid, gid);
+
+        Ok(temp_path)
     }
 
     fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf> {
         let file_path = dir.join(filename);
         fs::write(&file_path, content)?;
+
+        // 所有者とグループを現在のユーザーに設定
+        let uid = Uid::from_raw(std::process::id() as u32);
+        let gid = Gid::from_raw(unsafe { libc::getgid() } as u32);
+        
+        nix::unistd::chown(&file_path, Some(uid), Some(gid))?;
+
+        println!("=== Source File Created ===");
+        println!("Path: {:?}", file_path);
+        println!("Permissions: {:o}", fs::metadata(&file_path)?.permissions().mode());
+        println!("Owner: {}:{}", uid, gid);
+
         Ok(file_path)
     }
 
     fn set_permissions(&self, path: &Path, mode: u32) -> DockerResult<()> {
-        use std::os::unix::fs::PermissionsExt;
         let metadata = fs::metadata(path)?;
         let mut perms = metadata.permissions();
         perms.set_mode(mode);
         fs::set_permissions(path, perms)?;
+
+        println!("=== Permissions Set ===");
+        println!("Path: {:?}", path);
+        println!("Mode: {:o}", mode);
+
         Ok(())
     }
 
@@ -50,50 +91,35 @@ impl DockerFileManager for DefaultDockerFileManager {
 
 #[cfg(test)]
 pub struct MockDockerFileManager {
-    temp_dir: PathBuf,
+    temp_dir: TempDir,
 }
 
 #[cfg(test)]
 impl MockDockerFileManager {
     pub fn new() -> Self {
-        let temp_dir = std::env::temp_dir().join("mock-cph-test");
-        if temp_dir.exists() {
-            let _ = fs::remove_dir_all(&temp_dir);
+        Self {
+            temp_dir: TempDir::new().unwrap(),
         }
-        let _ = fs::create_dir_all(&temp_dir);
-        Self { temp_dir }
     }
 }
 
 #[cfg(test)]
 impl DockerFileManager for MockDockerFileManager {
     fn create_temp_directory(&self) -> DockerResult<PathBuf> {
-        let dir = self.temp_dir.join(Uuid::new_v4().to_string());
-        fs::create_dir_all(&dir)?;
-        Ok(dir)
+        Ok(self.temp_dir.path().to_path_buf())
     }
 
     fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf> {
         let file_path = dir.join(filename);
-        fs::create_dir_all(dir)?;
         fs::write(&file_path, content)?;
         Ok(file_path)
     }
 
-    fn set_permissions(&self, path: &Path, _mode: u32) -> DockerResult<()> {
-        if path.exists() {
-            Ok(())
-        } else {
-            Err(crate::docker::error::DockerError::Runtime(
-                format!("Path does not exist: {:?}", path)
-            ))
-        }
+    fn set_permissions(&self, _path: &Path, _mode: u32) -> DockerResult<()> {
+        Ok(())
     }
 
-    fn cleanup(&self, dir: &Path) -> DockerResult<()> {
-        if dir.exists() {
-            fs::remove_dir_all(dir)?;
-        }
+    fn cleanup(&self, _dir: &Path) -> DockerResult<()> {
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index d7a9172..88a52fe 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -7,7 +7,6 @@ use crate::docker::state::RunnerState;
 use crate::docker::config::DockerConfig;
 use crate::docker::fs::{DockerFileManager, DefaultDockerFileManager};
 use crate::docker::executor::{DockerCommandExecutor, DefaultDockerExecutor};
-use std::fs;
 
 pub struct DockerRunner {
     config: DockerConfig,
@@ -40,47 +39,37 @@ impl DockerRunner {
         
         // イメージの確認と取得
         if !self.executor.check_image(self.config.image()).await? {
-            println!("Image not found, attempting to pull: {}", self.config.image());
             if !self.executor.pull_image(self.config.image()).await? {
-                println!("Failed to pull image: {}", self.config.image());
                 *self.state.lock().await = RunnerState::Error;
-                return Err(DockerError::Runtime(format!("Failed to pull image: {}", self.config.image())));
+                return Err(DockerError::Runtime(format!("イメージの取得に失敗: {}", self.config.image())));
             }
         }
 
-        println!("Image is ready: {}", self.config.image());
         *self.state.lock().await = RunnerState::Running;
 
-        // 一時ディレクトリの作成
+        // 一時ディレクトリの作成（ホスト側）
         let temp_dir = self.file_manager.create_temp_directory()?;
-        let compile_dir = temp_dir.join("compile");
-        fs::create_dir_all(&compile_dir)?;
         
-        // ソースファイルの作成
+        // ソースファイルの作成（直接一時ディレクトリに配置）
         let source_file = self.file_manager.write_source_file(
-            &compile_dir,
+            &temp_dir,
             &format!("main.{}", self.config.extension()),
             source_code,
         )?;
-        
-        // ファイルのパーミッション設定
+
+        // パーミッションの設定
+        self.file_manager.set_permissions(&temp_dir, 0o755)?;
         self.file_manager.set_permissions(&source_file, 0o644)?;
-        self.file_manager.set_permissions(&compile_dir, 0o777)?;
 
-        // コマンドの構築
+        // コマンドの構築（シンプルに保つ）
         let command = if let Some(compile_cmd) = self.config.compile_cmd() {
             format!(
-                "cd {} && {} && {}",
-                self.config.mount_point(),
+                "{} && {}",
                 compile_cmd.join(" "),
                 self.config.run_cmd().join(" ")
             )
         } else {
-            format!(
-                "cd {} && {}",
-                self.config.mount_point(),
-                self.config.run_cmd().join(" ")
-            )
+            self.config.run_cmd().join(" ")
         };
 
         // コンテナの実行
@@ -89,8 +78,8 @@ impl DockerRunner {
             &container_name,
             self.config.image(),
             self.config.memory_limit(),
-            compile_dir.to_str().unwrap(),
-            self.config.mount_point(),
+            temp_dir.to_str().unwrap(),
+            "/app",  // シンプルな固定マウントポイント
             &command,
             self.config.timeout_seconds(),
         ).await;
@@ -99,14 +88,14 @@ impl DockerRunner {
         let _ = self.file_manager.cleanup(&temp_dir);
 
         // 状態の更新と結果の返却
-        match &result {
-            Ok(_) => {
+        match result {
+            Ok(output) => {
                 *self.state.lock().await = RunnerState::Completed;
-                result
+                Ok(output)
             }
-            Err(_) => {
+            Err(e) => {
                 *self.state.lock().await = RunnerState::Error;
-                result
+                Err(e)
             }
         }
     }
@@ -118,15 +107,6 @@ impl DockerRunner {
     pub async fn get_state(&self) -> RunnerState {
         self.state.lock().await.clone()
     }
-
-    pub async fn inspect_mount_point(&mut self) -> DockerResult<String> {
-        let container_name = format!("inspector-{}", Uuid::new_v4());
-        self.executor.inspect_directory(
-            &container_name,
-            self.config.image(),
-            self.config.mount_point(),
-        ).await
-    }
 }
 
 #[cfg(test)]
diff --git a/tests/docker/runner_test.rs b/tests/docker/runner_test.rs
index 7450517..bf8497f 100644
--- a/tests/docker/runner_test.rs
+++ b/tests/docker/runner_test.rs
@@ -1,9 +1,10 @@
 use std::process::Command;
-use tokio::test;
 use cph::config::Config;
 use cph::docker::{DockerRunner, DockerError};
 use std::fs;
 use std::path::PathBuf;
+use std::os::unix::fs::PermissionsExt;
+use crate::helpers::docker_debug;
 
 fn setup() -> PathBuf {
     let temp_dir = std::env::temp_dir().join("cph-test");
@@ -45,6 +46,8 @@ async fn test_docker_available() {
 #[tokio::test]
 async fn test_rust_runner() {
     let temp_dir = setup();
+    println!("=== Test Directory ===");
+    println!("{}", temp_dir.display());
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -53,14 +56,21 @@ async fn test_rust_runner() {
     println!("Hello from Rust!");
 }"#;
 
+    println!("=== Initial Directory State ===");
+    println!("{}", docker_debug::inspect_directory(&temp_dir));
+
     match runner.run_in_docker(source_code).await {
         Ok(output) => {
             println!("=== Execution Output ===");
             println!("{}", output);
+            println!("=== Final Directory State ===");
+            println!("{}", docker_debug::inspect_directory(&temp_dir));
             assert!(output.contains("Hello from Rust!"));
         }
         Err(e) => {
             println!("Error: {}", e);
+            println!("=== Final Directory State ===");
+            println!("{}", docker_debug::inspect_directory(&temp_dir));
             panic!("実行に失敗しました");
         }
     }
@@ -70,7 +80,7 @@ async fn test_rust_runner() {
 
 #[tokio::test]
 async fn test_timeout() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -88,11 +98,13 @@ async fn test_timeout() {
             _ => panic!("予期しないエラー: {}", e),
         },
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_memory_limit() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -113,11 +125,13 @@ async fn test_memory_limit() {
             _ => panic!("予期しないエラー: {}", e),
         },
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_compilation_error() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -132,11 +146,13 @@ async fn test_compilation_error() {
         Ok(_) => panic!("コンパイルエラーが検出されませんでした"),
         Err(e) => assert!(e.to_string().contains("error")),
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_pypy_runner() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "pypy".to_string()).unwrap();
@@ -156,11 +172,13 @@ print("Hello from PyPy!")
             panic!("PyPyの実行に失敗しました: {}", e);
         }
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_python_runner() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "python".to_string()).unwrap();
@@ -180,11 +198,13 @@ print("Hello from Python!")
             panic!("Pythonの実行に失敗しました: {}", e);
         }
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_cpp_runner_with_extension() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "cpp".to_string()).unwrap();
@@ -208,11 +228,13 @@ int main() {
             panic!("C++の実行に失敗しました: {}", e);
         }
     }
+
+    teardown(&temp_dir);
 }
 
 #[tokio::test]
 async fn test_rust_runner_with_extension() {
-    super::setup();
+    let temp_dir = setup();
     
     let config = Config::load().unwrap();
     let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
@@ -232,4 +254,48 @@ async fn test_rust_runner_with_extension() {
             panic!("Rustの実行に失敗しました: {}", e);
         }
     }
+
+    teardown(&temp_dir);
+}
+
+#[tokio::test]
+async fn test_mount_point() {
+    let temp_dir = setup();
+    
+    let config = Config::load().unwrap();
+    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
+
+    // テスト用のファイルを作成
+    let test_file = temp_dir.join("test.txt");
+    fs::write(&test_file, "test content").unwrap();
+    fs::set_permissions(&test_file, fs::Permissions::from_mode(0o644)).unwrap();
+
+    println!("=== Local Directory Contents ===");
+    println!("{}", docker_debug::inspect_directory(&temp_dir));
+
+    // 単純なファイル読み込みプログラムを実行
+    let source_code = r#"
+        use std::fs;
+        fn main() {
+            match fs::read_to_string("/app/test.txt") {
+                Ok(content) => println!("File content: {}", content),
+                Err(e) => eprintln!("Error reading file: {}", e),
+            }
+        }
+    "#;
+
+    match runner.run_in_docker(source_code).await {
+        Ok(output) => {
+            println!("=== Execution Output ===");
+            println!("{}", output);
+            assert!(output.contains("test content"), "ファイルの内容が読み取れません\n出力: {}", output);
+        }
+        Err(e) => {
+            println!("=== Error Output ===");
+            println!("Error: {}", e);
+            panic!("マウントポイントのテストに失敗しました: {}", e);
+        }
+    }
+
+    teardown(&temp_dir);
 } 
\ No newline at end of file
diff --git a/tests/helpers/mod.rs b/tests/helpers/mod.rs
index edbf2f7..83ccab1 100644
--- a/tests/helpers/mod.rs
+++ b/tests/helpers/mod.rs
@@ -2,11 +2,51 @@ use std::fs;
 use cph::config::Config;
 use tempfile::TempDir;
 use std::env;
+use std::path::Path;
+use std::process::Command;
 
 thread_local! {
     static TEST_DIR: std::cell::RefCell<Option<TempDir>> = std::cell::RefCell::new(None);
 }
 
+pub mod docker_debug {
+    use std::path::Path;
+    use std::process::Command;
+
+    pub fn inspect_directory(path: &Path) -> String {
+        let output = Command::new("ls")
+            .arg("-la")
+            .arg(path)
+            .output()
+            .unwrap_or_else(|e| panic!("Failed to inspect directory: {}", e));
+
+        String::from_utf8_lossy(&output.stdout).to_string()
+    }
+
+    pub fn inspect_docker_container(container_name: &str, path: &str) -> String {
+        let output = Command::new("docker")
+            .arg("exec")
+            .arg(container_name)
+            .arg("ls")
+            .arg("-la")
+            .arg(path)
+            .output()
+            .unwrap_or_else(|e| panic!("Failed to inspect container: {}", e));
+
+        String::from_utf8_lossy(&output.stdout).to_string()
+    }
+
+    pub fn get_docker_logs(container_name: &str) -> String {
+        let output = Command::new("docker")
+            .arg("logs")
+            .arg(container_name)
+            .output()
+            .unwrap_or_else(|e| panic!("Failed to get container logs: {}", e));
+
+        String::from_utf8_lossy(&output.stdout).to_string()
+    }
+}
+
 pub fn setup() {
     // テスト用の一時ディレクトリを作成
     let temp_dir = TempDir::new().unwrap();
