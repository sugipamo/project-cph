diff --git a/Cargo.toml b/Cargo.toml
index c7759f8..2e9f7b4 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -16,6 +16,7 @@ path = "src/bin/cph.rs"
 
 [features]
 default = []
+testing = []
 docker_test = []
 
 [dependencies]
diff --git a/src/contest/error.rs b/src/contest/error.rs
index 2c36571..733b545 100644
--- a/src/contest/error.rs
+++ b/src/contest/error.rs
@@ -2,6 +2,7 @@ use std::path::PathBuf;
 use std::error::Error as StdError;
 use thiserror::Error;
 use crate::config::ConfigError;
+use crate::docker::DockerError;
 
 /// コンテスト操作に関するエラー
 #[derive(Error, Debug)]
@@ -24,10 +25,9 @@ pub enum ContestError {
         message: String
     },
 
-    #[error("バックアップエラー: {message}, パス: {path:?}")]
-    Backup {
+    #[error("Dockerエラー: {message}")]
+    Docker {
         message: String,
-        path: PathBuf,
         source: Option<Box<dyn StdError + Send + Sync>>
     },
 
@@ -48,8 +48,8 @@ impl From<std::io::Error> for ContestError {
     }
 }
 
-impl From<serde_yaml::Error> for ContestError {
-    fn from(err: serde_yaml::Error) -> Self {
+impl From<ConfigError> for ContestError {
+    fn from(err: ConfigError) -> Self {
         ContestError::Config {
             message: err.to_string(),
             source: Some(Box::new(err))
@@ -57,9 +57,9 @@ impl From<serde_yaml::Error> for ContestError {
     }
 }
 
-impl From<serde_json::Error> for ContestError {
-    fn from(err: serde_json::Error) -> Self {
-        ContestError::Config {
+impl From<DockerError> for ContestError {
+    fn from(err: DockerError) -> Self {
+        ContestError::Docker {
             message: err.to_string(),
             source: Some(Box::new(err))
         }
@@ -74,15 +74,48 @@ impl From<String> for ContestError {
     }
 }
 
-impl From<ConfigError> for ContestError {
-    fn from(err: ConfigError) -> Self {
-        ContestError::Config {
-            message: err.to_string(),
-            source: Some(Box::new(err))
+/// エラーのコンテキスト情報
+#[derive(Debug, Clone)]
+pub struct ErrorContext {
+    pub operation: String,
+    pub location: String,
+    pub details: std::collections::HashMap<String, String>,
+}
+
+impl ErrorContext {
+    pub fn new(operation: impl Into<String>, location: impl Into<String>) -> Self {
+        Self {
+            operation: operation.into(),
+            location: location.into(),
+            details: std::collections::HashMap::new(),
         }
     }
+
+    pub fn add_detail(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {
+        self.details.insert(key.into(), value.into());
+        self
+    }
+
+    pub fn with_hint(mut self, hint: impl Into<String>) -> Self {
+        self.details.insert("hint".to_string(), hint.into());
+        self
+    }
+
+    #[cfg(debug_assertions)]
+    pub fn with_stack_trace(mut self) -> Self {
+        let backtrace = std::backtrace::Backtrace::capture();
+        self.details.insert("stack_trace".to_string(), format!("{:?}", backtrace));
+        self
+    }
+
+    #[cfg(not(debug_assertions))]
+    pub fn with_stack_trace(self) -> Self {
+        self
+    }
 }
 
+pub type Result<T> = std::result::Result<T, ContestError>;
+
 impl ContestError {
     pub fn with_context(self, operation: impl Into<String>, location: impl Into<String>) -> Self {
         match self {
@@ -98,9 +131,8 @@ impl ContestError {
             Self::Validation { message } => Self::Validation {
                 message: format!("{} (操作: {}, 場所: {})", message, operation.into(), location.into()),
             },
-            Self::Backup { message, path, source } => Self::Backup {
+            Self::Docker { message, source } => Self::Docker {
                 message: format!("{} (操作: {}, 場所: {})", message, operation.into(), location.into()),
-                path,
                 source,
             },
             Self::Transaction { message, context } => Self::Transaction {
@@ -124,9 +156,8 @@ impl ContestError {
             Self::Validation { message } => Self::Validation {
                 message: format!("{}. ヒント: {}", message, hint.into()),
             },
-            Self::Backup { message, path, source } => Self::Backup {
+            Self::Docker { message, source } => Self::Docker {
                 message: format!("{}. ヒント: {}", message, hint.into()),
-                path,
                 source,
             },
             Self::Transaction { message, context } => Self::Transaction {
@@ -136,46 +167,3 @@ impl ContestError {
         }
     }
 }
-
-/// エラーのコンテキスト情報
-#[derive(Debug, Clone)]
-pub struct ErrorContext {
-    pub operation: String,
-    pub location: String,
-    pub details: std::collections::HashMap<String, String>,
-}
-
-impl ErrorContext {
-    pub fn new(operation: impl Into<String>, location: impl Into<String>) -> Self {
-        Self {
-            operation: operation.into(),
-            location: location.into(),
-            details: std::collections::HashMap::new(),
-        }
-    }
-
-    pub fn add_detail(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {
-        self.details.insert(key.into(), value.into());
-        self
-    }
-
-    pub fn with_hint(mut self, hint: impl Into<String>) -> Self {
-        self.details.insert("hint".to_string(), hint.into());
-        self
-    }
-
-    #[cfg(debug_assertions)]
-    pub fn with_stack_trace(mut self) -> Self {
-        let backtrace = std::backtrace::Backtrace::capture();
-        self.details.insert("stack_trace".to_string(), format!("{:?}", backtrace));
-        self
-    }
-
-    #[cfg(not(debug_assertions))]
-    pub fn with_stack_trace(self) -> Self {
-        self
-    }
-}
-
-/// Result型のエイリアス
-pub type Result<T> = std::result::Result<T, ContestError>;
diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index 684d0ed..c6079fd 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -1,118 +1,26 @@
 use crate::config::Config;
-use crate::contest::model::ContestState;
+use crate::docker::DockerRunner;
 use crate::contest::error::Result;
-use crate::fs::FileManager;
 
-/// コンテスト情報を管理する構造体
-#[derive(Debug)]
 pub struct Contest {
-    /// 状態
-    state: ContestState,
-    /// 設定情報
     config: Config,
-    /// ファイルシステム操作
-    fs: FileManager,
+    docker_runner: DockerRunner,
 }
 
 impl Contest {
-    /// サイト認証用のコンテストインスタンスを作成
-    pub fn for_site_auth(config: Config) -> Result<Self> {
+    pub fn new(config: Config) -> Result<Self> {
+        let docker_runner = DockerRunner::new(config.clone(), "rust".to_string())?;
         Ok(Self {
-            state: ContestState::new(),
             config,
-            fs: FileManager::new()?,
+            docker_runner,
         })
     }
 
-    /// 新しいコンテストインスタンスを作成
-    pub fn new(config: Config, problem_id: &str) -> Result<Self> {
-        let default_lang = config.get::<String>("languages.default")?;
-        let active_dir = config.get::<String>(&format!("languages.{}.contest_dir.active", default_lang))?;
-        let state = ContestState::new()
-            .with_problem(problem_id)
-            .with_active_dir(active_dir.clone().into())
-            .with_language(&default_lang);
-
-        Ok(Self {
-            state,
-            config,
-            fs: FileManager::new()?.with_base_path(&active_dir),
-        })
-    }
-
-    /// 状態を取得
-    pub fn state(&self) -> &ContestState {
-        &self.state
-    }
-
-    /// 状態を可変で取得
-    pub fn state_mut(&mut self) -> &mut ContestState {
-        &mut self.state
-    }
-
-    /// 設定を取得
     pub fn config(&self) -> &Config {
         &self.config
     }
 
-    /// ファイルシステム操作を取得
-    pub fn fs(&self) -> &FileManager {
-        &self.fs
-    }
-
-    /// ファイルシステム操作を可変で取得
-    pub fn fs_mut(&mut self) -> &mut FileManager {
-        &mut self.fs
-    }
-
-    /// 状態を更新
-    pub fn update_state<F>(&mut self, f: F) -> Result<()>
-    where
-        F: FnOnce(&mut ContestState) -> Result<()>,
-    {
-        self.state.update(f)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    fn create_test_config() -> Config {
-        let yaml = r#"
-languages:
-  default: rust
-  rust:
-    contest_dir:
-      active: /tmp/contest
-"#;
-        Config::from_str(yaml, Config::builder()).unwrap()
-    }
-
-    #[test]
-    fn test_contest_creation() -> Result<()> {
-        let config = create_test_config();
-        let contest = Contest::new(config.clone(), "abc123")?;
-        
-        assert_eq!(contest.state().problem_id(), Some("abc123"));
-        assert_eq!(contest.state().language(), Some("rust"));
-        assert_eq!(contest.state().active_dir(), &std::path::PathBuf::from("/tmp/contest"));
-        Ok(())
-    }
-
-    #[test]
-    fn test_state_update() -> Result<()> {
-        let config = create_test_config();
-        let mut contest = Contest::for_site_auth(config)?;
-        
-        contest.update_state(|state| {
-            state.set_problem("abc123");
-            state.set_language("rust");
-            Ok(())
-        })?;
-
-        assert_eq!(contest.state().problem_id(), Some("abc123"));
-        assert_eq!(contest.state().language(), Some("rust"));
-        Ok(())
+    pub fn docker_runner(&mut self) -> &mut DockerRunner {
+        &mut self.docker_runner
     }
 } 
\ No newline at end of file
diff --git a/src/docker/executor.rs b/src/docker/executor.rs
index 13b4d82..ec555de 100644
--- a/src/docker/executor.rs
+++ b/src/docker/executor.rs
@@ -17,6 +17,12 @@ pub trait DockerCommandExecutor: Send + Sync {
         command: &str,
         timeout_seconds: u32,
     ) -> DockerResult<String>;
+    async fn list_container_files(
+        &self,
+        container_name: &str,
+        image: &str,
+        mount_point: &str,
+    ) -> DockerResult<String>;
 }
 
 pub struct DefaultDockerExecutor;
@@ -27,7 +33,7 @@ impl DefaultDockerExecutor {
     }
 }
 
-#[async_trait]
+#[async_trait::async_trait]
 impl DockerCommandExecutor for DefaultDockerExecutor {
     async fn check_image(&self, image: &str) -> DockerResult<bool> {
         let output = Command::new("docker")
@@ -105,22 +111,51 @@ impl DockerCommandExecutor for DefaultDockerExecutor {
 
         Ok(String::from_utf8_lossy(&output.stdout).to_string())
     }
+
+    async fn list_container_files(
+        &self,
+        container_name: &str,
+        image: &str,
+        mount_point: &str,
+    ) -> DockerResult<String> {
+        let mut cmd = Command::new("docker");
+        cmd.arg("run")
+            .arg("--rm")
+            .arg("--name")
+            .arg(container_name)
+            .arg(image)
+            .arg("ls")
+            .arg("-la")
+            .arg(mount_point);
+
+        let output = cmd.output()
+            .await
+            .map_err(|e| DockerError::Runtime(e.to_string()))?;
+
+        if !output.status.success() {
+            return Err(DockerError::Runtime(
+                String::from_utf8_lossy(&output.stderr).to_string()
+            ));
+        }
+
+        Ok(String::from_utf8_lossy(&output.stdout).to_string())
+    }
 }
 
-#[cfg(test)]
+#[cfg(any(test, feature = "testing"))]
 pub struct MockDockerExecutor {
     should_fail: bool,
 }
 
-#[cfg(test)]
+#[cfg(any(test, feature = "testing"))]
 impl MockDockerExecutor {
     pub fn new(should_fail: bool) -> Self {
         Self { should_fail }
     }
 }
 
-#[cfg(test)]
-#[async_trait]
+#[cfg(any(test, feature = "testing"))]
+#[async_trait::async_trait]
 impl DockerCommandExecutor for MockDockerExecutor {
     async fn check_image(&self, _image: &str) -> DockerResult<bool> {
         Ok(true)
@@ -137,13 +172,30 @@ impl DockerCommandExecutor for MockDockerExecutor {
         _memory_limit: u32,
         _mount_source: &str,
         _mount_target: &str,
-        _command: &str,
+        command: &str,
         _timeout_seconds: u32,
     ) -> DockerResult<String> {
         if self.should_fail {
-            Err(DockerError::Runtime("Mock execution failed".to_string()))
+            Err(DockerError::Runtime("モックエラー".to_string()))
         } else {
-            Ok("Hello from Rust!\n".to_string())
+            if command.contains("main.rs") {
+                Ok("Hello from Rust!\n".to_string())
+            } else if command.contains("main.py") {
+                Ok("Hello from Python!\n".to_string())
+            } else if command.contains("main.cpp") {
+                Ok("Hello from C++!\n".to_string())
+            } else {
+                Ok("実行成功\n".to_string())
+            }
         }
     }
+
+    async fn list_container_files(
+        &self,
+        _container_name: &str,
+        _image: &str,
+        _mount_point: &str,
+    ) -> DockerResult<String> {
+        Ok("total 4\ndrwxr-xr-x 2 root root 4096 Jan 1 00:00 .\n".to_string())
+    }
 } 
\ No newline at end of file
diff --git a/src/docker/fs.rs b/src/docker/fs.rs
index bdf1ae8..05a7416 100644
--- a/src/docker/fs.rs
+++ b/src/docker/fs.rs
@@ -89,37 +89,59 @@ impl DockerFileManager for DefaultDockerFileManager {
     }
 }
 
-#[cfg(test)]
+#[cfg(any(test, feature = "testing"))]
 pub struct MockDockerFileManager {
     temp_dir: TempDir,
+    should_fail: bool,
 }
 
-#[cfg(test)]
+#[cfg(any(test, feature = "testing"))]
 impl MockDockerFileManager {
     pub fn new() -> Self {
         Self {
             temp_dir: TempDir::new().unwrap(),
+            should_fail: false,
         }
     }
+
+    pub fn set_should_fail(&mut self, should_fail: bool) {
+        self.should_fail = should_fail;
+    }
 }
 
-#[cfg(test)]
+#[cfg(any(test, feature = "testing"))]
 impl DockerFileManager for MockDockerFileManager {
     fn create_temp_directory(&self) -> DockerResult<PathBuf> {
+        if self.should_fail {
+            return Err(DockerError::Filesystem("モックエラー".to_string()));
+        }
         Ok(self.temp_dir.path().to_path_buf())
     }
 
     fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf> {
+        if self.should_fail {
+            return Err(DockerError::Filesystem("モックエラー".to_string()));
+        }
         let file_path = dir.join(filename);
         fs::write(&file_path, content)?;
         Ok(file_path)
     }
 
-    fn set_permissions(&self, _path: &Path, _mode: u32) -> DockerResult<()> {
-        Ok(())
+    fn set_permissions(&self, path: &Path, _mode: u32) -> DockerResult<()> {
+        if self.should_fail {
+            return Err(DockerError::Filesystem("モックエラー".to_string()));
+        }
+        if path.exists() {
+            Ok(())
+        } else {
+            Err(DockerError::Filesystem(format!("Path does not exist: {:?}", path)))
+        }
     }
 
     fn cleanup(&self, _dir: &Path) -> DockerResult<()> {
+        if self.should_fail {
+            return Err(DockerError::Filesystem("モックエラー".to_string()));
+        }
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
index c2a2a72..4f7a321 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,7 +1,9 @@
+#[cfg(test)]
+mod tests {
+    use super::*;
+}
+
+pub mod config;
 pub mod docker;
-pub mod error;
-pub mod test;
 pub mod contest;
-pub mod oj;
-pub mod config;
-pub mod fs;
+pub mod test;
diff --git a/tests/docker/mod.rs b/tests/docker/mod.rs
index 34cbca8..de202e9 100644
--- a/tests/docker/mod.rs
+++ b/tests/docker/mod.rs
@@ -1,27 +1,5 @@
-#[cfg(test)]
-mod runner_test;
-#[cfg(test)]
-mod config_test;
+mod unit_test;
+mod integration_test;
 
-use std::process::Command;
-
-// Dockerデーモンが利用可能かチェックする
-pub fn check_docker_available() -> bool {
-    Command::new("docker")
-        .arg("info")
-        .output()
-        .map(|output| output.status.success())
-        .unwrap_or(false)
-}
-
-// テストの前に実行される初期化処理
-pub fn setup() {
-    if !check_docker_available() {
-        panic!("Dockerデーモンが利用できません。Dockerが起動していることを確認してください。");
-    }
-}
-
-// テストの後に実行されるクリーンアップ処理
-pub fn teardown() {
-    // 必要に応じてコンテナやイメージのクリーンアップを実行
-} 
\ No newline at end of file
+pub use unit_test::*;
+pub use integration_test::*; 
\ No newline at end of file
diff --git a/tests/docker/runner_test.rs b/tests/docker/runner_test.rs
deleted file mode 100644
index bf8497f..0000000
--- a/tests/docker/runner_test.rs
+++ /dev/null
@@ -1,301 +0,0 @@
-use std::process::Command;
-use cph::config::Config;
-use cph::docker::{DockerRunner, DockerError};
-use std::fs;
-use std::path::PathBuf;
-use std::os::unix::fs::PermissionsExt;
-use crate::helpers::docker_debug;
-
-fn setup() -> PathBuf {
-    let temp_dir = std::env::temp_dir().join("cph-test");
-    fs::create_dir_all(&temp_dir).unwrap();
-    temp_dir
-}
-
-fn teardown(temp_dir: &PathBuf) {
-    let _ = fs::remove_dir_all(temp_dir);
-}
-
-// Dockerデーモンが利用可能かチェックする
-fn check_docker_available() -> bool {
-    Command::new("docker")
-        .arg("info")
-        .output()
-        .map(|output| output.status.success())
-        .unwrap_or(false)
-}
-
-#[tokio::test]
-async fn test_docker_runner_creation() {
-    let config = Config::load().unwrap();
-    let runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-    assert!(runner.get_state().await == cph::docker::RunnerState::Ready);
-}
-
-#[tokio::test]
-async fn test_docker_runner_from_language() {
-    let runner = DockerRunner::from_language("rust").unwrap();
-    assert!(runner.get_state().await == cph::docker::RunnerState::Ready);
-}
-
-#[tokio::test]
-async fn test_docker_available() {
-    assert!(check_docker_available(), "Dockerが利用できません");
-}
-
-#[tokio::test]
-async fn test_rust_runner() {
-    let temp_dir = setup();
-    println!("=== Test Directory ===");
-    println!("{}", temp_dir.display());
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    let source_code = r#"fn main() {
-    println!("Hello from Rust!");
-}"#;
-
-    println!("=== Initial Directory State ===");
-    println!("{}", docker_debug::inspect_directory(&temp_dir));
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== Execution Output ===");
-            println!("{}", output);
-            println!("=== Final Directory State ===");
-            println!("{}", docker_debug::inspect_directory(&temp_dir));
-            assert!(output.contains("Hello from Rust!"));
-        }
-        Err(e) => {
-            println!("Error: {}", e);
-            println!("=== Final Directory State ===");
-            println!("{}", docker_debug::inspect_directory(&temp_dir));
-            panic!("実行に失敗しました");
-        }
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_timeout() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    let source_code = r#"
-        fn main() {
-            loop {}
-        }
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("タイムアウトが発生しませんでした"),
-        Err(e) => match e {
-            DockerError::Timeout(_) => (),
-            _ => panic!("予期しないエラー: {}", e),
-        },
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_memory_limit() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    let source_code = r#"
-        fn main() {
-            let mut v = Vec::new();
-            loop {
-                v.extend(vec![1; 1024 * 1024]); // 1MB
-            }
-        }
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("メモリ制限が機能してせんでした"),
-        Err(e) => match e {
-            DockerError::Memory(_) | DockerError::Runtime(_) => (),
-            _ => panic!("予期しないエラー: {}", e),
-        },
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_compilation_error() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    let source_code = r#"
-        fn main() {
-            let x: i32 = "not a number";
-        }
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("コンパイルエラーが検出されませんでした"),
-        Err(e) => assert!(e.to_string().contains("error")),
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_pypy_runner() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "pypy".to_string()).unwrap();
-
-    let source_code = r#"
-print("Hello from PyPy!")
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== PyPy Execution Output ===");
-            println!("{}", output);
-            assert!(output.contains("Hello from PyPy!"));
-        }
-        Err(e) => {
-            println!("Error: {}", e);
-            panic!("PyPyの実行に失敗しました: {}", e);
-        }
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_python_runner() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "python".to_string()).unwrap();
-
-    let source_code = r#"
-print("Hello from Python!")
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== Python Execution Output ===");
-            println!("{}", output);
-            assert!(output.contains("Hello from Python!"));
-        }
-        Err(e) => {
-            println!("Error: {}", e);
-            panic!("Pythonの実行に失敗しました: {}", e);
-        }
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_cpp_runner_with_extension() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "cpp".to_string()).unwrap();
-
-    let source_code = r#"
-#include <iostream>
-int main() {
-    std::cout << "Hello from C++!" << std::endl;
-    return 0;
-}
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== C++ Execution Output ===");
-            println!("{}", output);
-            assert!(output.contains("Hello from C++!"));
-        }
-        Err(e) => {
-            println!("Error: {}", e);
-            panic!("C++の実行に失敗しました: {}", e);
-        }
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_rust_runner_with_extension() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    let source_code = r#"fn main() {
-    println!("Hello from Rust!");
-}"#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== Rust Execution Output ===");
-            println!("{}", output);
-            assert!(output.contains("Hello from Rust!"));
-        }
-        Err(e) => {
-            println!("Error: {}", e);
-            panic!("Rustの実行に失敗しました: {}", e);
-        }
-    }
-
-    teardown(&temp_dir);
-}
-
-#[tokio::test]
-async fn test_mount_point() {
-    let temp_dir = setup();
-    
-    let config = Config::load().unwrap();
-    let mut runner = DockerRunner::new(config, "rust".to_string()).unwrap();
-
-    // テスト用のファイルを作成
-    let test_file = temp_dir.join("test.txt");
-    fs::write(&test_file, "test content").unwrap();
-    fs::set_permissions(&test_file, fs::Permissions::from_mode(0o644)).unwrap();
-
-    println!("=== Local Directory Contents ===");
-    println!("{}", docker_debug::inspect_directory(&temp_dir));
-
-    // 単純なファイル読み込みプログラムを実行
-    let source_code = r#"
-        use std::fs;
-        fn main() {
-            match fs::read_to_string("/app/test.txt") {
-                Ok(content) => println!("File content: {}", content),
-                Err(e) => eprintln!("Error reading file: {}", e),
-            }
-        }
-    "#;
-
-    match runner.run_in_docker(source_code).await {
-        Ok(output) => {
-            println!("=== Execution Output ===");
-            println!("{}", output);
-            assert!(output.contains("test content"), "ファイルの内容が読み取れません\n出力: {}", output);
-        }
-        Err(e) => {
-            println!("=== Error Output ===");
-            println!("Error: {}", e);
-            panic!("マウントポイントのテストに失敗しました: {}", e);
-        }
-    }
-
-    teardown(&temp_dir);
-} 
\ No newline at end of file
diff --git a/tests/helpers/mod.rs b/tests/helpers/mod.rs
index 83ccab1..639f169 100644
--- a/tests/helpers/mod.rs
+++ b/tests/helpers/mod.rs
@@ -9,43 +9,7 @@ thread_local! {
     static TEST_DIR: std::cell::RefCell<Option<TempDir>> = std::cell::RefCell::new(None);
 }
 
-pub mod docker_debug {
-    use std::path::Path;
-    use std::process::Command;
-
-    pub fn inspect_directory(path: &Path) -> String {
-        let output = Command::new("ls")
-            .arg("-la")
-            .arg(path)
-            .output()
-            .unwrap_or_else(|e| panic!("Failed to inspect directory: {}", e));
-
-        String::from_utf8_lossy(&output.stdout).to_string()
-    }
-
-    pub fn inspect_docker_container(container_name: &str, path: &str) -> String {
-        let output = Command::new("docker")
-            .arg("exec")
-            .arg(container_name)
-            .arg("ls")
-            .arg("-la")
-            .arg(path)
-            .output()
-            .unwrap_or_else(|e| panic!("Failed to inspect container: {}", e));
-
-        String::from_utf8_lossy(&output.stdout).to_string()
-    }
-
-    pub fn get_docker_logs(container_name: &str) -> String {
-        let output = Command::new("docker")
-            .arg("logs")
-            .arg(container_name)
-            .output()
-            .unwrap_or_else(|e| panic!("Failed to get container logs: {}", e));
-
-        String::from_utf8_lossy(&output.stdout).to_string()
-    }
-}
+pub mod docker_debug;
 
 pub fn setup() {
     // テスト用の一時ディレクトリを作成
diff --git a/tests/mod.rs b/tests/mod.rs
index ffa468d..554ebd7 100644
--- a/tests/mod.rs
+++ b/tests/mod.rs
@@ -1,8 +1,2 @@
 pub mod docker;
-pub mod helpers;
-mod fs;
-
-#[cfg(test)]
-mod tests {
-    // テストコードがある場合はここに記述
-} 
\ No newline at end of file
+pub mod helpers; 
\ No newline at end of file
