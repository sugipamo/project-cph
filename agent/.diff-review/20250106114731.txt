diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index b411056..8ddeb0f 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -1,52 +1,25 @@
 use std::sync::Arc;
 use tokio::sync::Mutex;
 use crate::contest::error::{ContestResult, ContestError};
-use crate::docker::traits::DockerOperations;
+use crate::docker::traits::ContainerOperations;
 use crate::docker::config::ContainerConfig;
 
 pub struct ContestService {
-    docker_operations: Arc<Mutex<dyn DockerOperations>>,
+    docker_operations: Arc<Mutex<dyn ContainerOperations>>,
 }
 
 impl ContestService {
-    pub fn new(docker_operations: Arc<Mutex<dyn DockerOperations>>) -> Self {
+    pub fn new(docker_operations: Arc<Mutex<dyn ContainerOperations>>) -> Self {
         Self {
             docker_operations,
         }
     }
 
-    pub async fn run_contest(&self, source_code: &str) -> ContestResult<String> {
-        self.compile_source(source_code).await?;
-        self.run_tests().await
-    }
-
-    async fn compile_source(&self, source_code: &str) -> ContestResult<()> {
-        let mut ops = self.docker_operations.lock().await;
-        let config = ContainerConfig::new(
-            "rust:latest".to_string(),
-            512,
-            "/workspace".to_string(),
-            "/tmp".to_string(),
-        );
-
-        ops.initialize(config).await
+    pub async fn initialize(&self, config: ContainerConfig) -> ContestResult<()> {
+        let mut operations = self.docker_operations.lock().await;
+        operations.execute_command("echo 'Initializing...'", None)
+            .await
             .map_err(|e| ContestError::Docker(e.to_string()))?;
-        
-        ops.start().await
-            .map_err(|e| ContestError::Docker(e.to_string()))?;
-
         Ok(())
     }
-
-    async fn run_tests(&self) -> ContestResult<String> {
-        let mut ops = self.docker_operations.lock().await;
-        let (stdout, stderr) = ops.execute("cargo test").await
-            .map_err(|e| ContestError::Docker(e.to_string()))?;
-
-        if stderr.is_empty() {
-            Ok(stdout)
-        } else {
-            Err(ContestError::Docker(stderr))
-        }
-    }
 } 
\ No newline at end of file
diff --git a/src/docker/error.rs b/src/docker/error.rs
index a05f24d..4c99ba2 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,35 +1,43 @@
-use thiserror::Error;
-use tokio::time::error::Elapsed;
-use crate::docker::state::StateError;
+use std::fmt;
+use std::error::Error;
+use std::io;
+use nix::errno::Errno;
 
-#[derive(Debug, Error)]
+#[derive(Debug)]
 pub enum DockerError {
-    #[error("コマンドの実行に失敗しました: {0}")]
+    Container(String),
+    State(String),
+    Compilation(String),
     Command(String),
-
-    #[error("コンテナの状態エラー: {0}")]
-    State(#[from] StateError),
-
-    #[error("タイムアウトエラー")]
-    Timeout(#[from] Elapsed),
-
-    #[error("ファイルシステムエラー: {0}")]
     Filesystem(String),
-
-    #[error("システムエラー: {0}")]
     System(String),
 }
 
-impl From<nix::errno::Errno> for DockerError {
-    fn from(err: nix::errno::Errno) -> Self {
-        DockerError::System(err.to_string())
+impl fmt::Display for DockerError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            DockerError::Container(msg) => write!(f, "コンテナエラー: {}", msg),
+            DockerError::State(msg) => write!(f, "状態管理エラー: {}", msg),
+            DockerError::Compilation(msg) => write!(f, "コンパイルエラー: {}", msg),
+            DockerError::Command(msg) => write!(f, "コマンドエラー: {}", msg),
+            DockerError::Filesystem(msg) => write!(f, "ファイルシステムエラー: {}", msg),
+            DockerError::System(msg) => write!(f, "システムエラー: {}", msg),
+        }
     }
 }
 
-impl From<std::io::Error> for DockerError {
-    fn from(err: std::io::Error) -> Self {
+impl Error for DockerError {}
+
+impl From<io::Error> for DockerError {
+    fn from(err: io::Error) -> Self {
         DockerError::Filesystem(err.to_string())
     }
 }
 
+impl From<Errno> for DockerError {
+    fn from(err: Errno) -> Self {
+        DockerError::System(err.to_string())
+    }
+}
+
 pub type DockerResult<T> = Result<T, DockerError>; 
\ No newline at end of file
diff --git a/src/docker/mod.rs b/src/docker/mod.rs
index 1adc6e2..dc38b1e 100644
--- a/src/docker/mod.rs
+++ b/src/docker/mod.rs
@@ -1,9 +1,13 @@
 pub mod config;
 pub mod error;
 pub mod fs;
-pub mod runner;
+pub mod executor;
 pub mod state;
 pub mod traits;
+pub mod runner;
 
-pub use runner::{DockerRunner, DockerRunnerManager, DockerCommand, DockerCommandExecutor, CommandOutput, DefaultDockerExecutor};
-pub use state::container::{ContainerState as RunnerState, ContainerStateManager, StateError}; 
\ No newline at end of file
+pub use runner::{
+    container_manager::DefaultContainerManager,
+    compilation_manager::DefaultCompilationManager,
+};
+pub use executor::{DockerCommand, DockerCommandExecutor}; 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 5067662..4086859 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -1,294 +1,33 @@
-use std::sync::Arc;
-use std::time::Duration;
-use tokio::sync::Mutex;
-use tokio::time::timeout;
-
-use crate::docker::error::{DockerError, DockerResult};
-use crate::docker::state::container::{ContainerState, ContainerStateManager};
-use crate::docker::config::ContainerConfig;
-use crate::docker::traits::ContainerManager;
-
-mod manager;
-mod executor;
-
-pub use manager::DockerRunnerManager;
-pub use executor::{DockerCommand, DockerCommandExecutor, CommandOutput, DefaultDockerExecutor};
-
-pub struct DockerRunner {
-    container_manager: Arc<Mutex<dyn ContainerManager>>,
-    state_manager: Arc<ContainerStateManager>,
-    timeout: Duration,
-    docker_executor: Arc<dyn DockerCommandExecutor>,
-}
-
-impl DockerRunner {
-    pub fn new(
-        container_manager: Arc<Mutex<dyn ContainerManager>>,
-        docker_executor: Arc<dyn DockerCommandExecutor>,
-        timeout: Duration
-    ) -> Self {
-        Self {
-            container_manager,
-            state_manager: Arc::new(ContainerStateManager::new()),
-            timeout,
-            docker_executor,
-        }
-    }
-
-    pub async fn initialize(&mut self, config: ContainerConfig) -> DockerResult<()> {
-        let mut manager = self.container_manager.lock().await;
-        manager.create_container(&config.image, vec![], &config.working_dir).await?;
-
-        let container_id = manager.get_container_id().await?;
-        self.state_manager.set_container_id(container_id.clone()).await;
-        
-        self.state_manager.create_container(container_id)
-            .await
-            .map_err(DockerError::State)
-    }
-
-    pub async fn start(&mut self) -> DockerResult<()> {
-        let container_id = {
-            let manager = self.container_manager.lock().await;
-            manager.get_container_id().await?
-        };
-
-        {
-            let mut manager = self.container_manager.lock().await;
-            manager.start_container().await?;
-        }
-
-        self.state_manager.start_container(container_id)
-            .await
-            .map_err(DockerError::State)
-    }
-
-    pub async fn stop(&mut self) -> DockerResult<()> {
-        let container_id = {
-            let manager = self.container_manager.lock().await;
-            manager.get_container_id().await?
-        };
-
-        let exit_code = {
-            let mut manager = self.container_manager.lock().await;
-            manager.stop_container().await?;
-            manager.get_exit_code().await?
-        };
-
-        self.state_manager.stop_container(container_id, exit_code)
-            .await
-            .map_err(DockerError::State)
-    }
-
-    pub async fn execute(&mut self, command: &str) -> DockerResult<(String, String)> {
-        let container_id = {
-            let manager = self.container_manager.lock().await;
-            manager.get_container_id().await?
-        };
-
-        // コマンド実行状態に遷移
-        self.state_manager.execute_command(container_id.clone(), command.to_string())
-            .await
-            .map_err(DockerError::State)?;
-
-        // タイムアウト付きでコマンドを実行
-        let command = DockerCommand::new("exec")
-            .arg("-i")
-            .arg(&container_id)
-            .arg("sh")
-            .arg("-c")
-            .arg(command);
-
-        let result = timeout(self.timeout, self.docker_executor.execute(command)).await;
-
-        match result {
-            Ok(cmd_result) => {
-                match cmd_result {
-                    Ok(output) => {
-                        self.state_manager.start_container(container_id)
-                            .await
-                            .map_err(DockerError::State)?;
-                        Ok((output.stdout, output.stderr))
-                    }
-                    Err(e) => {
-                        self.state_manager.fail_container(
-                            container_id,
-                            e.to_string(),
-                        ).await.map_err(DockerError::State)?;
-                        Err(e)
-                    }
-                }
-            }
-            Err(_) => {
-                let error = format!("コマンドの実行がタイムアウトしました（{}秒）", self.timeout.as_secs());
-                self.state_manager.fail_container(container_id, error.clone())
-                    .await
-                    .map_err(DockerError::State)?;
-                Err(DockerError::Command("コマンドの実行がタイムアウトしました".to_string()))
-            }
-        }
-    }
-
-    pub async fn subscribe_to_state_changes(&self) -> tokio::sync::mpsc::Receiver<ContainerState> {
-        self.state_manager.subscribe().await
-    }
+pub mod container_manager;
+pub mod compilation_manager;
+
+pub use container_manager::DefaultContainerManager;
+pub use compilation_manager::DefaultCompilationManager;
+pub use crate::docker::executor::{DockerCommand, DockerCommandExecutor};
+
+# レビュー結果
+
+## 重要な機能の削除
+- DockerOperationsからContainerOperationsへのインターフェース変更
+- ContestServiceの機能が大幅に簡素化（compile_sourceとrun_testsの削除）
+- エラー処理の実装が変更（thiserrorからstd::errorへ）
+- モジュール構造の変更（runnerの再構成）
+
+## コンパイルエラー
+- container_managerの所有権に関する問題が発生
+- 未使用の変数やインポートに関する警告が複数存在
+
+## 推奨される対応
+1. container_managerの所有権問題を解決する必要があります
+2. 削除された機能の代替実装を確認する必要があります
+3. 未使用の変数やインポートを整理する必要があります
+
+## 結論
+現状のコードには重要な問題があり、作業を中断して修正を行う必要があります。
 
-    pub async fn get_current_state(&self) -> ContainerState {
-        self.state_manager.get_current_state().await
-    }
-}
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::docker::executor::CommandOutput;
+    use mockall::mock;
+    use tokio::time::sleep;
+
+    mock! {
+        DockerExecutor {}
+        #[async_trait::async_trait]
+        impl DockerCommandExecutor for DockerExecutor {
+            async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput>;
+        }
+    }
+
+    mock! {
+        ContainerOps {}
+        #[async_trait::async_trait]
+        impl ContainerManager for ContainerOps {
+            async fn create_container(&mut self, image: &str, cmd: Vec<String>, working_dir: &str) -> DockerResult<()>;
+            async fn start_container(&mut self) -> DockerResult<()>;
+            async fn stop_container(&mut self) -> DockerResult<()>;
+            async fn get_container_id(&self) -> DockerResult<String>;
+            async fn get_exit_code(&self) -> DockerResult<i32>;
+            async fn check_image(&self, image: &str) -> DockerResult<bool>;
+            async fn pull_image(&self, image: &str) -> DockerResult<()>;
+        }
+    }
+
+    #[tokio::test]
+    async fn test_docker_runner_lifecycle() {
+        let mut mock_executor = MockDockerExecutor::new();
+        mock_executor
+            .expect_execute()
+            .returning(|_| Ok(CommandOutput {
+                success: true,
+                stdout: "container_id".to_string(),
+                stderr: "".to_string(),
+            }));
+
+        let mut mock_ops = MockContainerOps::new();
+        mock_ops
+            .expect_create_container()
+            .returning(|_, _, _| Ok(()));
+        mock_ops
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
+        mock_ops
+            .expect_start_container()
+            .returning(|| Ok(()));
+        mock_ops
+            .expect_stop_container()
+            .returning(|| Ok(()));
+        mock_ops
+            .expect_get_exit_code()
+            .returning(|| Ok(0));
+
+        let mut runner = DockerRunner::new(
+            Arc::new(Mutex::new(mock_ops)),
+            Arc::new(mock_executor),
+            Duration::from_secs(30),
+        );
+
+        // Test initialization
+        let config = ContainerConfig {
+            image: "test-image".to_string(),
+            memory_limit: 512,
+            mount_point: "/tmp".to_string(),
+            working_dir: "/workspace".to_string(),
+        };
+        assert!(runner.initialize(config).await.is_ok());
+
+        // Test state transitions
+        let state = runner.get_current_state().await;
+        assert!(matches!(state, ContainerState::Created { .. }));
+
+        assert!(runner.start().await.is_ok());
+        let state = runner.get_current_state().await;
+        assert!(matches!(state, ContainerState::Running { .. }));
+
+        assert!(runner.stop().await.is_ok());
+        let state = runner.get_current_state().await;
+        assert!(matches!(state, ContainerState::Stopped { .. }));
+    }
+
+    #[tokio::test]
+    async fn test_command_timeout() {
+        let mut mock_executor = MockDockerExecutor::new();
+        mock_executor
+            .expect_execute()
+            .returning(|_| {
+                sleep(Duration::from_secs(2));
+                Ok(CommandOutput {
+                    success: true,
+                    stdout: "".to_string(),
+                    stderr: "".to_string(),
+                })
+            });
+
+        let mut mock_ops = MockContainerOps::new();
+        mock_ops
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
+
+        let mut runner = DockerRunner::new(
+            Arc::new(Mutex::new(mock_ops)),
+            Arc::new(mock_executor),
+            Duration::from_secs(1),
+        );
+
+        let result = runner.execute("test_command").await;
+        assert!(matches!(result, Err(DockerError::Command(_))));
+
+        let state = runner.get_current_state().await;
+        assert!(matches!(state, ContainerState::Failed { .. }));
+    }
+
+    #[tokio::test]
+    async fn test_exit_code() {
+        let mut mock_executor = MockDockerExecutor::new();
+        mock_executor
+            .expect_execute()
+            .returning(|_| Ok(CommandOutput {
+                success: true,
+                stdout: "".to_string(),
+                stderr: "".to_string(),
+            }));
+
+        let mut mock_ops = MockContainerOps::new();
+        mock_ops
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
+        mock_ops
+            .expect_stop_container()
+            .returning(|| Ok(()));
+        mock_ops
+            .expect_get_exit_code()
+            .returning(|| Ok(137));
+
+        let mut runner = DockerRunner::new(
+            Arc::new(Mutex::new(mock_ops)),
+            Arc::new(mock_executor),
+            Duration::from_secs(30),
+        );
+
+        assert!(runner.stop().await.is_ok());
+        let state = runner.get_current_state().await;
+        if let ContainerState::Stopped { exit_code, .. } = state {
+            assert_eq!(exit_code, 137);
+        } else {
+            panic!("Expected Stopped state");
+        }
+    }
 } 
\ No newline at end of file
diff --git a/src/docker/state/mod.rs b/src/docker/state/mod.rs
index 65bc1e5..57f9758 100644
--- a/src/docker/state/mod.rs
+++ b/src/docker/state/mod.rs
@@ -1,2 +1,3 @@
-pub mod container;
-pub use container::{ContainerState, ContainerStateManager, StateError}; 
\ No newline at end of file
+pub mod manager;
+
+pub use manager::DefaultStateManager; 
\ No newline at end of file
diff --git a/src/docker/traits.rs b/src/docker/traits.rs
deleted file mode 100644
index 83e2f54..0000000
--- a/src/docker/traits.rs
+++ /dev/null
@@ -1,53 +0,0 @@
-use async_trait::async_trait;
-use std::time::Duration;
-use crate::docker::error::DockerResult;
-use crate::docker::config::ContainerConfig;
-
-#[async_trait]
-pub trait ContainerManager: Send + Sync {
-    async fn create_container(&mut self, image: &str, cmd: Vec<String>, working_dir: &str) -> DockerResult<()>;
-    async fn start_container(&mut self) -> DockerResult<()>;
-    async fn stop_container(&mut self) -> DockerResult<()>;
-    async fn get_container_id(&self) -> DockerResult<String>;
-    async fn get_exit_code(&self) -> DockerResult<i32>;
-    async fn check_image(&self, image: &str) -> DockerResult<bool>;
-    async fn pull_image(&self, image: &str) -> DockerResult<()>;
-}
-
-#[async_trait]
-pub trait DockerOperations: Send + Sync {
-    /// コンテナを作成し、初期化する
-    async fn initialize(&mut self, config: ContainerConfig) -> DockerResult<()>;
-
-    /// コンテナを起動する
-    async fn start(&mut self) -> DockerResult<()>;
-
-    /// コンテナを停止する
-    async fn stop(&mut self) -> DockerResult<()>;
-
-    /// コンテナにコマンドを実行する
-    async fn execute(&mut self, command: &str) -> DockerResult<(String, String)>;
-
-    /// コンテナの標準入力にデータを書き込む
-    async fn write(&mut self, input: &str) -> DockerResult<()>;
-
-    /// コンテナの標準出力からデータを読み取る
-    async fn read_stdout(&mut self, timeout: Duration) -> DockerResult<String>;
-
-    /// コンテナの標準エラー出力からデータを読み取る
-    async fn read_stderr(&mut self, timeout: Duration) -> DockerResult<String>;
-}
-
-#[async_trait]
-pub trait CompilationOperations: Send + Sync {
-    /// ソースコードをコンパイルする
-    async fn compile(
-        &mut self,
-        source_code: &str,
-        compile_cmd: Option<Vec<String>>,
-        env_vars: Vec<String>,
-    ) -> DockerResult<()>;
-
-    /// コンパイル結果を取得する
-    async fn get_compilation_output(&self) -> DockerResult<(String, String)>;
-} 
\ No newline at end of file
