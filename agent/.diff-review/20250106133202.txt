diff --git a/src/contest/error.rs b/src/contest/error.rs
index 774ee1d..c1adb98 100644
--- a/src/contest/error.rs
+++ b/src/contest/error.rs
@@ -1,23 +1,13 @@
-use thiserror::Error;
-use std::io;
-use crate::docker::error::DockerError;
+use crate::error::CphError;
 
-#[derive(Error, Debug)]
-pub enum ContestError {
-    #[error("IO error: {0}")]
-    IO(#[from] io::Error),
-    
-    #[error("Docker error: {0}")]
-    Docker(String),
-    
-    #[error("Invalid configuration: {0}")]
-    Config(String),
+pub fn site_err(msg: String) -> CphError {
+    CphError::Contest(format!("サイトエラー: {}", msg))
 }
 
-impl From<DockerError> for ContestError {
-    fn from(err: DockerError) -> Self {
-        ContestError::Docker(err.to_string())
-    }
+pub fn language_err(msg: String) -> CphError {
+    CphError::Contest(format!("言語エラー: {}", msg))
 }
 
-pub type ContestResult<T> = Result<T, ContestError>;
+pub fn config_err(msg: String) -> CphError {
+    CphError::Contest(format!("設定エラー: {}", msg))
+}
diff --git a/src/contest/model/state.rs b/src/contest/model/state.rs
index 19ccbf6..2a916b8 100644
--- a/src/contest/model/state.rs
+++ b/src/contest/model/state.rs
@@ -1,172 +1,43 @@
 use std::path::PathBuf;
-use serde::{Serialize, Deserialize};
-use crate::contest::error::{ContestError};
+use crate::error::Result;
+use crate::contest::error::config_err;
 
-/// コンテストの状態を表す構造体
-#[derive(Debug, Default, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone)]
 pub struct ContestState {
-    /// アクティブなコンテストのディレクトリ
-    #[serde(default)]
-    pub active_contest_dir: PathBuf,
-
-    /// コンテスト情報
-    #[serde(default)]
-    pub contest: String,
-
-    /// 問題ID
-    pub problem_id: Option<String>,
-
-    /// 使用言語
-    pub language: Option<String>,
-
-    /// サイトID（例: atcoder, codeforces）
-    #[serde(default)]
     pub site: String,
+    pub contest_id: String,
+    pub problem_id: String,
+    pub language: String,
+    pub source_path: PathBuf,
 }
 
 impl ContestState {
-    /// 新しい状態を作成
-    pub fn new() -> Self {
-        Self::default()
-    }
-
-    /// 問題IDを設定
-    pub fn with_problem(mut self, problem_id: &str) -> Self {
-        self.problem_id = Some(problem_id.to_string());
-        self
-    }
-
-    /// 言語を設定
-    pub fn with_language(mut self, language: &str) -> Self {
-        self.language = Some(language.to_string());
-        self
-    }
-
-    /// コンテスト情報を設定
-    pub fn with_contest(mut self, contest_id: &str) -> Self {
-        self.contest = contest_id.to_string();
-        self
-    }
-
-    /// サイトIDを設定
-    pub fn with_site(mut self, site: &str) -> Self {
-        self.site = site.to_string();
-        self
-    }
-
-    /// アクティブディレクトリを設定
-    pub fn with_active_dir(mut self, dir: PathBuf) -> Self {
-        self.active_contest_dir = dir;
-        self
-    }
-
-    /// 問題IDを取得
-    pub fn problem_id(&self) -> Option<&str> {
-        self.problem_id.as_deref()
-    }
-
-    /// 言語を取得
-    pub fn language(&self) -> Option<&str> {
-        self.language.as_deref()
-    }
-
-    /// アクティブディレクトリを取得
-    pub fn active_dir(&self) -> &PathBuf {
-        &self.active_contest_dir
-    }
-
-    /// 問題IDを設定
-    pub fn set_problem(&mut self, problem_id: &str) {
-        self.problem_id = Some(problem_id.to_string());
-    }
-
-    /// 言語を設定
-    pub fn set_language(&mut self, language: &str) {
-        self.language = Some(language.to_string());
-    }
-
-    /// コンテストIDを設定
-    pub fn set_contest(&mut self, contest_id: &str) {
-        self.contest = contest_id.to_string();
-    }
-
-    /// サイトIDを設定
-    pub fn set_site(&mut self, site: &str) {
-        self.site = site.to_string();
-    }
-
-    /// アクティブディレクトリを設定
-    pub fn set_active_dir(&mut self, dir: PathBuf) {
-        self.active_contest_dir = dir;
-    }
-
-    /// 状態を更新
-    pub fn update<F>(&mut self, f: F) -> Result<(), ContestError>
-    where
-        F: FnOnce(&mut Self) -> Result<(), ContestError>,
-    {
-        f(self)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_contest_state_new() {
-        let state = ContestState::new();
-        assert!(state.problem_id.is_none());
-        assert!(state.language.is_none());
-        assert_eq!(state.contest, "");
-        assert_eq!(state.site, "");
-        assert_eq!(state.active_contest_dir, PathBuf::new());
-    }
-
-    #[test]
-    fn test_contest_state_with_methods() {
-        let state = ContestState::new()
-            .with_problem("abc001_a")
-            .with_language("rust")
-            .with_contest("abc001")
-            .with_site("atcoder")
-            .with_active_dir(PathBuf::from("/tmp/contest"));
-
-        assert_eq!(state.problem_id(), Some("abc001_a"));
-        assert_eq!(state.language(), Some("rust"));
-        assert_eq!(state.contest, "abc001");
-        assert_eq!(state.site, "atcoder");
-        assert_eq!(state.active_dir(), &PathBuf::from("/tmp/contest"));
-    }
-
-    #[test]
-    fn test_contest_state_set_methods() {
-        let mut state = ContestState::new();
-        
-        state.set_problem("abc001_a");
-        state.set_language("rust");
-        state.set_contest("abc001");
-        state.set_site("atcoder");
-        state.set_active_dir(PathBuf::from("/tmp/contest"));
-
-        assert_eq!(state.problem_id(), Some("abc001_a"));
-        assert_eq!(state.language(), Some("rust"));
-        assert_eq!(state.contest, "abc001");
-        assert_eq!(state.site, "atcoder");
-        assert_eq!(state.active_dir(), &PathBuf::from("/tmp/contest"));
-    }
-
-    #[test]
-    fn test_contest_state_update() {
-        let mut state = ContestState::new();
-        
-        state.update(|s| {
-            s.set_problem("abc001_a");
-            s.set_language("rust");
-            Ok(())
-        }).unwrap();
-
-        assert_eq!(state.problem_id(), Some("abc001_a"));
-        assert_eq!(state.language(), Some("rust"));
+    pub fn new(
+        site: String,
+        contest_id: String,
+        problem_id: String,
+        language: String,
+        source_path: PathBuf,
+    ) -> Result<Self> {
+        if site.is_empty() {
+            return Err(config_err("サイトが指定されていません".to_string()));
+        }
+        if contest_id.is_empty() {
+            return Err(config_err("コンテストIDが指定されていません".to_string()));
+        }
+        if problem_id.is_empty() {
+            return Err(config_err("問題IDが指定されていません".to_string()));
+        }
+        if language.is_empty() {
+            return Err(config_err("言語が指定されていません".to_string()));
+        }
+
+        Ok(Self {
+            site,
+            contest_id,
+            problem_id,
+            language,
+            source_path,
+        })
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/contest.rs b/src/contest/service/contest.rs
index 6f7381d..6707691 100644
--- a/src/contest/service/contest.rs
+++ b/src/contest/service/contest.rs
@@ -1,41 +1,70 @@
-use std::sync::Arc;
-use tokio::sync::Mutex;
-use crate::config::Config;
-use crate::contest::error::{ContestError, ContestResult};
-use crate::docker::traits::DockerOperations;
+use std::path::PathBuf;
+use crate::error::Result;
+use crate::contest::error::{config_err, site_err, language_err};
+use crate::contest::model::ContestState;
 
 pub struct ContestService {
-    config: Config,
-    docker_operations: Arc<Mutex<Box<dyn DockerOperations>>>,
+    state: ContestState,
 }
 
 impl ContestService {
-    pub fn new(config: Config, docker_operations: Arc<Mutex<Box<dyn DockerOperations>>>) -> Self {
-        Self {
-            config,
-            docker_operations,
-        }
+    pub fn new(
+        site: String,
+        contest_id: String,
+        problem_id: String,
+        language: String,
+        source_path: PathBuf,
+    ) -> Result<Self> {
+        let state = ContestState::new(site, contest_id, problem_id, language, source_path)?;
+        Ok(Self { state })
     }
 
-    pub async fn run_contest(&self, source_code: &str) -> ContestResult<String> {
-        self.compile_source(source_code).await?;
-        self.run_tests().await
+    pub fn get_state(&self) -> &ContestState {
+        &self.state
     }
 
-    async fn compile_source(&self, _source_code: &str) -> ContestResult<()> {
-        // TODO: コンパイル処理の実装
+    pub fn update_site(&mut self, site: String) -> Result<()> {
+        if site.is_empty() {
+            return Err(site_err("サイトが指定されていません".to_string()));
+        }
+        let state = ContestState::new(
+            site,
+            self.state.contest_id.clone(),
+            self.state.problem_id.clone(),
+            self.state.language.clone(),
+            self.state.source_path.clone(),
+        )?;
+        self.state = state;
         Ok(())
     }
 
-    async fn run_tests(&self) -> ContestResult<String> {
-        let mut ops = self.docker_operations.lock().await;
-        let (stdout, stderr) = ops.execute("cargo test").await
-            .map_err(|e| ContestError::Docker(e.to_string()))?;
+    pub fn update_language(&mut self, language: String) -> Result<()> {
+        if language.is_empty() {
+            return Err(language_err("言語が指定されていません".to_string()));
+        }
+        let state = ContestState::new(
+            self.state.site.clone(),
+            self.state.contest_id.clone(),
+            self.state.problem_id.clone(),
+            language,
+            self.state.source_path.clone(),
+        )?;
+        self.state = state;
+        Ok(())
+    }
 
-        if stderr.is_empty() {
-            Ok(stdout)
-        } else {
-            Err(ContestError::Docker(stderr))
+    pub fn update_problem(&mut self, problem_id: String) -> Result<()> {
+        if problem_id.is_empty() {
+            return Err(config_err("問題IDが指定されていません".to_string()));
         }
+        let state = ContestState::new(
+            self.state.site.clone(),
+            self.state.contest_id.clone(),
+            problem_id,
+            self.state.language.clone(),
+            self.state.source_path.clone(),
+        )?;
+        self.state = state;
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/mod.rs b/src/contest/service/mod.rs
index af715d0..171b850 100644
--- a/src/contest/service/mod.rs
+++ b/src/contest/service/mod.rs
@@ -1,9 +1,9 @@
 pub mod contest;
 pub mod test;
 pub mod url;
-pub mod path;
+mod path;
 
 pub use contest::ContestService;
 pub use test::TestService;
 pub use url::UrlService;
-pub use path::PathService; 
\ No newline at end of file
+pub use path::ContestPath; 
\ No newline at end of file
diff --git a/src/contest/service/path.rs b/src/contest/service/path.rs
index 280b00d..6af3636 100644
--- a/src/contest/service/path.rs
+++ b/src/contest/service/path.rs
@@ -1,58 +1,48 @@
-use std::path::PathBuf;
-use crate::config::Config;
-use crate::contest::error::{ContestError, ContestResult};
+use std::path::{Path, PathBuf};
+use crate::error::Result;
+use crate::contest::error::config_err;
 
-pub struct PathService {
-    config: Config,
+pub struct ContestPath {
+    base_dir: PathBuf,
 }
 
-impl PathService {
-    pub fn new(config: Config) -> Self {
-        Self { config }
+impl ContestPath {
+    pub fn new<P: AsRef<Path>>(base_dir: P) -> Result<Self> {
+        let base_dir = base_dir.as_ref().to_path_buf();
+        if !base_dir.exists() {
+            return Err(config_err(format!("コンテストディレクトリが存在しません: {:?}", base_dir)));
+        }
+        Ok(Self { base_dir })
     }
 
-    pub fn get_test_dir(&self, problem_id: &str) -> ContestResult<PathBuf> {
-        let default_lang = self.config
-            .get::<String>("languages.default")
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+    pub fn get_source_path(&self, problem_id: &str) -> Result<PathBuf> {
+        let source_dir = self.base_dir.join("src");
+        if !source_dir.exists() {
+            return Err(config_err(format!("ソースディレクトリが存在しません: {:?}", source_dir)));
+        }
 
-        let active_dir = self.config
-            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+        let source_path = source_dir.join(format!("{}.rs", problem_id));
+        if !source_path.exists() {
+            return Err(config_err(format!("ソースファイルが存在しません: {:?}", source_path)));
+        }
 
-        let test_dir = PathBuf::from(active_dir)
-            .join("test")
-            .join(problem_id);
+        Ok(source_path)
+    }
 
+    pub fn get_test_dir(&self, problem_id: &str) -> Result<PathBuf> {
+        let test_dir = self.base_dir.join("test").join(problem_id);
         if !test_dir.exists() {
-            std::fs::create_dir_all(&test_dir)
-                .map_err(|e| ContestError::IO(e))?;
+            return Err(config_err(format!("テストディレクトリが存在しません: {:?}", test_dir)));
         }
-
         Ok(test_dir)
     }
 
-    pub fn get_source_file(&self, problem_id: &str) -> ContestResult<PathBuf> {
-        let default_lang = self.config
-            .get::<String>("languages.default")
-            .map_err(|e| ContestError::Config(e.to_string()))?;
-
-        let active_dir = self.config
-            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
-
-        let source_dir = PathBuf::from(active_dir)
-            .join("src");
-
-        if !source_dir.exists() {
-            std::fs::create_dir_all(&source_dir)
-                .map_err(|e| ContestError::IO(e))?;
+    pub fn get_build_dir(&self) -> Result<PathBuf> {
+        let build_dir = self.base_dir.join("target");
+        if !build_dir.exists() {
+            std::fs::create_dir_all(&build_dir)
+                .map_err(|e| config_err(format!("ビルドディレクトリの作成に失敗しました: {}", e)))?;
         }
-
-        let extension = self.config
-            .get::<String>(&format!("languages.{}.extension", default_lang))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
-
-        Ok(source_dir.join(format!("{}.{}", problem_id, extension)))
+        Ok(build_dir)
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/test.rs b/src/contest/service/test.rs
index 80be328..c30c69d 100644
--- a/src/contest/service/test.rs
+++ b/src/contest/service/test.rs
@@ -1,60 +1,69 @@
 use std::path::PathBuf;
-use crate::config::Config;
-use crate::contest::error::{ContestResult, ContestError};
-use crate::test::TestCase;
+use crate::error::Result;
+use crate::contest::error::config_err;
 
 pub struct TestService {
-    config: Config,
+    test_dir: PathBuf,
 }
 
 impl TestService {
-    pub fn new(config: Config) -> Self {
-        Self { config }
+    pub fn new(test_dir: PathBuf) -> Self {
+        Self { test_dir }
     }
 
-    pub async fn run_tests(&self, problem_id: &str) -> ContestResult<()> {
-        let test_dir = self.get_test_dir(problem_id)?;
-        if !test_dir.exists() {
-            return Err(ContestError::Config(
-                format!("テストディレクトリが存在しません: {:?}", test_dir)
-            ));
+    pub fn add_test_case(&self, input: &str, expected: &str) -> Result<()> {
+        if input.is_empty() {
+            return Err(config_err("入力が空です".to_string()));
+        }
+        if expected.is_empty() {
+            return Err(config_err("期待値が空です".to_string()));
         }
 
-        let entries = std::fs::read_dir(&test_dir)
-            .map_err(|e| ContestError::IO(e))?;
+        let test_count = self.get_test_count()?;
+        let input_file = self.test_dir.join(format!("test{}.in", test_count + 1));
+        let expected_file = self.test_dir.join(format!("test{}.out", test_count + 1));
 
-        for entry in entries {
-            let entry = entry.map_err(|e| ContestError::IO(e))?;
-            let path = entry.path();
-            if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-                let _test_case = self.load_test_case(&path)?;
-                // TODO: テストケースの実行処理を実装
-            }
-        }
+        std::fs::write(&input_file, input)
+            .map_err(|e| config_err(format!("テストケースの入力ファイルの作成に失敗しました: {}", e)))?;
+        std::fs::write(&expected_file, expected)
+            .map_err(|e| config_err(format!("テストケースの期待値ファイルの作成に失敗しました: {}", e)))?;
 
         Ok(())
     }
 
-    fn get_test_dir(&self, problem_id: &str) -> ContestResult<PathBuf> {
-        let default_lang = self.config
-            .get::<String>("languages.default")
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+    pub fn get_test_count(&self) -> Result<usize> {
+        let entries = std::fs::read_dir(&self.test_dir)
+            .map_err(|e| config_err(format!("テストディレクトリの読み取りに失敗しました: {}", e)))?;
 
-        let active_dir = self.config
-            .get::<String>(&format!("languages.{}.contest_dir.active", default_lang))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+        let count = entries
+            .filter_map(|entry| entry.ok())
+            .filter(|entry| {
+                entry.path()
+                    .extension()
+                    .map(|ext| ext == "in")
+                    .unwrap_or(false)
+            })
+            .count();
 
-        Ok(PathBuf::from(active_dir).join("test").join(problem_id))
+        Ok(count)
     }
 
-    fn load_test_case(&self, test_file: &PathBuf) -> ContestResult<TestCase> {
-        let input = std::fs::read_to_string(test_file)
-            .map_err(|e| ContestError::IO(e))?;
+    pub fn get_test_cases(&self) -> Result<Vec<(String, String)>> {
+        let mut test_cases = Vec::new();
+        let test_count = self.get_test_count()?;
+
+        for i in 1..=test_count {
+            let input_file = self.test_dir.join(format!("test{}.in", i));
+            let expected_file = self.test_dir.join(format!("test{}.out", i));
 
-        let expected_path = test_file.with_extension("out");
-        let expected = std::fs::read_to_string(&expected_path)
-            .map_err(|e| ContestError::IO(e))?;
+            let input = std::fs::read_to_string(&input_file)
+                .map_err(|e| config_err(format!("テストケースの入力ファイルの読み取りに失敗しました: {}", e)))?;
+            let expected = std::fs::read_to_string(&expected_file)
+                .map_err(|e| config_err(format!("テストケースの期待値ファイルの読み取りに失敗しました: {}", e)))?;
+
+            test_cases.push((input, expected));
+        }
 
-        Ok(TestCase { input, expected })
+        Ok(test_cases)
     }
 } 
\ No newline at end of file
diff --git a/src/contest/service/url.rs b/src/contest/service/url.rs
index e22e383..13bd9c5 100644
--- a/src/contest/service/url.rs
+++ b/src/contest/service/url.rs
@@ -1,37 +1,46 @@
-use crate::contest::error::{ContestError, ContestResult};
-use crate::config::Config;
+use crate::error::Result;
+use crate::contest::error::site_err;
 
 pub struct UrlService {
-    config: Config,
     site: String,
 }
 
 impl UrlService {
-    pub fn new(config: Config, site: String) -> Self {
-        Self { config, site }
+    pub fn new(site: String) -> Result<Self> {
+        if site.is_empty() {
+            return Err(site_err("サイトが指定されていません".to_string()));
+        }
+        Ok(Self { site })
     }
 
-    pub fn get_contest_url(&self, contest_id: &str) -> ContestResult<String> {
-        self.get_url(contest_id, "contest")
-    }
-
-    pub fn get_problem_url(&self, contest_id: &str, problem_id: &str) -> ContestResult<String> {
-        let _contest_url = self.get_contest_url(contest_id)?;
-        let problem_pattern = self.config.get::<String>(&format!("sites.{}.problem_url", self.site))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+    pub fn get_contest_url(&self, contest_id: &str) -> Result<String> {
+        if contest_id.is_empty() {
+            return Err(site_err("コンテストIDが指定されていません".to_string()));
+        }
 
-        let url = problem_pattern
-            .replace("{contest_id}", contest_id)
-            .replace("{problem_id}", problem_id);
+        let url = match self.site.as_str() {
+            "atcoder" => format!("https://atcoder.jp/contests/{}", contest_id),
+            "codeforces" => format!("https://codeforces.com/contest/{}", contest_id),
+            _ => return Err(site_err(format!("未対応のサイトです: {}", self.site))),
+        };
 
         Ok(url)
     }
 
-    fn get_url(&self, contest_id: &str, url_type: &str) -> ContestResult<String> {
-        let pattern = self.config.get::<String>(&format!("sites.{}.{}_url", self.site, url_type))
-            .map_err(|e| ContestError::Config(e.to_string()))?;
+    pub fn get_problem_url(&self, contest_id: &str, problem_id: &str) -> Result<String> {
+        if contest_id.is_empty() {
+            return Err(site_err("コンテストIDが指定されていません".to_string()));
+        }
+        if problem_id.is_empty() {
+            return Err(site_err("問題IDが指定されていません".to_string()));
+        }
+
+        let url = match self.site.as_str() {
+            "atcoder" => format!("https://atcoder.jp/contests/{}/tasks/{}", contest_id, problem_id),
+            "codeforces" => format!("https://codeforces.com/contest/{}/problem/{}", contest_id, problem_id),
+            _ => return Err(site_err(format!("未対応のサイトです: {}", self.site))),
+        };
 
-        let url = pattern.replace("{contest_id}", contest_id);
         Ok(url)
     }
 } 
\ No newline at end of file
diff --git a/src/docker/error.rs b/src/docker/error.rs
index bf2bde5..497a0b9 100644
--- a/src/docker/error.rs
+++ b/src/docker/error.rs
@@ -1,60 +1,21 @@
-use std::error::Error;
-use std::fmt;
-use std::io;
-use nix::errno::Errno;
-use crate::docker::state::StateError;
+use crate::error::CphError;
 
-#[derive(Debug)]
-pub enum DockerError {
-    Container(String),
-    Compilation(String),
-    Command(String),
-    State(StateError),
-    IO(io::Error),
-    Filesystem(String),
-    System(String),
+pub fn docker_err(msg: String) -> CphError {
+    CphError::Docker(msg)
 }
 
-impl fmt::Display for DockerError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            DockerError::Container(msg) => write!(f, "コンテナエラー: {}", msg),
-            DockerError::Compilation(msg) => write!(f, "コンパイルエラー: {}", msg),
-            DockerError::Command(msg) => write!(f, "コマンドエラー: {}", msg),
-            DockerError::State(err) => write!(f, "状態エラー: {}", err),
-            DockerError::IO(err) => write!(f, "I/Oエラー: {}", err),
-            DockerError::Filesystem(msg) => write!(f, "ファイルシステムエラー: {}", msg),
-            DockerError::System(msg) => write!(f, "システムエラー: {}", msg),
-        }
-    }
+pub fn container_err(msg: String) -> CphError {
+    CphError::Docker(format!("コンテナエラー: {}", msg))
 }
 
-impl Error for DockerError {
-    fn source(&self) -> Option<&(dyn Error + 'static)> {
-        match self {
-            DockerError::State(err) => Some(err),
-            DockerError::IO(err) => Some(err),
-            _ => None,
-        }
-    }
+pub fn compilation_err(msg: String) -> CphError {
+    CphError::Docker(format!("コンパイルエラー: {}", msg))
 }
 
-impl From<io::Error> for DockerError {
-    fn from(err: io::Error) -> Self {
-        DockerError::IO(err)
-    }
+pub fn command_err(msg: String) -> CphError {
+    CphError::Docker(format!("コマンドエラー: {}", msg))
 }
 
-impl From<StateError> for DockerError {
-    fn from(err: StateError) -> Self {
-        DockerError::State(err)
-    }
-}
-
-impl From<Errno> for DockerError {
-    fn from(err: Errno) -> Self {
-        DockerError::System(err.to_string())
-    }
-}
-
-pub type DockerResult<T> = Result<T, DockerError>; 
\ No newline at end of file
+pub fn state_err(msg: String) -> CphError {
+    CphError::Docker(format!("状態エラー: {}", msg))
+} 
\ No newline at end of file
diff --git a/src/docker/execution/command.rs b/src/docker/execution/command.rs
index d442de8..0ce8ecf 100644
--- a/src/docker/execution/command.rs
+++ b/src/docker/execution/command.rs
@@ -1,48 +1,51 @@
-use async_trait::async_trait;
+use std::process::Output;
 use tokio::process::Command;
-use crate::docker::error::{DockerError, DockerResult};
-use super::{DockerCommand, DockerCommandExecutor, CommandOutput};
+use crate::error::Result;
+use crate::docker::error::command_err;
 
-pub struct DefaultDockerCommandExecutor;
-
-impl DefaultDockerCommandExecutor {
-    pub fn new() -> Self {
-        Self
-    }
+#[derive(Debug)]
+pub struct DockerCommand {
+    command: String,
+    args: Vec<String>,
 }
 
-#[async_trait]
-impl DockerCommandExecutor for DefaultDockerCommandExecutor {
-    async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput> {
-        let mut cmd = Command::new("docker");
-        cmd.args(command.get_args());
+impl DockerCommand {
+    pub fn new<S: Into<String>>(command: S) -> Self {
+        Self {
+            command: command.into(),
+            args: Vec::new(),
+        }
+    }
 
-        let output = cmd.output().await.map_err(|e| {
-            DockerError::Command(format!("Dockerコマンドの実行に失敗しました: {}", e))
-        })?;
+    pub fn arg<S: Into<String>>(mut self, arg: S) -> Self {
+        self.args.push(arg.into());
+        self
+    }
 
-        Ok(CommandOutput::new(
-            output.status.success(),
-            String::from_utf8_lossy(&output.stdout).to_string(),
-            String::from_utf8_lossy(&output.stderr).to_string(),
-        ))
+    pub fn args<I, S>(mut self, args: I) -> Self
+    where
+        I: IntoIterator<Item = S>,
+        S: Into<String>,
+    {
+        self.args.extend(args.into_iter().map(Into::into));
+        self
     }
-}
 
-#[cfg(test)]
-mod tests {
-    use super::*;
+    pub async fn execute(&self) -> Result<Output> {
+        let output = Command::new(&self.command)
+            .args(&self.args)
+            .output()
+            .await
+            .map_err(|e| command_err(format!("コマンドの実行に失敗しました: {}", e)))?;
+
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(command_err(format!(
+                "コマンドが失敗しました: {}",
+                stderr
+            )));
+        }
 
-    #[tokio::test]
-    async fn test_docker_command_executor() {
-        let executor = DefaultDockerCommandExecutor::new();
-        let command = DockerCommand::new("version");
-        
-        let result = executor.execute(command).await;
-        assert!(result.is_ok());
-        
-        let output = result.unwrap();
-        assert!(output.success);
-        assert!(!output.stdout.is_empty());
+        Ok(output)
     }
 } 
\ No newline at end of file
diff --git a/src/docker/execution/compilation.rs b/src/docker/execution/compilation.rs
index 52060b9..1a6b41a 100644
--- a/src/docker/execution/compilation.rs
+++ b/src/docker/execution/compilation.rs
@@ -1,99 +1,68 @@
-use async_trait::async_trait;
-use std::sync::Arc;
-use crate::docker::error::{DockerError, DockerResult};
-use crate::docker::traits::CompilationOperations;
-use super::{DockerCommand, DockerCommandExecutor};
+use std::path::Path;
+use tokio::process::Command;
+use crate::error::Result;
+use crate::docker::error::compilation_err;
 
-pub struct DefaultCompilationManager {
-    docker_executor: Arc<dyn DockerCommandExecutor>,
-    container_id: String,
+pub struct CompilationManager {
+    container_id: Option<String>,
 }
 
-impl DefaultCompilationManager {
-    pub fn new(executor: Arc<dyn DockerCommandExecutor>, container_id: String) -> Self {
+impl CompilationManager {
+    pub fn new() -> Self {
         Self {
-            docker_executor: executor,
-            container_id,
+            container_id: None,
         }
     }
 
-    async fn execute_in_container(&self, cmd: Vec<String>) -> DockerResult<(String, String)> {
-        let command = DockerCommand::new("exec")
-            .arg(&self.container_id)
-            .args(cmd);
+    pub async fn compile<P: AsRef<Path>>(&mut self, source_code: &str, compile_cmd: Option<Vec<String>>, env_vars: Vec<String>, working_dir: P) -> Result<()> {
+        if self.container_id.is_some() {
+            return Err(compilation_err("コンパイルは既に実行されています".to_string()));
+        }
 
-        let output = self.docker_executor.execute(command).await?;
-        Ok((output.stdout, output.stderr))
-    }
-}
+        let mut command = Command::new("docker");
+        command
+            .arg("run")
+            .arg("--rm")
+            .args(env_vars.iter().flat_map(|var| vec!["-e", var]))
+            .arg("-w")
+            .arg(working_dir.as_ref().to_string_lossy().to_string());
 
-#[async_trait]
-impl CompilationOperations for DefaultCompilationManager {
-    async fn compile(
-        &mut self,
-        _source_code: &str,
-        compile_cmd: Option<Vec<String>>,
-        env_vars: Vec<String>,
-    ) -> DockerResult<()> {
         if let Some(cmd) = compile_cmd {
-            let mut command = DockerCommand::new("exec")
-                .arg(&self.container_id);
-
-            for env_var in env_vars {
-                let parts: Vec<&str> = env_var.split('=').collect();
-                if parts.len() == 2 {
-                    command = command.env(parts[0], parts[1]);
-                }
-            }
+            command.args(cmd);
+        }
 
-            command = command.args(cmd);
+        let output = command
+            .output()
+            .await
+            .map_err(|e| compilation_err(format!("コンパイルの実行に失敗しました: {}", e)))?;
 
-            let output = self.docker_executor.execute(command).await?;
-            if !output.success {
-                return Err(DockerError::Compilation(format!(
-                    "コンパイルに失敗しました: {}",
-                    output.stderr
-                )));
-            }
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(compilation_err(format!("コンパイルに失敗しました: {}", stderr)));
         }
-        Ok(())
-    }
 
-    async fn get_compilation_output(&self) -> DockerResult<(String, String)> {
-        self.execute_in_container(vec!["cat".to_string(), "compilation.log".to_string()]).await
-    }
-}
+        let container_id = String::from_utf8_lossy(&output.stdout)
+            .trim()
+            .to_string();
+        self.container_id = Some(container_id);
 
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::sync::Arc;
-    use mockall::predicate::*;
-    use crate::docker::test_helpers::MockDockerCommandExecutor;
+        Ok(())
+    }
 
-    #[tokio::test]
-    async fn test_compilation() {
-        let mut mock_executor = MockDockerCommandExecutor::new();
-        mock_executor.expect_execute()
-            .returning(|_| {
-                Ok(super::super::CommandOutput::new(
-                    true,
-                    String::new(),
-                    String::new(),
-                ))
-            });
+    pub async fn get_compilation_output(&self) -> Result<(String, String)> {
+        let container_id = self.container_id.as_ref()
+            .ok_or_else(|| compilation_err("コンパイルが実行されていません".to_string()))?;
 
-        let executor = Arc::new(mock_executor);
-        let mut manager = DefaultCompilationManager::new(
-            executor,
-            "test_container".to_string(),
-        );
+        let output = Command::new("docker")
+            .arg("logs")
+            .arg(container_id)
+            .output()
+            .await
+            .map_err(|e| compilation_err(format!("コンパイル出力の取得に失敗しました: {}", e)))?;
 
-        let result = manager.compile(
-            "test code",
-            Some(vec!["gcc".to_string(), "test.c".to_string()]),
-            vec![],
-        ).await;
-        assert!(result.is_ok());
+        Ok((
+            String::from_utf8_lossy(&output.stdout).to_string(),
+            String::from_utf8_lossy(&output.stderr).to_string(),
+        ))
     }
 } 
\ No newline at end of file
diff --git a/src/docker/execution/container.rs b/src/docker/execution/container.rs
index 16c0b00..948eb40 100644
--- a/src/docker/execution/container.rs
+++ b/src/docker/execution/container.rs
@@ -1,176 +1,141 @@
-use async_trait::async_trait;
-use std::sync::Arc;
-use crate::docker::error::{DockerError, DockerResult};
-use crate::docker::traits::ContainerManager;
-use super::{DockerCommand, DockerCommandExecutor};
-
-pub struct DefaultContainerManager {
-    container_id: String,
-    memory_limit: u64,
-    mount_point: String,
-    docker_executor: Arc<dyn DockerCommandExecutor>,
+use std::path::Path;
+use tokio::process::Command;
+use crate::error::Result;
+use crate::docker::error::container_err;
+
+pub struct ContainerManager {
+    container_id: Option<String>,
 }
 
-impl DefaultContainerManager {
-    pub fn new(memory_limit: u64, mount_point: String, executor: Arc<dyn DockerCommandExecutor>) -> Self {
+impl ContainerManager {
+    pub fn new() -> Self {
         Self {
-            container_id: String::new(),
-            memory_limit,
-            mount_point,
-            docker_executor: executor,
-        }
-    }
-
-    async fn ensure_container_exists(&self) -> DockerResult<()> {
-        if self.container_id.is_empty() {
-            return Err(DockerError::Container("コンテナが作成されていません".to_string()));
+            container_id: None,
         }
-        Ok(())
     }
-}
 
-#[async_trait]
-impl ContainerManager for DefaultContainerManager {
-    async fn create_container(&mut self, image: &str, cmd: Vec<String>, working_dir: &str) -> DockerResult<()> {
-        if !self.check_image(image).await? {
-            self.pull_image(image).await?;
+    pub async fn create_container<P: AsRef<Path>>(&mut self, image: &str, cmd: Vec<String>, working_dir: P) -> Result<()> {
+        if self.container_id.is_some() {
+            return Err(container_err("コンテナは既に作成されています".to_string()));
         }
 
-        let mut command = DockerCommand::new("create")
-            .arg("--memory")
-            .arg(&format!("{}m", self.memory_limit))
-            .arg("-v")
-            .arg(&format!("{}:/workspace", self.mount_point))
+        let output = Command::new("docker")
+            .arg("create")
+            .arg("--rm")
             .arg("-w")
-            .arg(working_dir)
-            .arg(image);
-
-        if !cmd.is_empty() {
-            command = command.args(cmd);
+            .arg(working_dir.as_ref().to_string_lossy().to_string())
+            .arg(image)
+            .args(cmd)
+            .output()
+            .await
+            .map_err(|e| container_err(format!("コンテナの作成に失敗しました: {}", e)))?;
+
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(container_err(format!("コンテナの作成に失敗しました: {}", stderr)));
         }
 
-        let output = self.docker_executor.execute(command).await?;
-        if output.success {
-            self.container_id = output.stdout.trim().to_string();
-            Ok(())
-        } else {
-            Err(DockerError::Container(format!(
-                "コンテナの作成に失敗しました: {}",
-                output.stderr
-            )))
-        }
+        let container_id = String::from_utf8_lossy(&output.stdout)
+            .trim()
+            .to_string();
+        self.container_id = Some(container_id);
+
+        Ok(())
     }
 
-    async fn start_container(&mut self) -> DockerResult<()> {
-        self.ensure_container_exists().await?;
+    pub async fn start_container(&self) -> Result<()> {
+        let container_id = self.container_id.as_ref()
+            .ok_or_else(|| container_err("コンテナが作成されていません".to_string()))?;
 
-        let command = DockerCommand::new("start")
-            .arg(&self.container_id);
+        let output = Command::new("docker")
+            .arg("start")
+            .arg(container_id)
+            .output()
+            .await
+            .map_err(|e| container_err(format!("コンテナの起動に失敗しました: {}", e)))?;
 
-        let output = self.docker_executor.execute(command).await?;
-        if output.success {
-            Ok(())
-        } else {
-            Err(DockerError::Container(format!(
-                "コンテナの起動に失敗しました: {}",
-                output.stderr
-            )))
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(container_err(format!("コンテナの起動に失敗しました: {}", stderr)));
         }
+
+        Ok(())
     }
 
-    async fn stop_container(&mut self) -> DockerResult<()> {
-        self.ensure_container_exists().await?;
+    pub async fn stop_container(&self) -> Result<()> {
+        let container_id = self.container_id.as_ref()
+            .ok_or_else(|| container_err("コンテナが作成されていません".to_string()))?;
 
-        let command = DockerCommand::new("stop")
-            .arg(&self.container_id);
+        let output = Command::new("docker")
+            .arg("stop")
+            .arg(container_id)
+            .output()
+            .await
+            .map_err(|e| container_err(format!("コンテナの停止に失敗しました: {}", e)))?;
 
-        let output = self.docker_executor.execute(command).await?;
-        if output.success {
-            Ok(())
-        } else {
-            Err(DockerError::Container(format!(
-                "コンテナの停止に失敗しました: {}",
-                output.stderr
-            )))
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(container_err(format!("コンテナの停止に失敗しました: {}", stderr)));
         }
+
+        Ok(())
     }
 
-    async fn get_container_id(&self) -> DockerResult<String> {
-        self.ensure_container_exists().await?;
-        Ok(self.container_id.clone())
+    pub async fn get_container_id(&self) -> Result<String> {
+        self.container_id.clone()
+            .ok_or_else(|| container_err("コンテナが作成されていません".to_string()))
     }
 
-    async fn get_exit_code(&self) -> DockerResult<i32> {
-        self.ensure_container_exists().await?;
+    pub async fn get_exit_code(&self) -> Result<i32> {
+        let container_id = self.container_id.as_ref()
+            .ok_or_else(|| container_err("コンテナが作成されていません".to_string()))?;
 
-        let command = DockerCommand::new("inspect")
+        let output = Command::new("docker")
+            .arg("inspect")
+            .arg(container_id)
             .arg("--format={{.State.ExitCode}}")
-            .arg(&self.container_id);
-
-        let output = self.docker_executor.execute(command).await?;
-        if output.success {
-            output.stdout.trim().parse::<i32>()
-                .map_err(|e| DockerError::Container(format!("終了コードの解析に失敗しました: {}", e)))
-        } else {
-            Err(DockerError::Container(format!(
-                "終了コードの取得に失敗しました: {}",
-                output.stderr
-            )))
+            .output()
+            .await
+            .map_err(|e| container_err(format!("終了コードの取得に失敗しました: {}", e)))?;
+
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(container_err(format!("終了コードの取得に失敗しました: {}", stderr)));
         }
+
+        let exit_code = String::from_utf8_lossy(&output.stdout)
+            .trim()
+            .parse::<i32>()
+            .map_err(|e| container_err(format!("終了コードの解析に失敗しました: {}", e)))?;
+
+        Ok(exit_code)
     }
 
-    async fn check_image(&self, image: &str) -> DockerResult<bool> {
-        let command = DockerCommand::new("image")
+    pub async fn check_image(&self, image: &str) -> Result<bool> {
+        let output = Command::new("docker")
+            .arg("image")
             .arg("inspect")
-            .arg(image);
+            .arg(image)
+            .output()
+            .await
+            .map_err(|e| container_err(format!("イメージの確認に失敗しました: {}", e)))?;
 
-        let output = self.docker_executor.execute(command).await?;
-        Ok(output.success)
+        Ok(output.status.success())
     }
 
-    async fn pull_image(&self, image: &str) -> DockerResult<()> {
-        let command = DockerCommand::new("pull")
-            .arg(image);
-
-        let output = self.docker_executor.execute(command).await?;
-        if output.success {
-            Ok(())
-        } else {
-            Err(DockerError::Container(format!(
-                "イメージの取得に失敗しました: {}",
-                output.stderr
-            )))
+    pub async fn pull_image(&self, image: &str) -> Result<()> {
+        let output = Command::new("docker")
+            .arg("pull")
+            .arg(image)
+            .output()
+            .await
+            .map_err(|e| container_err(format!("イメージの取得に失敗しました: {}", e)))?;
+
+        if !output.status.success() {
+            let stderr = String::from_utf8_lossy(&output.stderr);
+            return Err(container_err(format!("イメージの取得に失敗しました: {}", stderr)));
         }
-    }
-}
 
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::sync::Arc;
-    use mockall::predicate::*;
-    use crate::docker::test_helpers::MockDockerCommandExecutor;
-
-    #[tokio::test]
-    async fn test_container_creation() {
-        let mut mock_executor = MockDockerCommandExecutor::new();
-        mock_executor.expect_execute()
-            .returning(|_| {
-                Ok(super::super::CommandOutput::new(
-                    true,
-                    "container_id".to_string(),
-                    String::new(),
-                ))
-            });
-
-        let executor = Arc::new(mock_executor);
-        let mut manager = DefaultContainerManager::new(
-            512,
-            "/tmp".to_string(),
-            executor,
-        );
-
-        let result = manager.create_container("test-image", vec![], "/workspace").await;
-        assert!(result.is_ok());
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/execution/mod.rs b/src/docker/execution/mod.rs
index bd90784..5a4fd93 100644
--- a/src/docker/execution/mod.rs
+++ b/src/docker/execution/mod.rs
@@ -1,14 +1,14 @@
-pub mod command;
-pub mod container;
-pub mod compilation;
+mod command;
+mod container;
+mod compilation;
 
-pub use command::DefaultDockerCommandExecutor;
-pub use container::DefaultContainerManager;
-pub use compilation::DefaultCompilationManager;
+pub use command::DockerCommand;
+pub use container::ContainerManager;
+pub use compilation::CompilationManager;
 
 // 共通のトレイトと型定義
 use async_trait::async_trait;
-use crate::docker::error::DockerResult;
+use crate::error::Result;
 
 #[derive(Debug)]
 pub struct CommandOutput {
@@ -29,38 +29,5 @@ impl CommandOutput {
 
 #[async_trait]
 pub trait DockerCommandExecutor: Send + Sync {
-    async fn execute(&self, command: DockerCommand) -> DockerResult<CommandOutput>;
-}
-
-#[derive(Debug)]
-pub struct DockerCommand {
-    args: Vec<String>,
-}
-
-impl DockerCommand {
-    pub fn new(command: &str) -> Self {
-        Self {
-            args: vec![command.to_string()],
-        }
-    }
-
-    pub fn arg(mut self, arg: &str) -> Self {
-        self.args.push(arg.to_string());
-        self
-    }
-
-    pub fn args(mut self, args: Vec<String>) -> Self {
-        self.args.extend(args);
-        self
-    }
-
-    pub fn env(mut self, key: &str, value: &str) -> Self {
-        self.args.push("-e".to_string());
-        self.args.push(format!("{}={}", key, value));
-        self
-    }
-
-    pub fn get_args(&self) -> Vec<String> {
-        self.args.clone()
-    }
+    async fn execute(&self, command: DockerCommand) -> Result<CommandOutput>;
 } 
\ No newline at end of file
diff --git a/src/docker/fs.rs b/src/docker/fs.rs
index f63a66e..f637a76 100644
--- a/src/docker/fs.rs
+++ b/src/docker/fs.rs
@@ -1,84 +1,37 @@
-use std::path::{Path, PathBuf};
-use crate::docker::error::{DockerError, DockerResult};
-use crate::fs::{FileManager, DockerFileOperations};
+use std::path::Path;
+use crate::error::Result;
+use crate::docker::error::docker_err;
 
-pub struct DefaultDockerFileManager {
-    file_manager: FileManager,
+pub trait DockerFileOperations {
+    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<()>;
+    fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()>;
 }
 
-impl DefaultDockerFileManager {
-    pub fn new() -> DockerResult<Self> {
-        Ok(Self {
-            file_manager: FileManager::new().map_err(|e| DockerError::Filesystem(e.to_string()))?,
-        })
-    }
-}
-
-impl DockerFileManager for DefaultDockerFileManager {
-    fn create_temp_directory(&self) -> DockerResult<PathBuf> {
-        self.file_manager
-            .create_temp_directory()
-            .map_err(|e| DockerError::Filesystem(e.to_string()))
-    }
+pub struct DefaultDockerFileOperations;
 
-    fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf> {
-        self.file_manager
-            .write_source_file(dir, filename, content)
-            .map_err(|e| DockerError::Filesystem(e.to_string()))
-    }
-
-    fn set_permissions(&self, path: &Path, mode: u32) -> DockerResult<()> {
-        self.file_manager
-            .set_permissions(path, mode)
-            .map_err(|e| DockerError::Filesystem(e.to_string()))
+impl DefaultDockerFileOperations {
+    pub fn new() -> Self {
+        Self
     }
+}
 
-    fn cleanup(&self, dir: &Path) -> DockerResult<()> {
-        if dir.exists() {
-            std::fs::remove_dir_all(dir)
-                .map_err(|e| DockerError::Filesystem(e.to_string()))?;
-        }
+impl DockerFileOperations for DefaultDockerFileOperations {
+    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<()> {
+        let path = dir.as_ref().join(filename);
+        std::fs::write(&path, content)
+            .map_err(|e| docker_err(format!("ソースファイルの書き込みに失敗しました: {}", e)))?;
         Ok(())
     }
-}
-
-pub trait DockerFileManager {
-    fn create_temp_directory(&self) -> DockerResult<PathBuf>;
-    fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> DockerResult<PathBuf>;
-    fn set_permissions(&self, path: &Path, mode: u32) -> DockerResult<()>;
-    fn cleanup(&self, dir: &Path) -> DockerResult<()>;
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::fs;
-
-    #[test]
-    fn test_docker_file_manager() -> DockerResult<()> {
-        let manager = DefaultDockerFileManager::new()?;
-        
-        // 一時ディレクトリの作成
-        let temp_dir = manager.create_temp_directory()?;
-        assert!(temp_dir.exists());
-
-        // ソースファイルの書き込み
-        let file_path = manager.write_source_file(&temp_dir, "test.txt", "test content")?;
-        assert!(file_path.exists());
-        let content = fs::read_to_string(&file_path)
-            .map_err(|e| DockerError::Filesystem(e.to_string()))?;
-        assert_eq!(content, "test content");
-
-        // 権限設定
-        manager.set_permissions(&temp_dir, 0o777)?;
-        let metadata = fs::metadata(&temp_dir)
-            .map_err(|e| DockerError::Filesystem(e.to_string()))?;
-        assert_eq!(metadata.permissions().mode() & 0o777, 0o777);
-
-        // クリーンアップ
-        manager.cleanup(&temp_dir)?;
-        assert!(!temp_dir.exists());
 
+    fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()> {
+        use std::os::unix::fs::PermissionsExt;
+        let path = path.as_ref();
+        let metadata = std::fs::metadata(path)
+            .map_err(|e| docker_err(format!("メタデータの取得に失敗しました: {}", e)))?;
+        let mut perms = metadata.permissions();
+        perms.set_mode(mode);
+        std::fs::set_permissions(path, perms)
+            .map_err(|e| docker_err(format!("権限の設定に失敗しました: {}", e)))?;
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/docker/mod.rs b/src/docker/mod.rs
index 9401abd..68c7bde 100644
--- a/src/docker/mod.rs
+++ b/src/docker/mod.rs
@@ -1,19 +1,14 @@
-pub mod config;
 pub mod error;
 pub mod execution;
-pub mod fs;
 pub mod state;
-pub mod test_helpers;
-pub mod traits;
+pub mod fs;
 
 pub use execution::{
-    DefaultDockerCommandExecutor,
-    DefaultContainerManager,
-    DefaultCompilationManager,
-};
-
-pub use traits::{
+    DockerCommand,
     ContainerManager,
-    DockerOperations,
-    CompilationOperations,
-}; 
\ No newline at end of file
+    CompilationManager,
+    DockerCommandExecutor,
+    CommandOutput,
+};
+pub use state::{ContainerState, ContainerStateManager};
+pub use fs::{DockerFileOperations, DefaultDockerFileOperations}; 
\ No newline at end of file
diff --git a/src/docker/state/manager.rs b/src/docker/state/manager.rs
index ad64fef..8e4f440 100644
--- a/src/docker/state/manager.rs
+++ b/src/docker/state/manager.rs
@@ -1,64 +1,58 @@
 use std::sync::Arc;
-use tokio::sync::{Mutex, mpsc};
-use crate::docker::state::types::{ContainerState, StateError};
-use crate::docker::state::validation::validate_transition;
+use tokio::sync::RwLock;
+use crate::error::Result;
+use super::ContainerState;
+use crate::docker::error::state_err;
+use crate::docker::state::operations;
 
+#[derive(Debug, Clone)]
 pub struct ContainerStateManager {
-    state: Arc<Mutex<ContainerState>>,
-    container_id: Arc<Mutex<Option<String>>>,
-    subscribers: Arc<Mutex<Vec<mpsc::Sender<ContainerState>>>>,
+    state: Arc<RwLock<ContainerState>>,
 }
 
 impl ContainerStateManager {
     pub fn new() -> Self {
         Self {
-            state: Arc::new(Mutex::new(ContainerState::Initial)),
-            container_id: Arc::new(Mutex::new(None)),
-            subscribers: Arc::new(Mutex::new(Vec::new())),
+            state: Arc::new(RwLock::new(ContainerState::Initial)),
         }
     }
 
-    pub async fn set_container_id(&self, id: String) {
-        let mut container_id = self.container_id.lock().await;
-        *container_id = Some(id);
+    pub async fn get_current_state(&self) -> ContainerState {
+        self.state.read().await.clone()
     }
 
-    pub async fn get_container_id(&self) -> Option<String> {
-        let container_id = self.container_id.lock().await;
-        container_id.clone()
+    pub async fn create_container(&self, container_id: String) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = operations::create_container(&current_state, container_id).await?;
+        *self.state.write().await = new_state;
+        Ok(())
     }
 
-    pub async fn transition_to(&self, new_state: ContainerState) -> Result<(), StateError> {
-        let mut state = self.state.lock().await;
-        
-        // 状態遷移の検証
-        validate_transition(&state, &new_state).await?;
-        
-        // 状態を更新
-        *state = new_state.clone();
-        
-        // 購読者に通知
-        self.notify_subscribers(new_state).await;
-        
+    pub async fn start_container(&self) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = operations::start_container(&current_state).await?;
+        *self.state.write().await = new_state;
         Ok(())
     }
 
-    async fn notify_subscribers(&self, state: ContainerState) {
-        let mut subscribers = self.subscribers.lock().await;
-        subscribers.retain_mut(|subscriber| {
-            subscriber.try_send(state.clone()).is_ok()
-        });
+    pub async fn stop_container(&self) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = operations::stop_container(&current_state).await?;
+        *self.state.write().await = new_state;
+        Ok(())
     }
 
-    pub async fn subscribe(&self) -> mpsc::Receiver<ContainerState> {
-        let (tx, rx) = mpsc::channel(32);
-        let mut subscribers = self.subscribers.lock().await;
-        subscribers.push(tx);
-        rx
+    pub async fn fail_container(&self, container_id: String, error: String) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = operations::fail_container(&current_state, container_id, error).await?;
+        *self.state.write().await = new_state;
+        Ok(())
     }
 
-    pub async fn get_current_state(&self) -> ContainerState {
-        let state = self.state.lock().await;
-        state.clone()
+    pub async fn get_container_id(&self) -> Result<String> {
+        let state = self.get_current_state().await;
+        state.container_id()
+            .map(String::from)
+            .ok_or_else(|| state_err("コンテナIDが見つかりません".to_string()))
     }
 } 
\ No newline at end of file
diff --git a/src/docker/state/mod.rs b/src/docker/state/mod.rs
index a21c12c..185a496 100644
--- a/src/docker/state/mod.rs
+++ b/src/docker/state/mod.rs
@@ -3,5 +3,5 @@ mod validation;
 mod manager;
 mod operations;
 
-pub use types::{ContainerState, StateError};
+pub use types::ContainerState;
 pub use manager::ContainerStateManager; 
\ No newline at end of file
diff --git a/src/docker/state/operations.rs b/src/docker/state/operations.rs
index e703b2c..f15f957 100644
--- a/src/docker/state/operations.rs
+++ b/src/docker/state/operations.rs
@@ -1,122 +1,76 @@
 use std::time::Instant;
-use crate::docker::state::types::{ContainerState, StateError};
-use crate::docker::state::manager::ContainerStateManager;
+use crate::error::Result;
+use super::ContainerState;
+use crate::docker::error::state_err;
 
-impl ContainerStateManager {
-    pub async fn create_container(&self, container_id: String) -> Result<(), StateError> {
-        let current_state = self.get_current_state().await;
-        match current_state {
-            ContainerState::Initial => {
-                self.transition_to(ContainerState::Created {
-                    container_id,
-                    created_at: Instant::now(),
-                }).await
-            },
-            _ => Err(StateError::InvalidTransition {
-                from: current_state,
-                to: ContainerState::Created {
-                    container_id,
-                    created_at: Instant::now(),
-                },
-            }),
+pub async fn fail_container(current_state: &ContainerState, container_id: String, error: String) -> Result<ContainerState> {
+    match current_state {
+        ContainerState::Initial |
+        ContainerState::Stopped { .. } |
+        ContainerState::Failed { .. } => {
+            Err(state_err(format!(
+                "無効な状態からの失敗遷移: {}",
+                current_state
+            )))
+        },
+        _ => {
+            Ok(ContainerState::Failed {
+                container_id,
+                error,
+                occurred_at: Instant::now(),
+            })
         }
     }
+}
 
-    pub async fn start_container(&self, container_id: String) -> Result<(), StateError> {
-        let current_state = self.get_current_state().await;
-        match current_state {
-            ContainerState::Created { container_id: current_id, .. } if current_id == container_id => {
-                self.transition_to(ContainerState::Running {
-                    container_id,
-                    started_at: Instant::now(),
-                }).await
-            },
-            _ => Err(StateError::InvalidTransition {
-                from: current_state,
-                to: ContainerState::Running {
-                    container_id,
-                    started_at: Instant::now(),
-                },
-            }),
+pub async fn create_container(current_state: &ContainerState, container_id: String) -> Result<ContainerState> {
+    match current_state {
+        ContainerState::Initial => {
+            Ok(ContainerState::Created {
+                container_id,
+                created_at: Instant::now(),
+            })
+        },
+        _ => {
+            Err(state_err(format!(
+                "無効な状態からの作成遷移: {}",
+                current_state
+            )))
         }
     }
+}
 
-    pub async fn execute_command(&self, container_id: String, command: String) -> Result<(), StateError> {
-        let current_state = self.get_current_state().await;
-        match current_state {
-            ContainerState::Running { container_id: current_id, .. } if current_id == container_id => {
-                self.transition_to(ContainerState::Executing {
-                    container_id,
-                    started_at: Instant::now(),
-                    command,
-                }).await
-            },
-            _ => Err(StateError::InvalidTransition {
-                from: current_state,
-                to: ContainerState::Executing {
-                    container_id,
-                    started_at: Instant::now(),
-                    command,
-                },
-            }),
+pub async fn start_container(current_state: &ContainerState) -> Result<ContainerState> {
+    match current_state {
+        ContainerState::Created { container_id, .. } => {
+            Ok(ContainerState::Running {
+                container_id: container_id.clone(),
+                started_at: Instant::now(),
+            })
+        },
+        _ => {
+            Err(state_err(format!(
+                "無効な状態からの開始遷移: {}",
+                current_state
+            )))
         }
     }
+}
 
-    pub async fn stop_container(&self, container_id: String, exit_code: i32) -> Result<(), StateError> {
-        let current_state = self.get_current_state().await;
-        let execution_time = current_state.duration_since_start()
-            .ok_or_else(|| StateError::InvalidTransition {
-                from: current_state.clone(),
-                to: ContainerState::Stopped {
-                    container_id: container_id.clone(),
-                    exit_code,
-                    execution_time: std::time::Duration::from_secs(0),
-                },
-            })?;
-
-        match current_state {
-            ContainerState::Running { container_id: current_id, .. } |
-            ContainerState::Executing { container_id: current_id, .. }
-                if current_id == container_id => {
-                self.transition_to(ContainerState::Stopped {
-                    container_id,
-                    exit_code,
-                    execution_time,
-                }).await
-            },
-            _ => Err(StateError::InvalidTransition {
-                from: current_state,
-                to: ContainerState::Stopped {
-                    container_id,
-                    exit_code,
-                    execution_time,
-                },
-            }),
-        }
-    }
-
-    pub async fn fail_container(&self, container_id: String, error: String) -> Result<(), StateError> {
-        let current_state = self.get_current_state().await;
-        match current_state {
-            ContainerState::Initial |
-            ContainerState::Stopped { .. } |
-            ContainerState::Failed { .. } => {
-                Err(StateError::InvalidTransition {
-                    from: current_state,
-                    to: ContainerState::Failed {
-                        container_id,
-                        error,
-                        occurred_at: Instant::now(),
-                    },
-                })
-            },
-            _ => {
-                self.transition_to(ContainerState::Failed {
-                    container_id,
-                    error,
-                    occurred_at: Instant::now(),
-                }).await
-            }
+pub async fn stop_container(current_state: &ContainerState) -> Result<ContainerState> {
+    match current_state {
+        ContainerState::Running { container_id, .. } |
+        ContainerState::Executing { container_id, .. } => {
+            Ok(ContainerState::Stopped {
+                container_id: container_id.clone(),
+                stopped_at: Instant::now(),
+            })
+        },
+        _ => {
+            Err(state_err(format!(
+                "無効な状態からの停止遷移: {}",
+                current_state
+            )))
         }
     }
 } 
\ No newline at end of file
diff --git a/src/docker/state/types.rs b/src/docker/state/types.rs
index 927daed..0a06d0c 100644
--- a/src/docker/state/types.rs
+++ b/src/docker/state/types.rs
@@ -1,7 +1,7 @@
+use std::fmt;
 use std::time::{Duration, Instant};
-use thiserror::Error;
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Debug, Clone)]
 pub enum ContainerState {
     Initial,
     Created {
@@ -19,8 +19,7 @@ pub enum ContainerState {
     },
     Stopped {
         container_id: String,
-        exit_code: i32,
-        execution_time: Duration,
+        stopped_at: Instant,
     },
     Failed {
         container_id: String,
@@ -29,22 +28,6 @@ pub enum ContainerState {
     },
 }
 
-#[derive(Debug, Error)]
-pub enum StateError {
-    #[error("Invalid state transition from {from:?} to {to:?}")]
-    InvalidTransition {
-        from: ContainerState,
-        to: ContainerState,
-    },
-    #[error("Container ID mismatch: expected {expected}, got {actual}")]
-    ContainerIdMismatch {
-        expected: String,
-        actual: String,
-    },
-    #[error("Container not found: {0}")]
-    ContainerNotFound(String),
-}
-
 impl ContainerState {
     pub fn container_id(&self) -> Option<&str> {
         match self {
@@ -57,15 +40,36 @@ impl ContainerState {
         }
     }
 
-    pub fn is_terminal(&self) -> bool {
-        matches!(self, ContainerState::Stopped { .. } | ContainerState::Failed { .. })
-    }
-
     pub fn duration_since_start(&self) -> Option<Duration> {
         match self {
             ContainerState::Running { started_at, .. } |
-            ContainerState::Executing { started_at, .. } => Some(started_at.elapsed()),
+            ContainerState::Executing { started_at, .. } => {
+                Some(started_at.elapsed())
+            }
             _ => None,
         }
     }
+}
+
+impl fmt::Display for ContainerState {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            ContainerState::Initial => write!(f, "初期状態"),
+            ContainerState::Created { container_id, .. } => {
+                write!(f, "作成済み(ID: {})", container_id)
+            }
+            ContainerState::Running { container_id, .. } => {
+                write!(f, "実行中(ID: {})", container_id)
+            }
+            ContainerState::Executing { container_id, command, .. } => {
+                write!(f, "コマンド実行中(ID: {}, コマンド: {})", container_id, command)
+            }
+            ContainerState::Stopped { container_id, .. } => {
+                write!(f, "停止済み(ID: {})", container_id)
+            }
+            ContainerState::Failed { container_id, error, .. } => {
+                write!(f, "失敗(ID: {}, エラー: {})", container_id, error)
+            }
+        }
+    }
 } 
\ No newline at end of file
diff --git a/src/docker/state/validation.rs b/src/docker/state/validation.rs
index 206e136..2e80dfd 100644
--- a/src/docker/state/validation.rs
+++ b/src/docker/state/validation.rs
@@ -1,6 +1,8 @@
-use crate::docker::state::types::{ContainerState, StateError};
+use crate::docker::error::state_err;
+use crate::error::Result;
+use super::ContainerState;
 
-pub async fn validate_transition(current: &ContainerState, new: &ContainerState) -> Result<(), StateError> {
+pub async fn validate_transition(current: &ContainerState, new: &ContainerState) -> Result<()> {
     match (current, new) {
         // 初期状態からの遷移
         (ContainerState::Initial, ContainerState::Created { .. }) => Ok(()),
@@ -28,30 +30,31 @@ pub async fn validate_transition(current: &ContainerState, new: &ContainerState)
         // 終端状態からの遷移は許可しない
         (ContainerState::Stopped { .. }, _) |
         (ContainerState::Failed { .. }, _) => {
-            Err(StateError::InvalidTransition {
-                from: current.clone(),
-                to: new.clone(),
-            })
+            Err(state_err(format!(
+                "無効な状態遷移: {} -> {}",
+                current, new
+            )))
         }
         
         // その他の遷移は無効
-        _ => Err(StateError::InvalidTransition {
-            from: current.clone(),
-            to: new.clone(),
-        }),
+        _ => Err(state_err(format!(
+            "無効な状態遷移: {} -> {}",
+            current, new
+        ))),
     }
 }
 
-pub fn validate_container_id(current: &ContainerState, new: &ContainerState) -> Result<(), StateError> {
-    let current_id = current.container_id().unwrap_or_default();
-    let new_id = new.container_id().unwrap_or_default();
+fn validate_container_id(current: &ContainerState, new: &ContainerState) -> Result<()> {
+    let current_id = current.container_id();
+    let new_id = new.container_id();
     
-    if current_id == new_id {
-        Ok(())
+    if current_id != new_id {
+        Err(state_err(format!(
+            "コンテナIDが一致しません: {} != {}",
+            current_id.unwrap_or("なし"),
+            new_id.unwrap_or("なし")
+        )))
     } else {
-        Err(StateError::ContainerIdMismatch {
-            expected: current_id.to_string(),
-            actual: new_id.to_string(),
-        })
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/error.rs b/src/error.rs
index 3beada2..5ba1143 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -1,40 +1,61 @@
 use std::io;
-use std::path::StripPrefixError;
 use thiserror::Error;
 
-pub const NO_ACTIVE_CONTEST: &str = "アクティブなコンテストがありません。'work'コマンドで設定してください。";
-
 #[derive(Debug, Error)]
-pub enum ContestError {
+pub enum CphError {
+    #[error("IOエラー: {0}")]
+    IO(#[from] io::Error),
+
     #[error("設定エラー: {0}")]
     Config(String),
-    
+
+    #[error("Dockerエラー: {0}")]
+    Docker(String),
+
+    #[error("コンテストエラー: {0}")]
+    Contest(String),
+
     #[error("ファイルシステムエラー: {0}")]
-    FileSystem(String),
-    
-    #[error("言語エラー: {0}")]
-    Language(String),
-    
-    #[error("サイトエラー: {0}")]
-    Site(String),
+    Fs(String),
+
+    #[error("その他のエラー: {0}")]
+    Other(String),
 }
 
-#[derive(Debug, Error)]
-pub enum CphError {
-    #[error("IOエラー: {0}")]
-    Io(#[from] io::Error),
+pub type Result<T> = std::result::Result<T, CphError>;
 
-    #[error("YAMLエラー: {0}")]
-    Yaml(#[from] serde_yaml::Error),
+// エラー作成用のヘルパー関数
+pub fn io_err(msg: String) -> CphError {
+    CphError::IO(io::Error::new(io::ErrorKind::Other, msg))
+}
 
-    #[error("パスエラー: {0}")]
-    Path(#[from] StripPrefixError),
+pub fn config_err(msg: String) -> CphError {
+    CphError::Config(msg)
+}
 
-    #[error("{0}")]
-    Contest(#[from] ContestError),
+pub fn docker_err(msg: String) -> CphError {
+    CphError::Docker(msg)
+}
+
+pub fn contest_err(msg: String) -> CphError {
+    CphError::Contest(msg)
+}
+
+pub fn fs_err(msg: String) -> CphError {
+    CphError::Fs(msg)
+}
 
-    #[error("{0}")]
-    Message(String),
+pub fn other_err(msg: String) -> CphError {
+    CphError::Other(msg)
 }
 
-pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>; 
\ No newline at end of file
+// エラー変換用のマクロ
+#[macro_export]
+macro_rules! cph_err {
+    ($kind:ident, $msg:expr) => {
+        crate::error::$kind(format!("{}", $msg))
+    };
+    ($kind:ident, $fmt:expr, $($arg:tt)*) => {
+        crate::error::$kind(format!($fmt, $($arg)*))
+    };
+} 
\ No newline at end of file
diff --git a/src/fs/backup.rs b/src/fs/backup.rs
index 1ce8068..a2d82f5 100644
--- a/src/fs/backup.rs
+++ b/src/fs/backup.rs
@@ -1,7 +1,8 @@
 use std::fs;
 use std::path::{Path, PathBuf};
-use fs_extra::dir::{self, CopyOptions};
-use super::error::{Result, FsError};
+use tempfile::TempDir;
+use crate::error::Result;
+use super::error::{fs_err, fs_err_with_source};
 
 /// バックアップを管理する構造体
 #[derive(Debug)]
@@ -13,46 +14,35 @@ pub struct BackupManager {
 impl BackupManager {
     /// 新しいバックアップマネージャーを作成
     pub fn new() -> Result<Self> {
-        let backup_dir = std::env::temp_dir().join("cph_backup");
-        fs::create_dir_all(&backup_dir)
-            .map_err(|e| FsError::FileSystem {
-                message: format!("バックアップディレクトリの作成に失敗しました: {}", e),
-                source: Some(e),
-            })?;
-
         Ok(Self {
-            backup_dir: Some(backup_dir),
+            backup_dir: None,
         })
     }
 
     /// バックアップを作成
-    pub fn create(&mut self, path: &Path) -> Result<()> {
-        if let Some(backup_dir) = &self.backup_dir {
-            // 既存のバックアップをクリーンアップ
-            if backup_dir.exists() {
-                fs::remove_dir_all(backup_dir)
-                    .map_err(|e| FsError::Backup {
-                        message: format!("既存のバックアップの削除に失敗しました: {}", e),
-                        source: Some(e),
-                    })?;
-            }
+    pub fn create<P: AsRef<Path>>(&mut self, target_dir: P) -> Result<()> {
+        if self.backup_dir.is_some() {
+            return Ok(());
+        }
+
+        let temp_dir = TempDir::new()
+            .map_err(|e| fs_err_with_source("バックアップディレクトリの作成に失敗しました", e))?;
 
-            // バックアップディレクトリを作成
-            fs::create_dir_all(backup_dir)
-                .map_err(|e| FsError::Backup {
-                        message: format!("バックアップディレクトリの作成に失敗しました: {}", e),
-                        source: Some(e),
-                    })?;
+        let backup_path = temp_dir.path().to_path_buf();
+        fs::create_dir_all(&backup_path)
+            .map_err(|e| fs_err_with_source("バックアップディレクトリの作成に失敗しました", e))?;
 
-            // ディレクトリをコピー
-            let options = CopyOptions::new();
-            dir::copy(path, backup_dir, &options)
-                .map_err(|e| FsError::FileSystem {
-                    message: format!("ファイルのバックアップに失敗しました: {}", e),
-                    source: Some(std::io::Error::new(std::io::ErrorKind::Other, e.to_string())),
-                })?;
+        // ターゲットディレクトリの内容をコピー
+        if target_dir.as_ref().exists() {
+            fs_extra::dir::copy(
+                target_dir.as_ref(),
+                &backup_path,
+                &fs_extra::dir::CopyOptions::new(),
+            )
+            .map_err(|e| fs_err(format!("バックアップの作成に失敗しました: {}", e)))?;
         }
 
+        self.backup_dir = Some(backup_path);
         Ok(())
     }
 
@@ -60,12 +50,9 @@ impl BackupManager {
     pub fn restore(&self) -> Result<()> {
         if let Some(backup_dir) = &self.backup_dir {
             if backup_dir.exists() {
-                let options = CopyOptions::new();
-                dir::copy(backup_dir, "..", &options)
-                    .map_err(|e| FsError::Backup {
-                        message: format!("バックアップからの復元に失敗しました: {}", e),
-                        source: Some(std::io::Error::new(std::io::ErrorKind::Other, e.to_string())),
-                    })?;
+                let options = fs_extra::dir::CopyOptions::new();
+                fs_extra::dir::copy(backup_dir, "..", &options)
+                    .map_err(|e| fs_err(format!("バックアップからの復元に失敗しました: {}", e)))?;
             }
         }
 
@@ -77,10 +64,7 @@ impl BackupManager {
         if let Some(backup_dir) = &self.backup_dir {
             if backup_dir.exists() {
                 fs::remove_dir_all(backup_dir)
-                    .map_err(|e| FsError::Backup {
-                        message: format!("バックアップのクリーンアップに失敗しました: {}", e),
-                        source: Some(e),
-                    })?;
+                    .map_err(|e| fs_err_with_source("バックアップのクリーンアップに失敗しました", e))?;
             }
         }
 
diff --git a/src/fs/docker.rs b/src/fs/docker.rs
index 12131eb..28ff6f5 100644
--- a/src/fs/docker.rs
+++ b/src/fs/docker.rs
@@ -1,21 +1,12 @@
-use std::path::{Path, PathBuf};
+use std::path::Path;
 use std::os::unix::fs::PermissionsExt;
+use crate::error::Result;
 use nix::unistd::{Uid, Gid};
-use super::error::Result;
 
-/// Docker環境でのファイル操作に特化したトレイト
 pub trait DockerFileOperations {
-    /// 一時ディレクトリを作成
-    fn create_temp_directory(&self) -> Result<PathBuf>;
-    
-    /// ファイルの権限を設定
-    fn set_permissions(&self, path: &Path, mode: u32) -> Result<()>;
-    
-    /// ファイルの所有者とグループを設定
-    fn set_ownership(&self, path: &Path, uid: Option<Uid>, gid: Option<Gid>) -> Result<()>;
-    
-    /// ソースファイルを書き込み
-    fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> Result<PathBuf>;
+    fn create_temp_directory(&self) -> Result<std::path::PathBuf>;
+    fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()>;
+    fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf>;
 }
 
 /// Docker環境でのファイル操作のデフォルト実装
@@ -56,11 +47,11 @@ mod tests {
     }
 
     impl DockerFileOperations for MockDockerFileOps {
-        fn create_temp_directory(&self) -> Result<PathBuf> {
+        fn create_temp_directory(&self) -> Result<std::path::PathBuf> {
             Ok(self.temp_dir.path().to_path_buf())
         }
 
-        fn set_permissions(&self, path: &Path, _mode: u32) -> Result<()> {
+        fn set_permissions<P: AsRef<Path>>(&self, path: P, _mode: u32) -> Result<()> {
             if path.exists() {
                 Ok(())
             } else {
@@ -76,7 +67,7 @@ mod tests {
             }
         }
 
-        fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> Result<PathBuf> {
+        fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<std::path::PathBuf> {
             let file_path = dir.join(filename);
             fs::write(&file_path, content)?;
             Ok(file_path)
diff --git a/src/fs/error.rs b/src/fs/error.rs
index d35ffff..d4924f6 100644
--- a/src/fs/error.rs
+++ b/src/fs/error.rs
@@ -1,102 +1,9 @@
-use std::fmt;
-use std::io;
-use nix::errno::Errno;
-use fs_extra::error::Error as FsExtraError;
+use crate::error::CphError;
 
-#[derive(Debug)]
-pub enum FsError {
-    FileSystem {
-        message: String,
-        source: Option<io::Error>,
-    },
-    Backup {
-        message: String,
-        source: Option<io::Error>,
-    },
-    Transaction {
-        message: String,
-        source: Option<Box<dyn std::error::Error>>,
-    },
+pub fn fs_err(msg: String) -> CphError {
+    CphError::Fs(msg)
 }
 
-impl fmt::Display for FsError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            FsError::FileSystem { message, source } => {
-                write!(f, "ファイルシステムエラー: {}", message)?;
-                if let Some(err) = source {
-                    write!(f, " (原因: {})", err)?;
-                }
-                Ok(())
-            }
-            FsError::Backup { message, source } => {
-                write!(f, "バックアップエラー: {}", message)?;
-                if let Some(err) = source {
-                    write!(f, " (原因: {})", err)?;
-                }
-                Ok(())
-            }
-            FsError::Transaction { message, source } => {
-                write!(f, "トランザクションエラー: {}", message)?;
-                if let Some(err) = source {
-                    write!(f, " (原因: {})", err)?;
-                }
-                Ok(())
-            }
-        }
-    }
-}
-
-impl std::error::Error for FsError {
-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
-        match self {
-            FsError::FileSystem { source, .. } => source.as_ref().map(|e| e as _),
-            FsError::Backup { source, .. } => source.as_ref().map(|e| e as _),
-            FsError::Transaction { source, .. } => source.as_ref().map(|e| &**e as _),
-        }
-    }
-}
-
-impl From<io::Error> for FsError {
-    fn from(err: io::Error) -> Self {
-        FsError::FileSystem {
-            message: err.to_string(),
-            source: Some(err),
-        }
-    }
-}
-
-impl From<Errno> for FsError {
-    fn from(err: Errno) -> Self {
-        FsError::FileSystem {
-            message: err.to_string(),
-            source: Some(io::Error::from_raw_os_error(err as i32)),
-        }
-    }
-}
-
-impl From<FsExtraError> for FsError {
-    fn from(err: FsExtraError) -> Self {
-        FsError::FileSystem {
-            message: err.to_string(),
-            source: Some(io::Error::new(io::ErrorKind::Other, err.to_string())),
-        }
-    }
-}
-
-impl From<String> for FsError {
-    fn from(message: String) -> Self {
-        FsError::FileSystem {
-            message,
-            source: None,
-        }
-    }
-}
-
-impl From<&str> for FsError {
-    fn from(message: &str) -> Self {
-        message.to_string().into()
-    }
-}
-
-pub type Result<T> = std::result::Result<T, FsError>; 
\ No newline at end of file
+pub fn fs_err_with_source<E: std::error::Error>(msg: &str, source: E) -> CphError {
+    CphError::Fs(format!("{}: {}", msg, source))
+} 
\ No newline at end of file
diff --git a/src/fs/manager.rs b/src/fs/manager.rs
index 33bad30..38b1d1f 100644
--- a/src/fs/manager.rs
+++ b/src/fs/manager.rs
@@ -1,222 +1,67 @@
 use std::path::{Path, PathBuf};
-use std::os::unix::fs::PermissionsExt;
-use std::cell::UnsafeCell;
-use nix::unistd::{Uid, Gid};
-use tempfile::TempDir;
-use super::{BackupManager, FileOperation, FileOperationBuilder, DockerFileOperations, DefaultDockerFileOperations};
-use super::error::Result;
+use crate::error::Result;
+use super::error::{fs_err, fs_err_with_source};
+use super::{FileOperationBuilder, FileTransaction};
 
-/// ファイル操作を管理する構造体
-#[derive(Debug)]
 pub struct FileManager {
-    /// バックアップマネージャー
-    backup_manager: BackupManager,
-    /// 基準となるパス
-    base_path: PathBuf,
-    /// 一時ディレクトリ
-    temp_dir: UnsafeCell<Option<TempDir>>,
+    builder: FileOperationBuilder,
 }
 
 impl FileManager {
-    /// 新しいファイルマネージャーを作成
     pub fn new() -> Result<Self> {
         Ok(Self {
-            backup_manager: BackupManager::new()?,
-            base_path: PathBuf::new(),
-            temp_dir: UnsafeCell::new(None),
+            builder: FileOperationBuilder::new(),
         })
     }
 
-    /// 基準パスを設定
-    pub fn with_base_path<P: AsRef<Path>>(mut self, path: P) -> Self {
-        self.base_path = path.as_ref().to_path_buf();
-        self
+    pub fn create_directory<P: AsRef<Path>>(&self, path: P) -> Result<()> {
+        let operation = self.builder.create_dir(path);
+        let mut transaction = FileTransaction::new(vec![operation]);
+        transaction.execute()
     }
 
-    /// トランザクション的なファイル操作を実行
-    pub fn execute_operations(&mut self, operations: Vec<Box<dyn FileOperation>>) -> Result<()> {
-        // バックアップを作成
-        self.backup_manager.create(&self.base_path)?;
-
-        // 操作を実行
-        for op in operations {
-            if let Err(e) = op.execute() {
-                // エラーが発生した場合、バックアップから復元
-                self.backup_manager.restore()?;
-                return Err(e);
-            }
-        }
-
-        // 成功した場合、バックアップをクリーンアップ
-        self.backup_manager.cleanup()?;
-        Ok(())
+    pub fn copy_file<P: AsRef<Path>>(&self, from: P, to: P) -> Result<()> {
+        let operation = self.builder.copy(from, to);
+        let mut transaction = FileTransaction::new(vec![operation]);
+        transaction.execute()
     }
 
-    /// ディレクトリを作成
-    pub fn create_directory(&mut self, path: &Path) -> Result<()> {
-        let operations = FileOperationBuilder::new()
-            .create_dir(path)
-            .build();
-        self.execute_operations(operations)
+    pub fn move_file<P: AsRef<Path>>(&self, from: P, to: P) -> Result<()> {
+        let copy_operation = self.builder.copy(from.as_ref(), to.as_ref());
+        let remove_operation = self.builder.remove(from);
+        let mut transaction = FileTransaction::new(vec![copy_operation, remove_operation]);
+        transaction.execute()
     }
 
-    /// ファイルをコピー
-    pub fn copy_file(&mut self, from: &Path, to: &Path) -> Result<()> {
-        let operations = FileOperationBuilder::new()
-            .copy_file(from, to)
-            .build();
-        self.execute_operations(operations)
+    pub fn delete_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
+        let operation = self.builder.remove(path);
+        let mut transaction = FileTransaction::new(vec![operation]);
+        transaction.execute()
     }
 
-    /// ファイルを移動
-    pub fn move_file(&mut self, from: &Path, to: &Path) -> Result<()> {
-        let operations = FileOperationBuilder::new()
-            .copy_file(from, to)
-            .delete_file(from)
-            .build();
-        self.execute_operations(operations)
+    pub fn create_temp_directory(&self) -> Result<PathBuf> {
+        let temp_dir = tempfile::TempDir::new()
+            .map_err(|e| fs_err_with_source("一時ディレクトリの作成に失敗しました", e))?;
+        let path = temp_dir.path().to_path_buf();
+        Ok(path)
     }
 
-    /// ファイルを削除
-    pub fn delete_file(&mut self, path: &Path) -> Result<()> {
-        let operations = FileOperationBuilder::new()
-            .delete_file(path)
-            .build();
-        self.execute_operations(operations)
+    pub fn write_source_file<P: AsRef<Path>>(&self, dir: P, filename: &str, content: &str) -> Result<PathBuf> {
+        let path = dir.as_ref().join(filename);
+        std::fs::write(&path, content)
+            .map_err(|e| fs_err_with_source("ソースファイルの書き込みに失敗しました", e))?;
+        Ok(path)
     }
 
-    /// バックアップを作成
-    pub fn backup(&mut self, path: &Path) -> Result<()> {
-        self.backup_manager.create(path)
-    }
-
-    /// バックアップから復元
-    pub fn rollback(&self) -> Result<()> {
-        self.backup_manager.restore()
-    }
-
-    /// バックアップをクリーンアップ
-    pub fn cleanup(&mut self) -> Result<()> {
-        self.backup_manager.cleanup()
-    }
-}
-
-impl DockerFileOperations for FileManager {
-    fn create_temp_directory(&self) -> Result<PathBuf> {
-        let temp_dir = TempDir::new()?;
-        let temp_path = temp_dir.path().to_path_buf();
-        
-        // 権限を設定
-        self.ensure_directory_permissions(&temp_path)?;
-
-        // 所有者とグループを設定
-        let (uid, gid) = self.get_current_user_ids();
-        self.set_ownership(&temp_path, Some(uid), Some(gid))?;
-
-        // 一時ディレクトリを保持
-        unsafe {
-            *self.temp_dir.get() = Some(temp_dir);
-        }
-
-        Ok(temp_path)
-    }
-
-    fn set_permissions(&self, path: &Path, mode: u32) -> Result<()> {
-        let metadata = std::fs::metadata(path)?;
+    pub fn set_permissions<P: AsRef<Path>>(&self, path: P, mode: u32) -> Result<()> {
+        use std::os::unix::fs::PermissionsExt;
+        let path = path.as_ref();
+        let metadata = std::fs::metadata(path)
+            .map_err(|e| fs_err(format!("メタデータの取得に失敗しました: {}", e)))?;
         let mut perms = metadata.permissions();
         perms.set_mode(mode);
-        std::fs::set_permissions(path, perms)?;
-        Ok(())
-    }
-
-    fn set_ownership(&self, path: &Path, uid: Option<Uid>, gid: Option<Gid>) -> Result<()> {
-        nix::unistd::chown(path, uid, gid)?;
-        Ok(())
-    }
-
-    fn write_source_file(&self, dir: &Path, filename: &str, content: &str) -> Result<PathBuf> {
-        let file_path = dir.join(filename);
-        std::fs::write(&file_path, content)?;
-
-        // 所有者とグループを設定
-        let (uid, gid) = self.get_current_user_ids();
-        self.set_ownership(&file_path, Some(uid), Some(gid))?;
-
-        Ok(file_path)
-    }
-}
-
-impl DefaultDockerFileOperations for FileManager {}
-
-impl Drop for FileManager {
-    fn drop(&mut self) {
-        // 一時ディレクトリを自動的にクリーンアップ
-        unsafe {
-            if let Some(temp_dir) = (*self.temp_dir.get()).take() {
-                let _ = temp_dir.close();
-            }
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::fs;
-
-    #[test]
-    fn test_file_manager() -> Result<()> {
-        let mut manager = FileManager::new()?;
-        
-        // ディレクトリを作成
-        let test_dir = PathBuf::from("test_dir");
-        manager.create_directory(&test_dir)?;
-        assert!(test_dir.exists());
-
-        // ファイルを作成
-        let test_file = test_dir.join("test.txt");
-        fs::write(&test_file, "test content")?;
-        assert!(test_file.exists());
-
-        // ファイルをコピー
-        let copy_file = test_dir.join("test_copy.txt");
-        manager.copy_file(&test_file, &copy_file)?;
-        assert!(copy_file.exists());
-        assert_eq!(fs::read_to_string(&copy_file)?, "test content");
-
-        // ファイルを移動
-        let move_file = test_dir.join("test_move.txt");
-        manager.move_file(&copy_file, &move_file)?;
-        assert!(!copy_file.exists());
-        assert!(move_file.exists());
-
-        // ファイルを削除
-        manager.delete_file(&test_file)?;
-        assert!(!test_file.exists());
-
-        // クリーンアップ
-        fs::remove_dir_all(test_dir)?;
-        Ok(())
-    }
-
-    #[test]
-    fn test_docker_operations() -> Result<()> {
-        let manager = FileManager::new()?;
-        
-        // 一時ディレクトリの作成
-        let temp_dir = manager.create_temp_directory()?;
-        assert!(temp_dir.exists());
-
-        // ソースファイルの書き込み
-        let file_path = manager.write_source_file(&temp_dir, "test.txt", "test content")?;
-        assert!(file_path.exists());
-        assert_eq!(fs::read_to_string(&file_path)?, "test content");
-
-        // 権限設定
-        manager.set_permissions(&temp_dir, 0o777)?;
-        let metadata = fs::metadata(&temp_dir)?;
-        assert_eq!(metadata.permissions().mode() & 0o777, 0o777);
-
+        std::fs::set_permissions(path, perms)
+            .map_err(|e| fs_err(format!("権限の設定に失敗しました: {}", e)))?;
         Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/fs/mod.rs b/src/fs/mod.rs
index f381d3a..5b60684 100644
--- a/src/fs/mod.rs
+++ b/src/fs/mod.rs
@@ -10,4 +10,4 @@ pub use operations::{CopyOperation, CreateDirOperation, RemoveOperation, FileOpe
 pub use transaction::{FileTransaction, FileOperation, TransactionState};
 pub use manager::FileManager;
 pub use docker::{DockerFileOperations, DefaultDockerFileOperations};
-pub use error::{Result, FsError}; 
\ No newline at end of file
+pub use crate::error::Result; 
\ No newline at end of file
diff --git a/src/fs/operations.rs b/src/fs/operations.rs
index c88d281..4a10640 100644
--- a/src/fs/operations.rs
+++ b/src/fs/operations.rs
@@ -1,150 +1,136 @@
 use std::path::{Path, PathBuf};
-use super::error::{Result, FsError};
-use super::FileOperation;
+use crate::error::Result;
+use super::error::{fs_err, fs_err_with_source};
+use super::transaction::FileOperation;
 
-/// ディレクトリを作成する操作
-#[derive(Debug)]
-pub struct CreateDirOperation {
-    path: PathBuf,
-}
+pub struct FileOperationBuilder;
+
+impl FileOperationBuilder {
+    pub fn new() -> Self {
+        Self
+    }
 
-impl CreateDirOperation {
-    /// 新しいディレクトリ作成操作を作成
-    pub fn new<P: AsRef<Path>>(path: P) -> Self {
-        Self {
+    pub fn create_dir<P: AsRef<Path>>(&self, path: P) -> Box<dyn FileOperation> {
+        Box::new(CreateDirOperation {
             path: path.as_ref().to_path_buf(),
-        }
+        })
+    }
+
+    pub fn copy<P: AsRef<Path>>(&self, from: P, to: P) -> Box<dyn FileOperation> {
+        Box::new(CopyOperation {
+            from: from.as_ref().to_path_buf(),
+            to: to.as_ref().to_path_buf(),
+        })
+    }
+
+    pub fn remove<P: AsRef<Path>>(&self, path: P) -> Box<dyn FileOperation> {
+        Box::new(RemoveOperation {
+            path: path.as_ref().to_path_buf(),
+        })
     }
 }
 
+#[derive(Debug)]
+pub struct CreateDirOperation {
+    path: PathBuf,
+}
+
 impl FileOperation for CreateDirOperation {
     fn execute(&self) -> Result<()> {
         std::fs::create_dir_all(&self.path)
-            .map_err(|e| FsError::FileSystem {
-                message: format!("ディレクトリの作成に失敗しました: {}", e),
-                source: Some(e),
-            })?;
-        Ok(())
+            .map_err(|e| fs_err_with_source("ディレクトリの作成に失敗しました", e))
     }
 
     fn rollback(&self) -> Result<()> {
         if self.path.exists() {
             std::fs::remove_dir_all(&self.path)
-                .map_err(|e| FsError::FileSystem {
-                    message: format!("ディレクトリの削除に失敗しました: {}", e),
-                    source: Some(e),
-                })?;
+                .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
+        } else {
+            Ok(())
         }
-        Ok(())
     }
 }
 
-/// ファイルをコピーする操作
 #[derive(Debug)]
 pub struct CopyOperation {
     from: PathBuf,
     to: PathBuf,
 }
 
-impl CopyOperation {
-    /// 新しいファイルコピー操作を作成
-    pub fn new<P: AsRef<Path>>(from: P, to: P) -> Self {
-        Self {
-            from: from.as_ref().to_path_buf(),
-            to: to.as_ref().to_path_buf(),
-        }
-    }
-}
-
 impl FileOperation for CopyOperation {
     fn execute(&self) -> Result<()> {
-        std::fs::copy(&self.from, &self.to)
-            .map_err(|e| FsError::FileSystem {
-                message: format!("ファイルのコピーに失敗しました: {}", e),
-                source: Some(e),
-            })?;
+        if !self.from.exists() {
+            return Err(fs_err(format!(
+                "コピー元のファイルが存在しません: {:?}",
+                self.from
+            )));
+        }
+
+        if self.from.is_dir() {
+            fs_extra::dir::copy(
+                &self.from,
+                &self.to,
+                &fs_extra::dir::CopyOptions::new(),
+            )
+            .map_err(|e| fs_err(format!("ディレクトリのコピーに失敗しました: {}", e)))?;
+        } else {
+            fs_extra::file::copy(
+                &self.from,
+                &self.to,
+                &fs_extra::file::CopyOptions::new(),
+            )
+            .map_err(|e| fs_err(format!("ファイルのコピーに失敗しました: {}", e)))?;
+        }
+
         Ok(())
     }
 
     fn rollback(&self) -> Result<()> {
         if self.to.exists() {
-            std::fs::remove_file(&self.to)
-                .map_err(|e| FsError::FileSystem {
-                    message: format!("ファイルの削除に失敗しました: {}", e),
-                    source: Some(e),
-                })?;
+            if self.to.is_dir() {
+                std::fs::remove_dir_all(&self.to)
+                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
+            } else {
+                std::fs::remove_file(&self.to)
+                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))
+            }
+        } else {
+            Ok(())
         }
-        Ok(())
     }
 }
 
-/// ファイルを削除する操作
 #[derive(Debug)]
 pub struct RemoveOperation {
     path: PathBuf,
 }
 
-impl RemoveOperation {
-    /// 新しいファイル削除操作を作成
-    pub fn new<P: AsRef<Path>>(path: P) -> Self {
-        Self {
-            path: path.as_ref().to_path_buf(),
-        }
-    }
-}
-
 impl FileOperation for RemoveOperation {
     fn execute(&self) -> Result<()> {
         if self.path.exists() {
-            std::fs::remove_file(&self.path)
-                .map_err(|e| FsError::FileSystem {
-                    message: format!("ファイルの削除に失敗しました: {}", e),
-                    source: Some(e),
-                })?;
+            if self.path.is_dir() {
+                std::fs::remove_dir_all(&self.path)
+                    .map_err(|e| fs_err_with_source("ディレクトリの削除に失敗しました", e))
+            } else {
+                std::fs::remove_file(&self.path)
+                    .map_err(|e| fs_err_with_source("ファイルの削除に失敗しました", e))
+            }
+        } else {
+            Ok(())
         }
-        Ok(())
     }
 
     fn rollback(&self) -> Result<()> {
-        // 削除操作のロールバックは何もしない
-        Ok(())
-    }
-}
-
-/// ファイル操作のビルダー
-#[derive(Debug, Default)]
-pub struct FileOperationBuilder {
-    operations: Vec<Box<dyn FileOperation>>,
-}
-
-impl FileOperationBuilder {
-    /// 新しいビルダーを作成
-    pub fn new() -> Self {
-        Self {
-            operations: Vec::new(),
+        // 削除操作のロールバックは、ファイルの復元が必要
+        // ここでは単純な実装として、空のファイルを作成
+        if !self.path.exists() {
+            if let Some(parent) = self.path.parent() {
+                std::fs::create_dir_all(parent)
+                    .map_err(|e| fs_err_with_source("親ディレクトリの作成に失敗しました", e))?;
+            }
+            std::fs::File::create(&self.path)
+                .map_err(|e| fs_err_with_source("ファイルの作成に失敗しました", e))?;
         }
-    }
-
-    /// ディレクトリを作成する操作を追加
-    pub fn create_dir<P: AsRef<Path>>(mut self, path: P) -> Self {
-        self.operations.push(Box::new(CreateDirOperation::new(path)));
-        self
-    }
-
-    /// ファイルをコピーする操作を追加
-    pub fn copy_file<P: AsRef<Path>>(mut self, from: P, to: P) -> Self {
-        self.operations.push(Box::new(CopyOperation::new(from, to)));
-        self
-    }
-
-    /// ファイルを削除する操作を追加
-    pub fn delete_file<P: AsRef<Path>>(mut self, path: P) -> Self {
-        self.operations.push(Box::new(RemoveOperation::new(path)));
-        self
-    }
-
-    /// 操作のリストを構築
-    pub fn build(self) -> Vec<Box<dyn FileOperation>> {
-        self.operations
+        Ok(())
     }
 } 
\ No newline at end of file
diff --git a/src/fs/transaction.rs b/src/fs/transaction.rs
index b4f018f..0fd07ea 100644
--- a/src/fs/transaction.rs
+++ b/src/fs/transaction.rs
@@ -1,5 +1,6 @@
 use std::fmt::Debug;
-use super::error::{Result, FsError};
+use crate::error::Result;
+use super::error::fs_err;
 
 /// ファイル操作のトランザクション状態
 #[derive(Debug, PartialEq)]
@@ -43,10 +44,7 @@ impl FileTransaction {
     /// トランザクションを実行
     pub fn execute(&mut self) -> Result<()> {
         if self.state != TransactionState::Initial {
-            return Err(FsError::Transaction {
-                message: "トランザクションは既に実行されています".to_string(),
-                source: None,
-            });
+            return Err(fs_err("トランザクションは既に実行されています".to_string()));
         }
 
         self.state = TransactionState::InProgress;
@@ -56,10 +54,7 @@ impl FileTransaction {
             if let Err(e) = operation.execute() {
                 // エラーが発生した場合、ロールバック
                 self.rollback()?;
-                return Err(FsError::Transaction {
-                    message: format!("操作の実行中にエラーが発生しました: {}", e),
-                    source: Some(Box::new(e)),
-                });
+                return Err(fs_err(format!("操作の実行中にエラーが発生しました: {}", e)));
             }
         }
 
@@ -76,10 +71,7 @@ impl FileTransaction {
         // 逆順で各操作をロールバック
         for operation in self.operations.iter().rev() {
             if let Err(e) = operation.rollback() {
-                return Err(FsError::Transaction {
-                    message: format!("ロールバック中にエラーが発生しました: {}", e),
-                    source: Some(Box::new(e)),
-                });
+                return Err(fs_err(format!("ロールバック中にエラーが発生しました: {}", e)));
             }
         }
 
diff --git a/src/lib.rs b/src/lib.rs
index bced122..40eff6d 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -8,6 +8,8 @@ pub mod docker;
 pub mod contest;
 pub mod fs;
 pub mod test;
+pub mod error;
 
 pub use config::Config;
 pub use contest::ContestService;
+pub use error::{CphError, Result};
diff --git a/src/test/mod.rs b/src/test/mod.rs
index 918c203..96bd1d4 100644
--- a/src/test/mod.rs
+++ b/src/test/mod.rs
@@ -1,47 +1,35 @@
 use std::path::PathBuf;
-use crate::contest::error::{ContestError, ContestResult};
+use crate::error::Result;
+use crate::contest::error::config_err;
 
 pub struct TestCase {
     pub input: String,
     pub expected: String,
 }
 
-pub trait TestRunner {
-    fn run_test(&self, test_case: &TestCase) -> ContestResult<bool>;
-}
-
-pub fn load_test_cases(test_dir: &str) -> ContestResult<Vec<TestCase>> {
-    if !std::path::Path::new(test_dir).exists() {
-        return Err(ContestError::Config(
-            format!("テストディレクトリが存在しません: {}", test_dir)
-        ));
-    }
+pub fn load_test_cases(test_dir: &PathBuf) -> Result<Vec<TestCase>> {
+    let mut test_cases = Vec::new();
 
     let entries = std::fs::read_dir(test_dir)
-        .map_err(|e| ContestError::IO(e))?;
+        .map_err(|e| config_err(format!("テストディレクトリの読み取りに失敗しました: {}", e)))?;
 
-    let mut test_cases = Vec::new();
     for entry in entries {
-        let entry = entry.map_err(|e| ContestError::IO(e))?;
+        let entry = entry
+            .map_err(|e| config_err(format!("テストファイルの読み取りに失敗しました: {}", e)))?;
         let path = entry.path();
 
         if path.is_file() && path.extension().map_or(false, |ext| ext == "in") {
-            let test_file = path.to_str().ok_or_else(|| ContestError::Config(
-                format!("テストファイルのパスが無効です: {:?}", path)
-            ))?;
-
+            let test_file = path.to_str().unwrap();
             let expected_path = PathBuf::from(test_file).with_extension("out");
             if !expected_path.exists() {
-                return Err(ContestError::Config(
-                    format!("期待値ファイルが存在しません: {:?}", expected_path)
-                ));
+                return Err(config_err(format!("期待値ファイルが存在しません: {:?}", expected_path)));
             }
 
-            let input = std::fs::read_to_string(&test_file)
-                .map_err(|e| ContestError::IO(e))?;
+            let input = std::fs::read_to_string(&path)
+                .map_err(|e| config_err(format!("入力ファイルの読み取りに失敗しました: {}", e)))?;
 
             let expected = std::fs::read_to_string(&expected_path)
-                .map_err(|e| ContestError::IO(e))?;
+                .map_err(|e| config_err(format!("期待値ファイルの読み取りに失敗しました: {}", e)))?;
 
             test_cases.push(TestCase { input, expected });
         }
