diff --git a/src/bin/cph.rs b/src/bin/cph.rs
index 26b059c..43faeb1 100644
--- a/src/bin/cph.rs
+++ b/src/bin/cph.rs
@@ -1,19 +1,8 @@
 use cph::config::Config;
+use std::error::Error;
 
 #[tokio::main]
-async fn main() -> cph::error::Result<()> {
-    // 設定を読み込む
-    let config = Config::load()?;
-
-    // コマンドライン引数を取得
-    let args: Vec<String> = std::env::args().skip(1).collect();
-    if args.is_empty() {
-        println!("使用方法: cph <command> [args...]");
-        return Ok(());
-    }
-
-    // コマンドを実行
-    // TODO: 実際のコマンド実行処理を実装
-
+async fn main() -> Result<(), Box<dyn Error>> {
+    let _config = Config::load()?;
     Ok(())
 }
diff --git a/src/docker/config.rs b/src/docker/config.rs
index 380d881..2f08094 100644
--- a/src/docker/config.rs
+++ b/src/docker/config.rs
@@ -1,86 +1,90 @@
-use std::path::Path;
-use serde::{Serialize, Deserialize};
-use crate::config::{Config, ConfigError};
+use crate::config::Config;
+use crate::docker::error::{DockerError, DockerResult};
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone)]
 pub struct DockerConfig {
-    pub timeout_seconds: u64,
-    pub memory_limit_mb: u64,
-    pub mount_point: String,
+    timeout_seconds: u32,
+    memory_limit: u32,
+    mount_point: String,
+    image: String,
+    extension: String,
+    compile_cmd: Option<Vec<String>>,
+    run_cmd: Vec<String>,
 }
 
 impl DockerConfig {
-    pub fn new(timeout_seconds: u64, memory_limit_mb: u64, mount_point: String) -> Self {
-        Self {
-            timeout_seconds,
-            memory_limit_mb,
-            mount_point,
-        }
-    }
+    pub fn new(config: &Config, language: &str) -> DockerResult<Self> {
+        let base_path = format!("languages.{}.runner", language);
+        
+        // 言語の存在確認
+        let extension = config
+            .get::<String>(&format!("languages.{}.extension", language))
+            .map_err(|e| DockerError::Config(format!("言語名の解決に失敗しました: {}", e)))?;
 
-    pub fn default() -> Result<Self, ConfigError> {
-        let config = Config::load()?;
-        Self::from_config(&config)
-    }
+        // Docker設定の取得
+        let docker_path = format!("{}.docker", base_path);
+        let timeout_seconds = config
+            .get::<u64>(&format!("{}.timeout_seconds", docker_path))
+            .unwrap_or(10) as u32;
+        
+        let memory_limit = config
+            .get::<u64>(&format!("{}.memory_limit_mb", docker_path))
+            .unwrap_or(256) as u32;
+        
+        let mount_point = config
+            .get::<String>(&format!("{}.mount_point", docker_path))
+            .unwrap_or_else(|_| "/compile".to_string());
 
-    pub fn from_config(config: &Config) -> Result<Self, ConfigError> {
-        let timeout_seconds = config.get::<u64>("system.docker.timeout_seconds")
-            .map_err(|e| ConfigError::RequiredValueError(
-                format!("タイムアウト設定の読み込みに失敗しました: {}", e)
-            ))?;
+        // イメージ名を取得
+        let image = config
+            .get::<String>(&format!("{}.image", base_path))
+            .map_err(|e| DockerError::Config(format!("イメージ名の取得に失敗しました: {}", e)))?;
 
-        let memory_limit_mb = config.get::<u64>("system.docker.memory_limit_mb")
-            .map_err(|e| ConfigError::RequiredValueError(
-                format!("メモリ制限設定の読み込みに失敗しました: {}", e)
-            ))?;
+        // コマンドを取得
+        let compile_cmd = config
+            .get::<Vec<String>>(&format!("{}.compile", base_path))
+            .ok();
 
-        let mount_point = config.get::<String>("system.docker.mount_point")
-            .map_err(|e| ConfigError::RequiredValueError(
-                format!("マウントポイント設定の読み込みに失敗しました: {}", e)
-            ))?;
+        let run_cmd = config
+            .get::<Vec<String>>(&format!("{}.run", base_path))
+            .map_err(|e| DockerError::Config(format!("実行コマンドの取得に失敗しました: {}", e)))?;
 
-        Ok(Self::new(timeout_seconds, memory_limit_mb, mount_point))
+        Ok(Self {
+            timeout_seconds,
+            memory_limit,
+            mount_point,
+            image,
+            extension,
+            compile_cmd,
+            run_cmd,
+        })
     }
 
-    pub fn from_yaml<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
-        let content = std::fs::read_to_string(path)
-            .map_err(ConfigError::IoError)?;
-        serde_yaml::from_str(&content)
-            .map_err(ConfigError::ParseError)
+    pub fn timeout_seconds(&self) -> u32 {
+        self.timeout_seconds
     }
-}
 
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::config::ConfigBuilder;
+    pub fn memory_limit(&self) -> u32 {
+        self.memory_limit
+    }
+
+    pub fn mount_point(&self) -> &str {
+        &self.mount_point
+    }
 
-    #[test]
-    fn test_docker_config_from_config() -> Result<(), ConfigError> {
-        let builder = ConfigBuilder::new()
-            .add_required_value(
-                "system.docker.timeout_seconds",
-                "実行タイムアウト時間",
-                crate::config::ConfigType::Integer
-            )
-            .add_required_value(
-                "system.docker.memory_limit_mb",
-                "メモリ制限",
-                crate::config::ConfigType::Integer
-            )
-            .add_required_value(
-                "system.docker.mount_point",
-                "マウントポイント",
-                crate::config::ConfigType::String
-            );
+    pub fn image(&self) -> &str {
+        &self.image
+    }
 
-        let config = Config::load()?;
-        let docker_config = DockerConfig::from_config(&config)?;
+    pub fn extension(&self) -> &str {
+        &self.extension
+    }
 
-        assert!(docker_config.timeout_seconds > 0);
-        assert!(docker_config.memory_limit_mb > 0);
-        assert!(!docker_config.mount_point.is_empty());
+    pub fn compile_cmd(&self) -> Option<&[String]> {
+        self.compile_cmd.as_deref()
+    }
 
-        Ok(())
+    pub fn run_cmd(&self) -> &[String] {
+        &self.run_cmd
     }
 } 
\ No newline at end of file
diff --git a/src/docker/mod.rs b/src/docker/mod.rs
index 3edbbdf..9961fd6 100644
--- a/src/docker/mod.rs
+++ b/src/docker/mod.rs
@@ -1,5 +1,13 @@
 pub mod runner;
 pub mod state;
+pub mod error;
+pub mod config;
+pub mod fs;
+pub mod executor;
 
 pub use runner::DockerRunner;
-pub use state::RunnerState; 
\ No newline at end of file
+pub use state::RunnerState;
+pub use error::{DockerError, DockerResult};
+pub use config::DockerConfig;
+pub use fs::{DockerFileManager, DefaultDockerFileManager};
+pub use executor::{DockerCommandExecutor, DefaultDockerExecutor}; 
\ No newline at end of file
diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 0d54c76..f668f20 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -1,140 +1,159 @@
-pub mod command;
-
 use std::sync::Arc;
 use tokio::sync::Mutex;
+use uuid::Uuid;
 use crate::config::Config;
-use self::command::DockerCommand;
+use crate::docker::error::{DockerError, DockerResult};
 use crate::docker::state::RunnerState;
+use crate::docker::config::DockerConfig;
+use crate::docker::fs::{DockerFileManager, DefaultDockerFileManager};
+use crate::docker::executor::{DockerCommandExecutor, DefaultDockerExecutor};
 
 pub struct DockerRunner {
-    command: DockerCommand,
-    config: Arc<Config>,
-    language: String,
+    config: DockerConfig,
+    file_manager: Box<dyn DockerFileManager>,
+    executor: Box<dyn DockerCommandExecutor>,
     state: Arc<Mutex<RunnerState>>,
 }
 
 impl DockerRunner {
-    pub fn new(config: Config, language: String) -> Result<Self, String> {
-        // 言語の存在確認
-        let config = Arc::new(config);
-        let _resolved = config.get_with_alias::<String>(&format!("languages.{}.extension", language))
-            .map_err(|e| format!("言語名の解決に失敗しました: {}", e))?;
-
+    pub fn new(config: Config, language: String) -> DockerResult<Self> {
+        let docker_config = DockerConfig::new(&config, &language)?;
+        
         Ok(Self {
-            command: DockerCommand::new(),
-            config: config.clone(),
-            language,
+            config: docker_config,
+            file_manager: Box::new(DefaultDockerFileManager::new()),
+            executor: Box::new(DefaultDockerExecutor::new()),
             state: Arc::new(Mutex::new(RunnerState::Ready)),
         })
     }
 
-    pub fn from_language(language: &str) -> Result<Self, String> {
+    pub fn from_language(language: &str) -> DockerResult<Self> {
         let config = Config::load()
-            .map_err(|e| format!("設定の読み込みに失敗しました: {}", e))?;
+            .map_err(|e| DockerError::Config(format!("設定の読み込みに失敗しました: {}", e)))?;
         
         Self::new(config, language.to_string())
     }
 
-    fn get_docker_config(&self) -> Result<(u32, u32, String), String> {
-        let base_path = format!("languages.{}.runner.docker", self.language);
-        
-        let timeout_seconds = self.config.get::<u64>(&format!("{}.timeout_seconds", base_path))
-            .unwrap_or(10) as u32;
-        
-        let memory_limit = self.config.get::<u64>(&format!("{}.memory_limit_mb", base_path))
-            .unwrap_or(256) as u32;
-        
-        let mount_point = self.config.get::<String>(&format!("{}.mount_point", base_path))
-            .unwrap_or_else(|_| "/compile".to_string());
-
-        Ok((timeout_seconds, memory_limit, mount_point))
-    }
-
-    pub async fn run_in_docker(&mut self, source_code: &str) -> Result<String, String> {
+    pub async fn run_in_docker(&mut self, source_code: &str) -> DockerResult<String> {
         println!("Starting Docker execution");
         
-        // イメージ名を取得
-        let image = self.config.get::<String>(&format!("languages.{}.runner.image", self.language))
-            .map_err(|e| format!("イメージ名の取得に失敗しました: {}", e))?;
-
-        // 拡張子を取得
-        let extension = self.config.get::<String>(&format!("languages.{}.extension", self.language))
-            .map_err(|e| format!("拡張子の取得に失敗しました: {}", e))?;
-
-        // コンパイルコマンドを取得（オプション）
-        let compile_cmd = self.config.get::<Vec<String>>(&format!("languages.{}.runner.compile", self.language))
-            .ok();
-
-        // 実行コマンドを取得
-        let run_cmd = self.config.get::<Vec<String>>(&format!("languages.{}.runner.run", self.language))
-            .map_err(|e| format!("実行コマンドの取得に失敗しました: {}", e))?;
-
-        // Docker設定を取得
-        let (timeout_seconds, memory_limit, mount_point) = self.get_docker_config()?;
-
         // イメージの確認と取得
-        if !self.command.check_image(&image).await {
-            println!("Image not found, attempting to pull: {}", image);
-            if !self.command.pull_image(&image).await {
-                println!("Failed to pull image: {}", image);
+        if !self.executor.check_image(self.config.image()).await? {
+            println!("Image not found, attempting to pull: {}", self.config.image());
+            if !self.executor.pull_image(self.config.image()).await? {
+                println!("Failed to pull image: {}", self.config.image());
                 *self.state.lock().await = RunnerState::Error;
-                return Err(format!("Failed to pull image: {}", image));
+                return Err(DockerError::Runtime(format!("Failed to pull image: {}", self.config.image())));
             }
         }
 
-        println!("Image is ready: {}", image);
+        println!("Image is ready: {}", self.config.image());
         *self.state.lock().await = RunnerState::Running;
 
-        // ソースコードの実行
-        let result = self.command.run_code(
-            &image,
+        // 一時ディレクトリの作成
+        let temp_dir = self.file_manager.create_temp_directory()?;
+        
+        // ソースファイルの作成
+        let source_file = self.file_manager.write_source_file(
+            &temp_dir,
+            &format!("main.{}", self.config.extension()),
             source_code,
-            memory_limit,
-            timeout_seconds,
-            &mount_point,
-            &extension,
-            compile_cmd.as_deref(),
-            &run_cmd,
+        )?;
+        
+        // ファイルのパーミッション設定
+        self.file_manager.set_permissions(&source_file, 0o644)?;
+        self.file_manager.set_permissions(&temp_dir, 0o777)?;
+
+        // コマンドの構築
+        let command = if let Some(compile_cmd) = self.config.compile_cmd() {
+            format!(
+                "{} && {}",
+                compile_cmd.join(" "),
+                self.config.run_cmd().join(" ")
+            )
+        } else {
+            self.config.run_cmd().join(" ")
+        };
+
+        // コンテナの実行
+        let container_name = format!("runner-{}", Uuid::new_v4());
+        let result = self.executor.run_container(
+            &container_name,
+            self.config.image(),
+            self.config.memory_limit(),
+            temp_dir.to_str().unwrap(),
+            self.config.mount_point(),
+            &command,
+            self.config.timeout_seconds(),
         ).await;
 
-        match result {
-            Ok(output) => {
-                *self.state.lock().await = RunnerState::Ready;
-                Ok(output)
-            }
-            Err(e) => {
-                *self.state.lock().await = RunnerState::Error;
-                Err(e)
-            }
-        }
+        // 一時ディレクトリの削除
+        self.file_manager.cleanup(&temp_dir)?;
+
+        // 状態の更新と結果の返却
+        *self.state.lock().await = match &result {
+            Ok(_) => RunnerState::Completed,
+            Err(_) => RunnerState::Error,
+        };
+
+        result
     }
 
-    pub async fn cleanup(&mut self) -> Result<(), String> {
-        println!("Cleaning up Docker runner");
-        if self.command.stop_container().await {
-            println!("Container stopped successfully");
-            *self.state.lock().await = RunnerState::Stop;
-            Ok(())
-        } else {
-            println!("Failed to stop container");
-            *self.state.lock().await = RunnerState::Error;
-            Err("Failed to stop container".to_string())
-        }
+    pub async fn cleanup(&mut self) -> DockerResult<()> {
+        Ok(())
     }
 
     pub async fn get_state(&self) -> RunnerState {
         self.state.lock().await.clone()
     }
 
-    pub async fn inspect_mount_point(&mut self) -> Result<String, String> {
-        // Docker設定を取得
-        let (_, _, mount_point) = self.get_docker_config()?;
+    pub async fn inspect_mount_point(&mut self) -> DockerResult<String> {
+        let container_name = format!("inspector-{}", Uuid::new_v4());
+        self.executor.inspect_directory(
+            &container_name,
+            self.config.image(),
+            self.config.mount_point(),
+        ).await
+    }
+}
 
-        // イメージ名を取得
-        let image = self.config.get::<String>(&format!("languages.{}.runner.image", self.language))
-            .map_err(|e| format!("イメージ名の取得に失敗しました: {}", e))?;
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::docker::fs::MockDockerFileManager;
+    use crate::docker::executor::MockDockerExecutor;
+
+    #[tokio::test]
+    async fn test_docker_runner_success() {
+        let config = Config::load().unwrap();
+        let docker_config = DockerConfig::new(&config, "rust").unwrap();
+        
+        let mut runner = DockerRunner {
+            config: docker_config,
+            file_manager: Box::new(MockDockerFileManager::new()),
+            executor: Box::new(MockDockerExecutor::new(false)),
+            state: Arc::new(Mutex::new(RunnerState::Ready)),
+        };
+
+        let result = runner.run_in_docker("fn main() {}").await;
+        assert!(result.is_ok());
+        assert_eq!(runner.get_state().await, RunnerState::Completed);
+    }
+
+    #[tokio::test]
+    async fn test_docker_runner_failure() {
+        let config = Config::load().unwrap();
+        let docker_config = DockerConfig::new(&config, "rust").unwrap();
+        
+        let mut runner = DockerRunner {
+            config: docker_config,
+            file_manager: Box::new(MockDockerFileManager::new()),
+            executor: Box::new(MockDockerExecutor::new(true)),
+            state: Arc::new(Mutex::new(RunnerState::Ready)),
+        };
 
-        println!("Inspecting mount point directory: {}", &mount_point);
-        self.command.inspect_directory(&image, &mount_point).await
+        let result = runner.run_in_docker("fn main() {}").await;
+        assert!(result.is_err());
+        assert_eq!(runner.get_state().await, RunnerState::Error);
     }
 } 
\ No newline at end of file
diff --git a/src/docker/state.rs b/src/docker/state.rs
index c47f376..800f657 100644
--- a/src/docker/state.rs
+++ b/src/docker/state.rs
@@ -4,8 +4,9 @@ use std::fmt;
 pub enum RunnerState {
     Ready,
     Running,
-    Stop,
     Error,
+    Stop,
+    Completed,
 }
 
 impl fmt::Display for RunnerState {
diff --git a/tests/docker/runner_test.rs b/tests/docker/runner_test.rs
index dc812a4..7ba1c6a 100644
--- a/tests/docker/runner_test.rs
+++ b/tests/docker/runner_test.rs
@@ -1,7 +1,7 @@
 use std::process::Command;
 use tokio::test;
 use cph::config::Config;
-use cph::docker::DockerRunner;
+use cph::docker::{DockerRunner, DockerError};
 use std::fs;
 
 // Dockerデーモンが利用可能かチェックする
@@ -77,7 +77,10 @@ async fn test_timeout() {
 
     match runner.run_in_docker(source_code).await {
         Ok(_) => panic!("タイムアウトが発生しませんでした"),
-        Err(e) => assert!(e.contains("タイムアウト")),
+        Err(e) => match e {
+            DockerError::Timeout(_) => (),
+            _ => panic!("予期しないエラー: {}", e),
+        },
     }
 }
 
@@ -98,11 +101,11 @@ async fn test_memory_limit() {
     "#;
 
     match runner.run_in_docker(source_code).await {
-        Ok(_) => panic!("メモリ制限が機能していません"),
-        Err(e) => {
-            println!("Error message: {}", e);
-            assert!(e.contains("out of memory") || e.contains("Killed") || e.contains("タイムアウト"));
-        }
+        Ok(_) => panic!("メモリ制限が機能してせんでした"),
+        Err(e) => match e {
+            DockerError::Memory(_) | DockerError::Runtime(_) => (),
+            _ => panic!("予期しないエラー: {}", e),
+        },
     }
 }
 
