diff --git a/src/docker/state/manager.rs b/src/docker/state/manager.rs
index 061ba4a..2c865df 100644
--- a/src/docker/state/manager.rs
+++ b/src/docker/state/manager.rs
@@ -4,6 +4,7 @@ use crate::error::Result;
 use super::ContainerState;
 use crate::docker::error::state_err;
 use std::collections::HashMap;
+use super::types::{StateInfo, StateType};
 
 #[derive(Debug, Clone)]
 pub struct ContainerStateManager {
@@ -83,6 +84,52 @@ impl ContainerStateManager {
             .map(String::from)
             .ok_or_else(|| state_err("状態管理", "コンテナIDが見つかりません"))
     }
+
+    pub async fn regenerate_container(&self) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        let new_state = current_state.regenerate()
+            .ok_or_else(|| state_err(
+                "状態遷移",
+                format!("無効な状態からの再生成遷移: {}", current_state)
+            ))?;
+        *self.state.write().await = new_state;
+        Ok(())
+    }
+
+    pub async fn restore_state(&self, state_info: StateInfo) -> Result<()> {
+        let current_state = self.get_current_state().await;
+        if !matches!(current_state, ContainerState::Created { .. }) {
+            return Err(state_err(
+                "状態遷移",
+                format!("無効な状態からの状態復元: {}", current_state)
+            ));
+        }
+
+        let new_state = match state_info.state_type {
+            StateType::Running => ContainerState::Running {
+                container_id: state_info.container_id,
+                started_at: state_info.timestamp,
+            },
+            StateType::Executing(command) => ContainerState::Executing {
+                container_id: state_info.container_id,
+                started_at: state_info.timestamp,
+                command,
+            },
+            StateType::Stopped => ContainerState::Stopped {
+                container_id: state_info.container_id,
+                stopped_at: state_info.timestamp,
+                exit_status: None,
+            },
+            StateType::Failed(error) => ContainerState::Failed {
+                container_id: state_info.container_id,
+                error,
+                occurred_at: state_info.timestamp,
+            },
+        };
+
+        *self.state.write().await = new_state;
+        Ok(())
+    }
 }
 
 #[derive(Debug, Clone)]
diff --git a/src/docker/state/operations.rs b/src/docker/state/operations.rs
index ece8578..65dd915 100644
--- a/src/docker/state/operations.rs
+++ b/src/docker/state/operations.rs
@@ -82,4 +82,21 @@ pub async fn stop_container(current_state: &ContainerState) -> Result<ContainerS
             ))
         }
     }
+}
+
+pub async fn regenerate_container(current_state: &ContainerState) -> Result<ContainerState> {
+    if !current_state.can_regenerate() {
+        return Err(state_err(
+            "状態遷移",
+            format!("無効な状態からの再生成遷移: {}", current_state)
+        ));
+    }
+
+    let state_info = current_state.get_state_info()
+        .ok_or_else(|| state_err("状態遷移", "状態情報の取得に失敗しました"))?;
+
+    Ok(ContainerState::Created {
+        container_id: state_info.container_id,
+        created_at: Arc::new(Instant::now()),
+    })
 } 
\ No newline at end of file
diff --git a/src/docker/state/types.rs b/src/docker/state/types.rs
index 24e0ba5..e597ee1 100644
--- a/src/docker/state/types.rs
+++ b/src/docker/state/types.rs
@@ -3,6 +3,21 @@ use std::time::{Duration, Instant};
 use std::process::ExitStatus;
 use std::sync::Arc;
 
+#[derive(Debug, Clone)]
+pub enum StateType {
+    Running,
+    Executing(Arc<String>),
+    Stopped,
+    Failed(Arc<String>),
+}
+
+#[derive(Debug, Clone)]
+pub struct StateInfo {
+    pub container_id: Arc<String>,
+    pub state_type: StateType,
+    pub timestamp: Arc<Instant>,
+}
+
 #[derive(Debug, Clone)]
 pub enum ContainerState {
     Initial,
@@ -109,6 +124,58 @@ impl ContainerState {
             _ => None,
         }
     }
+
+    pub fn regenerate(&self) -> Option<Self> {
+        self.get_container_id_for_regeneration()
+            .map(|container_id| Self::Created {
+                container_id: Arc::clone(container_id),
+                created_at: Arc::new(Instant::now()),
+            })
+    }
+
+    fn get_container_id_for_regeneration(&self) -> Option<&Arc<String>> {
+        match self {
+            Self::Running { container_id, .. } |
+            Self::Executing { container_id, .. } |
+            Self::Stopped { container_id, .. } |
+            Self::Failed { container_id, .. } => Some(container_id),
+            _ => None,
+        }
+    }
+
+    pub fn can_regenerate(&self) -> bool {
+        self.get_container_id_for_regeneration().is_some()
+    }
+
+    pub fn get_state_info(&self) -> Option<StateInfo> {
+        self.create_state_info()
+    }
+
+    fn create_state_info(&self) -> Option<StateInfo> {
+        match self {
+            Self::Running { container_id, started_at } => Some(StateInfo {
+                container_id: Arc::clone(container_id),
+                state_type: StateType::Running,
+                timestamp: Arc::clone(started_at),
+            }),
+            Self::Executing { container_id, started_at, command } => Some(StateInfo {
+                container_id: Arc::clone(container_id),
+                state_type: StateType::Executing(Arc::clone(command)),
+                timestamp: Arc::clone(started_at),
+            }),
+            Self::Stopped { container_id, stopped_at, .. } => Some(StateInfo {
+                container_id: Arc::clone(container_id),
+                state_type: StateType::Stopped,
+                timestamp: Arc::clone(stopped_at),
+            }),
+            Self::Failed { container_id, occurred_at, error } => Some(StateInfo {
+                container_id: Arc::clone(container_id),
+                state_type: StateType::Failed(Arc::clone(error)),
+                timestamp: Arc::clone(occurred_at),
+            }),
+            _ => None,
+        }
+    }
 }
 
 impl fmt::Display for ContainerState {
diff --git a/src/docker/state/validation.rs b/src/docker/state/validation.rs
index 5de39ee..3917568 100644
--- a/src/docker/state/validation.rs
+++ b/src/docker/state/validation.rs
@@ -1,6 +1,7 @@
 use crate::error::docker::DockerErrorKind;
 use crate::error::Result;
 use crate::docker_error;
+use crate::docker::state::ContainerState;
 
 pub fn validate_image_name(image_name: &str) -> Result<()> {
     if image_name.is_empty() {
@@ -72,4 +73,24 @@ pub fn validate_env(key: &str, value: &str) -> Result<()> {
         ));
     }
     Ok(())
+}
+
+pub fn validate_regeneration(current_state: &ContainerState) -> Result<()> {
+    if !current_state.can_regenerate() {
+        return Err(docker_error!(
+            DockerErrorKind::ValidationError,
+            format!("現在の状態からは再生成できません: {}", current_state)
+        ));
+    }
+    Ok(())
+}
+
+pub fn validate_state_restoration(current_state: &ContainerState) -> Result<()> {
+    if !matches!(current_state, ContainerState::Created { .. }) {
+        return Err(docker_error!(
+            DockerErrorKind::ValidationError,
+            format!("状態の復元は作成済み状態からのみ可能です: {}", current_state)
+        ));
+    }
+    Ok(())
 } 
\ No newline at end of file
