diff --git a/src/docker/runner/mod.rs b/src/docker/runner/mod.rs
index 4ac1e7b..a5c62aa 100644
--- a/src/docker/runner/mod.rs
+++ b/src/docker/runner/mod.rs
@@ -1,10 +1,10 @@
 use std::sync::Arc;
-use std::time::{Duration, Instant};
+use std::time::Duration;
 use tokio::sync::Mutex;
 use tokio::time::timeout;
 
 use crate::docker::error::{DockerError, DockerResult};
-use crate::docker::state::container::{ContainerState, ContainerStateManager, StateError};
+use crate::docker::state::container::{ContainerState, ContainerStateManager};
 use crate::docker::config::ContainerConfig;
 use crate::docker::executor::{DockerCommand, DockerCommandExecutor};
 use crate::docker::traits::ContainerManager;
@@ -37,55 +37,54 @@ impl DockerRunner {
         let container_id = manager.get_container_id().await?;
         self.state_manager.set_container_id(container_id.clone()).await;
         
-        self.state_manager.transition_to(ContainerState::Created {
-            container_id,
-            created_at: Instant::now(),
-        }).await.map_err(DockerError::State)?;
-
-        Ok(())
+        self.state_manager.create_container(container_id)
+            .await
+            .map_err(DockerError::State)
     }
 
     pub async fn start(&mut self) -> DockerResult<()> {
-        let mut manager = self.container_manager.lock().await;
-        manager.start_container().await?;
+        let container_id = {
+            let manager = self.container_manager.lock().await;
+            manager.get_container_id().await?
+        };
 
-        self.state_manager.transition_to(ContainerState::Running {
-            container_id: manager.get_container_id().await?,
-            started_at: Instant::now(),
-        }).await.map_err(DockerError::State)?;
+        {
+            let mut manager = self.container_manager.lock().await;
+            manager.start_container().await?;
+        }
 
-        Ok(())
+        self.state_manager.start_container(container_id)
+            .await
+            .map_err(DockerError::State)
     }
 
     pub async fn stop(&mut self) -> DockerResult<()> {
-        let mut manager = self.container_manager.lock().await;
-        let container_id = manager.get_container_id().await?;
-        
-        manager.stop_container().await?;
-
-        let current_state = self.state_manager.get_current_state().await;
-        let execution_time = current_state.duration_since_start().unwrap_or_default();
-        let exit_code = manager.get_exit_code().await?;
+        let container_id = {
+            let manager = self.container_manager.lock().await;
+            manager.get_container_id().await?
+        };
 
-        self.state_manager.transition_to(ContainerState::Stopped {
-            container_id,
-            exit_code,
-            execution_time,
-        }).await.map_err(DockerError::State)?;
+        let exit_code = {
+            let mut manager = self.container_manager.lock().await;
+            manager.stop_container().await?;
+            manager.get_exit_code().await?
+        };
 
-        Ok(())
+        self.state_manager.stop_container(container_id, exit_code)
+            .await
+            .map_err(DockerError::State)
     }
 
     pub async fn execute(&mut self, command: &str) -> DockerResult<(String, String)> {
-        let mut manager = self.container_manager.lock().await;
-        let container_id = manager.get_container_id().await?;
+        let container_id = {
+            let manager = self.container_manager.lock().await;
+            manager.get_container_id().await?
+        };
 
-        // 実行状態に遷移
-        self.state_manager.transition_to(ContainerState::Executing {
-            container_id: container_id.clone(),
-            started_at: Instant::now(),
-            command: command.to_string(),
-        }).await.map_err(DockerError::State)?;
+        // コマンド実行状態に遷移
+        self.state_manager.execute_command(container_id.clone(), command.to_string())
+            .await
+            .map_err(DockerError::State)?;
 
         // タイムアウト付きでコマンドを実行
         let command = DockerCommand::new("exec")
@@ -101,28 +100,25 @@ impl DockerRunner {
             Ok(cmd_result) => {
                 match cmd_result {
                     Ok(output) => {
-                        self.state_manager.transition_to(ContainerState::Running {
-                            container_id,
-                            started_at: Instant::now(),
-                        }).await.map_err(DockerError::State)?;
+                        self.state_manager.start_container(container_id)
+                            .await
+                            .map_err(DockerError::State)?;
                         Ok((output.stdout, output.stderr))
                     }
                     Err(e) => {
-                        self.state_manager.transition_to(ContainerState::Failed {
+                        self.state_manager.fail_container(
                             container_id,
-                            error: e.to_string(),
-                            occurred_at: Instant::now(),
-                        }).await.map_err(DockerError::State)?;
+                            e.to_string(),
+                        ).await.map_err(DockerError::State)?;
                         Err(e)
                     }
                 }
             }
             Err(_) => {
-                self.state_manager.transition_to(ContainerState::Failed {
-                    container_id,
-                    error: format!("コマンドの実行がタイムアウトしました（{}秒）", self.timeout.as_secs()),
-                    occurred_at: Instant::now(),
-                }).await.map_err(DockerError::State)?;
+                let error = format!("コマンドの実行がタイムアウトしました（{}秒）", self.timeout.as_secs());
+                self.state_manager.fail_container(container_id, error.clone())
+                    .await
+                    .map_err(DockerError::State)?;
                 Err(DockerError::Command("コマンドの実行がタイムアウトしました".to_string()))
             }
         }
@@ -153,13 +149,16 @@ mod tests {
     }
 
     mock! {
-        DockerOps {}
+        ContainerOps {}
         #[async_trait::async_trait]
-        impl DockerOperations for DockerOps {
-            async fn initialize(&mut self, config: ContainerConfig) -> DockerResult<()>;
-            async fn start(&mut self) -> DockerResult<()>;
-            async fn stop(&mut self) -> DockerResult<()>;
-            async fn execute(&mut self, command: &str) -> DockerResult<(String, String)>;
+        impl ContainerManager for ContainerOps {
+            async fn create_container(&mut self, image: &str, cmd: Vec<String>, working_dir: &str) -> DockerResult<()>;
+            async fn start_container(&mut self) -> DockerResult<()>;
+            async fn stop_container(&mut self) -> DockerResult<()>;
+            async fn get_container_id(&self) -> DockerResult<String>;
+            async fn get_exit_code(&self) -> DockerResult<i32>;
+            async fn check_image(&self, image: &str) -> DockerResult<bool>;
+            async fn pull_image(&self, image: &str) -> DockerResult<()>;
         }
     }
 
@@ -174,16 +173,22 @@ mod tests {
                 stderr: "".to_string(),
             }));
 
-        let mut mock_ops = MockDockerOps::new();
+        let mut mock_ops = MockContainerOps::new();
         mock_ops
-            .expect_initialize()
-            .returning(|_| Ok(()));
+            .expect_create_container()
+            .returning(|_, _, _| Ok(()));
         mock_ops
-            .expect_start()
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
+        mock_ops
+            .expect_start_container()
             .returning(|| Ok(()));
         mock_ops
-            .expect_stop()
+            .expect_stop_container()
             .returning(|| Ok(()));
+        mock_ops
+            .expect_get_exit_code()
+            .returning(|| Ok(0));
 
         let mut runner = DockerRunner::new(
             Arc::new(Mutex::new(mock_ops)),
@@ -218,19 +223,19 @@ mod tests {
         let mut mock_executor = MockDockerExecutor::new();
         mock_executor
             .expect_execute()
-            .returning(|_| Ok(CommandOutput {
-                success: true,
-                stdout: "container_id".to_string(),
-                stderr: "".to_string(),
-            }));
+            .returning(|_| {
+                sleep(Duration::from_secs(2));
+                Ok(CommandOutput {
+                    success: true,
+                    stdout: "".to_string(),
+                    stderr: "".to_string(),
+                })
+            });
 
-        let mut mock_ops = MockDockerOps::new();
+        let mut mock_ops = MockContainerOps::new();
         mock_ops
-            .expect_execute()
-            .returning(|_| async {
-                sleep(Duration::from_secs(2)).await;
-                Ok(("output".to_string(), "".to_string()))
-            }.boxed());
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
 
         let mut runner = DockerRunner::new(
             Arc::new(Mutex::new(mock_ops)),
@@ -250,26 +255,22 @@ mod tests {
         let mut mock_executor = MockDockerExecutor::new();
         mock_executor
             .expect_execute()
-            .returning(|cmd| {
-                if cmd.command == "inspect" {
-                    Ok(CommandOutput {
-                        success: true,
-                        stdout: "137".to_string(),
-                        stderr: "".to_string(),
-                    })
-                } else {
-                    Ok(CommandOutput {
-                        success: true,
-                        stdout: "container_id".to_string(),
-                        stderr: "".to_string(),
-                    })
-                }
-            });
+            .returning(|_| Ok(CommandOutput {
+                success: true,
+                stdout: "".to_string(),
+                stderr: "".to_string(),
+            }));
 
-        let mut mock_ops = MockDockerOps::new();
+        let mut mock_ops = MockContainerOps::new();
+        mock_ops
+            .expect_get_container_id()
+            .returning(|| Ok("test_container".to_string()));
         mock_ops
-            .expect_stop()
+            .expect_stop_container()
             .returning(|| Ok(()));
+        mock_ops
+            .expect_get_exit_code()
+            .returning(|| Ok(137));
 
         let mut runner = DockerRunner::new(
             Arc::new(Mutex::new(mock_ops)),
diff --git a/src/docker/state/container.rs b/src/docker/state/container.rs
index 61fcad9..380e13b 100644
--- a/src/docker/state/container.rs
+++ b/src/docker/state/container.rs
@@ -162,6 +162,123 @@ impl ContainerStateManager {
         let state = self.state.lock().await;
         state.clone()
     }
+
+    pub async fn start_container(&self, container_id: String) -> Result<(), StateError> {
+        let current_state = self.get_current_state().await;
+        match current_state {
+            ContainerState::Created { container_id: current_id, .. } if current_id == container_id => {
+                self.transition_to(ContainerState::Running {
+                    container_id,
+                    started_at: Instant::now(),
+                }).await
+            },
+            _ => Err(StateError::InvalidTransition {
+                from: current_state,
+                to: ContainerState::Running {
+                    container_id,
+                    started_at: Instant::now(),
+                },
+            }),
+        }
+    }
+
+    pub async fn execute_command(&self, container_id: String, command: String) -> Result<(), StateError> {
+        let current_state = self.get_current_state().await;
+        match current_state {
+            ContainerState::Running { container_id: current_id, .. } if current_id == container_id => {
+                self.transition_to(ContainerState::Executing {
+                    container_id,
+                    started_at: Instant::now(),
+                    command,
+                }).await
+            },
+            _ => Err(StateError::InvalidTransition {
+                from: current_state,
+                to: ContainerState::Executing {
+                    container_id,
+                    started_at: Instant::now(),
+                    command,
+                },
+            }),
+        }
+    }
+
+    pub async fn stop_container(&self, container_id: String, exit_code: i32) -> Result<(), StateError> {
+        let current_state = self.get_current_state().await;
+        let execution_time = current_state.duration_since_start()
+            .ok_or_else(|| StateError::InvalidTransition {
+                from: current_state.clone(),
+                to: ContainerState::Stopped {
+                    container_id: container_id.clone(),
+                    exit_code,
+                    execution_time: Duration::from_secs(0),
+                },
+            })?;
+
+        match current_state {
+            ContainerState::Running { container_id: current_id, .. } |
+            ContainerState::Executing { container_id: current_id, .. }
+                if current_id == container_id => {
+                self.transition_to(ContainerState::Stopped {
+                    container_id,
+                    exit_code,
+                    execution_time,
+                }).await
+            },
+            _ => Err(StateError::InvalidTransition {
+                from: current_state,
+                to: ContainerState::Stopped {
+                    container_id,
+                    exit_code,
+                    execution_time,
+                },
+            }),
+        }
+    }
+
+    pub async fn fail_container(&self, container_id: String, error: String) -> Result<(), StateError> {
+        let current_state = self.get_current_state().await;
+        match current_state {
+            ContainerState::Initial |
+            ContainerState::Stopped { .. } |
+            ContainerState::Failed { .. } => {
+                Err(StateError::InvalidTransition {
+                    from: current_state,
+                    to: ContainerState::Failed {
+                        container_id,
+                        error,
+                        occurred_at: Instant::now(),
+                    },
+                })
+            },
+            _ => {
+                self.transition_to(ContainerState::Failed {
+                    container_id,
+                    error,
+                    occurred_at: Instant::now(),
+                }).await
+            }
+        }
+    }
+
+    pub async fn create_container(&self, container_id: String) -> Result<(), StateError> {
+        let current_state = self.get_current_state().await;
+        match current_state {
+            ContainerState::Initial => {
+                self.transition_to(ContainerState::Created {
+                    container_id,
+                    created_at: Instant::now(),
+                }).await
+            },
+            _ => Err(StateError::InvalidTransition {
+                from: current_state,
+                to: ContainerState::Created {
+                    container_id,
+                    created_at: Instant::now(),
+                },
+            }),
+        }
+    }
 }
 
 impl ContainerState {
@@ -263,4 +380,56 @@ mod tests {
         let received_state = rx.recv().await.unwrap();
         assert_eq!(received_state, new_state);
     }
+
+    #[tokio::test]
+    async fn test_container_lifecycle() {
+        let manager = ContainerStateManager::new();
+        let container_id = "test_container".to_string();
+
+        // Created状態に遷移
+        let created_state = ContainerState::Created {
+            container_id: container_id.clone(),
+            created_at: Instant::now(),
+        };
+        assert!(manager.transition_to(created_state).await.is_ok());
+
+        // コンテナ起動
+        assert!(manager.start_container(container_id.clone()).await.is_ok());
+        let state = manager.get_current_state().await;
+        assert!(matches!(state, ContainerState::Running { .. }));
+
+        // コマンド実行
+        assert!(manager.execute_command(container_id.clone(), "test command".to_string()).await.is_ok());
+        let state = manager.get_current_state().await;
+        assert!(matches!(state, ContainerState::Executing { .. }));
+
+        // コンテナ停止
+        assert!(manager.stop_container(container_id.clone(), 0).await.is_ok());
+        let state = manager.get_current_state().await;
+        assert!(matches!(state, ContainerState::Stopped { .. }));
+    }
+
+    #[tokio::test]
+    async fn test_container_failure() {
+        let manager = ContainerStateManager::new();
+        let container_id = "test_container".to_string();
+
+        // Created状態に遷移
+        let created_state = ContainerState::Created {
+            container_id: container_id.clone(),
+            created_at: Instant::now(),
+        };
+        assert!(manager.transition_to(created_state).await.is_ok());
+
+        // コンテナ起動
+        assert!(manager.start_container(container_id.clone()).await.is_ok());
+
+        // エラー発生
+        assert!(manager.fail_container(container_id.clone(), "テストエラー".to_string()).await.is_ok());
+        let state = manager.get_current_state().await;
+        assert!(matches!(state, ContainerState::Failed { .. }));
+
+        // 失敗状態からの遷移は不可
+        assert!(manager.start_container(container_id.clone()).await.is_err());
+    }
 } 
\ No newline at end of file

分析結果：
1. 重要な機能の削除：なし（コンテナ状態管理の改善リファクタリング）
2. コードチェック：エラーなし（軽微な警告のみ）
3. 機能の重複：なし
4. 実装の効率性：改善（状態管理の責任分離、シンプル化）

結論：安全なリファクタリングであり、コードの品質向上に貢献する変更です。
