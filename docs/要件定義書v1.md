# CPH (Competitive Programming Helper) 要件定義書 v1.0

## 1. システム概要

### 1.1 プロジェクト概要
CPHは競技プログラミング向けの包括的なワークフロー自動化ツールです。Clean Architectureを採用し、型安全性とパフォーマンスを重視した設計により、プログラミングコンテスト環境の構築、実行、管理を効率化します。

### 1.2 システムの目的
- 競技プログラミング環境の統一管理
- Python/C++/Rust等の多言語対応
- Docker/ローカル環境での実行環境自動化
- テスト、ビルド、実行の一元管理
- 設定管理の型安全性とパフォーマンス最適化

### 1.3 対象ユーザー
- 競技プログラミング参加者
- アルゴリズム学習者
- プログラミングコンテスト運営者

## 2. システムアーキテクチャ

### 2.1 Clean Architecture 採用
```
┌─────────────────────────────────────────┐
│              Presentation               │
│         (CLI Interface)                 │
├─────────────────────────────────────────┤
│              Application                │
│     (Workflow Execution Service)        │
├─────────────────────────────────────────┤
│               Domain                    │
│  (Core Business Logic, ConfigNode)      │
├─────────────────────────────────────────┤
│            Infrastructure               │
│  (DI Container, Providers, Drivers)     │
└─────────────────────────────────────────┘
```

#### 依存関係の流れ
```
外部システム → Infrastructure → Application → Domain
     ↓              ↓              ↓
   Drivers    →  Providers  →  Services  →  Entities
   
※ 循環依存回避のため：
- ConfigNodeは Domain に配置
- TypeSafeConfigNodeManager は Application に配置  
- 設定ファイル読み込みは Infrastructure の ConfigProvider が担当
```

### 2.2 主要レイヤー
- **Core Layer** (`/src/core/`): ビジネスロジック、ドメインモデル
  - ConfigNode (Domain Entity)
- **Infrastructure Layer** (`/src/infrastructure/`): 副作用処理、外部システム連携
  - ConfigProvider (設定ファイル読み込み)
- **Application Layer** (`/src/application/`): アプリケーションサービス
  - TypeSafeConfigNodeManager (設定管理サービス)
- **Operations Layer** (`/src/operations/`): 操作抽象化、インターフェース定義

**注**: `/src/configuration/` は Application Layer の一部として統合

## 3. 機能要件

### 3.1 コア機能

#### 3.1.1 ワークフロー実行
- **複合リクエスト実行**: Docker/Python/Shell/Fileの組み合わせ処理
- **並列実行対応**: 複数タスクの効率的な並列処理
- **エラーハンドリング**: 包括的なエラー分類と回復処理
- **実行履歴管理**: SQLiteベースの実行履歴追跡

#### 3.1.2 多言語対応
- **Python**: PyPy/CPython対応、型チェック、テスト実行
- **C++**: GCC/Clangコンパイル、最適化オプション対応
- **Rust**: Cargo統合、デバッグ/リリースビルド
- **言語切り替え**: 動的な言語環境切り替え

#### 3.1.3 実行環境管理
- **Docker統合**: セキュアなコンテナ実行環境
- **ローカル実行**: 直接ローカル環境での実行
- **環境テンプレート**: 言語別実行環境テンプレート
- **依存関係管理**: 自動的な依存関係解決

### 3.2 設定管理システム

#### 3.2.1 型安全な設定管理
- **TypeSafeConfigNodeManager**: 型指定必須の設定取得API
- **ConfigNode**: グラフ構造による階層設定解決
- **テンプレート展開**: `{key}` 形式の動的変数置換
- **設定バリデーション**: カスタムバリデーター対応

#### 3.2.2 階層化設定システム
```
優先度: Runtime > Language > Shared > System
│
├── Runtime Config (実行時設定)
├── Language Config (言語固有設定)
├── Shared Config (共有設定)
└── System Config (システムデフォルト)
```

#### 3.2.3 設定ファイル構造
- **システム設定**: `/config/system/` - Docker、言語、タイムアウト設定
- **環境設定**: `/contest_env/` - コンテスト環境、言語別設定
- **テンプレート**: `/contest_template/` - 言語別コードテンプレート

### 3.3 依存性注入システム

#### 3.3.1 DIコンテナー
- **列挙型キー**: `DIKey` enumによる型安全な依存管理
- **自動依存解決**: リフレクションベースの引数注入
- **オーバーライド機能**: テスト用モック注入対応
- **遅延ロード**: パフォーマンス最適化のための遅延初期化

#### 3.3.2 プロバイダー群
- **JSONProvider**: JSON操作の抽象化
- **SQLiteProvider**: データベース操作
- **OSProvider**: OS操作の抽象化
- **FileProvider**: ファイル操作の抽象化
- **TimeProvider**: 時間操作の抽象化

## 4. 非機能要件

### 4.1 パフォーマンス要件
- **設定解決速度**: 
  - キャッシュヒット時: < 10μs (マイクロ秒)
  - キャッシュミス時: < 1ms (ミリ秒)
  - テンプレート展開: < 5ms
- **コマンド実行応答性**: CLI開始から実行開始まで < 100ms
- **多層キャッシュ**: 型変換、テンプレート展開、ExecutionConfigキャッシュによる高速化
- **ファイル統合効果**: 設定ファイル統合による読み込み時間短縮（目標10倍以上）
- **メモリ効率**: LRUキャッシュによる効率的なメモリ使用（最大100MB制限）

### 4.2 型安全性要件
- **型指定必須**: すべての設定取得で戻り値型の明示的指定
- **静的型チェック**: mypy による開発時型検証
  - `--strict` モードでの型チェック必須
  - Generic型を活用した型安全なAPI設計
- **ランタイム検証**: 実行時の型チェックと適切なエラー報告
  - pydantic または typing_extensions.TypedDict 活用
- **バリデーション**: カスタムバリデーターによる設定値検証
  - 型変換失敗時の詳細エラーメッセージ

### 4.3 保守性要件
- **責務分離**: Clean Architectureによる明確な責務分離
- **副作用制限**: Infrastructure層のみでの副作用処理
- **テスタビリティ**: 完全なDI対応によるユニットテスト容易性
- **拡張性**: 新機能追加時の影響範囲最小化

### 4.4 信頼性要件
- **エラーハンドリング**: 包括的なエラー分類と適切な回復処理
- **ログ管理**: 構造化ログによる問題追跡
- **設定検証**: 起動時の設定整合性チェック
- **冗長性**: 重要な処理での冗長性確保

## 5. 技術制約

### 5.1 設計制約
- **デフォルト値禁止**: グローバルなデフォルト値使用禁止
- **副作用制限**: Infrastructure層以外での副作用禁止
- **フォールバック禁止**: エラーを見逃す可能性を回避
- **引数デフォルト値禁止**: 呼び出し元での値準備徹底

### 5.2 技術スタック
- **言語**: Python 3.8+
- **アーキテクチャ**: Clean Architecture
- **型チェック**: mypy (--strict モード)
- **データベース**: SQLite (履歴管理)
- **コンテナ**: Docker (実行環境)
- **設定形式**: JSON (YAML拡張予定)
- **バリデーション**: pydantic または typing_extensions
- **テスト**: pytest, hypothesis

### 5.3 開発制約
- **循環インポート禁止**: 遅延インポートによる強引な解決禁止
- **密結合回避**: 適切な依存性注入による疎結合設計
- **互換性維持**: 既存インターフェースの後方互換性維持
- **コード品質**: ruffによる厳格なリンティング

## 6. インターフェース設計

### 6.1 CLI インターフェース
```bash
# 基本実行
./cph.sh [arguments...]

# 例: Python実行
./cph.sh python run --problem=A

# 例: Docker環境でのC++実行  
./cph.sh cpp run --env=docker --problem=B

# 直接Python実行
PYTHONPATH=src python3 -m src.main [arguments...]
```

**実装詳細**:
- エントリーポイント: `src/core/main/main.py`
- CLIアプリケーション: `src/core/cli_app/cli_app.py`
- Clean Architecture準拠の段階的初期化
- 設定管理とDI容器の統合

### 6.2 設定API
```python
# 型安全な設定取得
timeout = config_manager.resolve_config(['timeout', 'default'], int)
debug_mode = config_manager.resolve_config(['debug'], bool)

# テンプレート展開
path = config_manager.resolve_template_typed(
    "{workspace}/contests/{contest_name}/{problem_name}",
    context,
    str
)

# 実行設定生成
execution_config = config_manager.create_execution_config(
    contest_name="abc123",
    problem_name="problem_a",
    language="python",
    env_type="local",
    command_type="run"
)
```

### 6.3 依存注入API
```python
# DIコンテナー登録
infrastructure.register(DIKey.FILE_DRIVER, _create_file_driver)

# 依存解決
file_driver = infrastructure.resolve(DIKey.FILE_DRIVER)

# モック注入（テスト用）
infrastructure.override(DIKey.FILE_DRIVER, mock_file_driver)
```

## 7. データ設計

### 7.1 設定データ構造
```json
{
  "python": {
    "language_id": "python",
    "source_file_name": "{problem_name}.py",
    "run_command": "python3 {source_file_name}",
    "timeout": 5
  },
  "docker_defaults": {
    "docker_options": {
      "detach": false,
      "interactive": true,
      "tty": true,
      "remove": true
    }
  }
}
```

### 7.2 実行履歴データ
```python
@dataclass
class ExecutionHistory:
    id: int
    timestamp: datetime
    language: str
    command_type: str
    exit_code: int
    execution_time: float
    context: dict
```

### 7.3 ConfigNodeグラフ構造
```python
class ConfigNode:
    key: str
    value: Any
    children: Dict[str, ConfigNode]
    parent: Optional[ConfigNode]
    edges: List[ConfigEdge]
```

## 8. 運用要件

### 8.1 ログ管理
- **構造化ログ**: JSON形式での構造化ログ出力
- **ログレベル**: DEBUG, INFO, WARNING, ERROR, CRITICAL
- **ログローテーション**: ファイルサイズ・日時ベースのローテーション
- **デバッグモード**: `--debug` フラグによる詳細ログ出力

### 8.2 監視・メトリクス
- **実行時間監視**: 各操作の実行時間測定
- **エラー監視**: エラー発生率とパターン分析
- **リソース監視**: メモリ・CPU使用量追跡
- **設定利用状況**: 設定項目の使用頻度分析

### 8.3 バックアップ・復旧
- **設定バックアップ**: 重要設定ファイルの自動バックアップ
- **実行履歴保持**: SQLiteデータベースでの履歴管理
- **環境復旧**: テンプレートからの環境再構築機能

## 9. セキュリティ要件

### 9.1 Docker セキュリティ
- **権限制限**: 最小権限でのコンテナ実行
- **ネットワーク分離**: 不要な外部通信の遮断
- **リソース制限**: CPU・メモリ使用量の制限
- **セキュリティプロファイル**: AppArmorまたはSeccompの活用

### 9.2 ファイルシステムセキュリティ
- **パス検証**: ディレクトリトラバーサル攻撃の防御
- **権限管理**: 適切なファイル・ディレクトリ権限設定
- **一時ファイル**: セキュアな一時ファイル処理
- **設定保護**: 機密設定情報の適切な保護

## 10. テスト要件

### 10.1 テスト戦略
- **ユニットテスト**: 各コンポーネントの個別テスト
- **統合テスト**: コンポーネント間の連携テスト
- **E2Eテスト**: エンドツーエンドでの動作テスト
- **パフォーマンステスト**: 性能要件の検証

### 10.2 テスト環境
- **モック対応**: 完全なDI対応によるモック注入
- **テストフィクスチャ**: pytest fixtures による環境構築
- **プロパティベーステスト**: hypothesis による網羅的テスト
- **並列テスト**: pytest-xdist による高速テスト実行

## 11. 移行・導入要件

### 11.1 既存システムからの移行
- **後方互換性**: 既存インターフェースの維持
- **段階的移行**: 機能単位での段階的移行対応
- **データ移行**: 設定・履歴データの移行支援
- **移行検証**: 移行後の動作検証機能

### 11.2 導入支援
- **セットアップスクリプト**: 自動環境構築スクリプト
- **設定ウィザード**: 初期設定の対話的設定支援
- **ドキュメント**: 包括的な導入・利用ドキュメント
- **サンプル**: 言語別の実装サンプル提供

## 12. 拡張性要件

### 12.1 言語拡張
- **プラグインアーキテクチャ**: 新言語の容易な追加
- **言語定義**: 宣言的な言語設定定義
- **コンパイラ統合**: 各言語コンパイラとの統合
- **依存関係管理**: 言語固有の依存関係解決

### 12.2 機能拡張
- **ドライバ拡張**: 新実行環境ドライバの追加
- **フォーマッタ拡張**: カスタムフォーマッタの実装
- **バリデータ拡張**: カスタム検証ルールの追加
- **プロバイダ拡張**: 新プロバイダの統合

---

## 変更履歴
- v1.1 (2025-06-25): 論理的整合性改善版 - レビュー結果に基づく修正
  - パフォーマンス要件を現実的な値に修正（0.1-5μs → キャッシュヒット時10μs）
  - Clean Architecture依存関係図を追加・明確化
  - Python型安全性実装方針を具体化（mypy --strict、pydantic活用）
  - CLI実装例を実際のプロジェクト構造に合わせて修正
  - Configuration Layerの位置づけをApplication Layerに統合
- v1.0 (2025-06-25): 初版作成 - 現在のプロジェクト構造を基にした要件定義