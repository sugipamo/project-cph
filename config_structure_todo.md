# 設定ファイル構造の分析

## 現状の構造

### ファイル構成
- `mod.rs`: 設定モジュールのエントリーポイント
- YAML設定ファイル群:
  - `languages.yaml`: 言語設定
  - `sites.yaml`: サイト設定
  - `oj.yaml`: オンラインジャッジ設定
  - `docker.yaml`: Docker設定
  - `commands.yaml`: コマンド設定
- 対応するRust実装:
  - `languages.rs`
  - `sites.rs`
  - `oj.rs`
  - `commands.rs`

### 実装状況

#### 良好な点
1. 設定の分離
   - 各機能ごとに設定ファイルが分離されている
   - YAMLによる可読性の高い設定形式
   - 設定パスの一元管理

2. 型安全性
   - `serde`による型付けされたデシリアライズ
   - 各設定に対応する明確な構造体定義

#### 課題点
1. 設定ファイルの分散
   - 各YAMLファイルが独立して存在
   - 設定間の関連性が不明確
   - 重複する可能性のある設定項目

2. 実装の重複
   - 各設定ファイルに対して個別の読み込みロジック
   - エラーハンドリングが統一されていない
   - 共通機能の抽象化が不足

3. 設定の検証
   - バリデーションロジックが不統一
   - 設定間の整合性チェックが不足
   - デフォルト値の扱いが不明確

## 改善提案

1. 設定の統合
   - 共通の設定管理トレイトの導入
   - 設定読み込みの抽象化
   - 設定間の依存関係の明確化

2. バリデーション機構の統一
   - 共通のバリデーションフレームワーク
   - 設定間の整合性チェック機構
   - エラーメッセージの標準化

3. 設定の階層化
   - 設定の継承関係の導入
   - デフォルト値の体系化
   - オーバーライド機構の整備

4. テスト容易性の向上
   - モック設定の導入
   - 設定変更のテスト支援
   - 設定の整合性テスト

## 次のステップ

1. 共通の設定管理トレイトの設計と実装
   ```rust
   trait ConfigLoader {
       type Config;
       fn load(path: PathBuf) -> Result<Self::Config>;
       fn validate(&self) -> Result<()>;
   }
   ```

2. 設定の階層構造の設計
   ```rust
   struct AppConfig {
       languages: LanguageConfig,
       sites: SiteConfig,
       oj: OJConfig,
       // 共通設定や依存関係の管理
   }
   ```

3. バリデーション機構の実装
   - 型レベルでの制約
   - ランタイムチェック
   - エラー報告の統一

4. テストフレームワークの整備
   - 設定ファイルのモック
   - テストヘルパー
   - 統合テスト

## 実装の優先順位

1. 共通トレイトの導入
2. 設定の階層化
3. バリデーション機構
4. テストフレームワーク

各改善は段階的に行い、既存の機能を維持しながら進める必要があります。 